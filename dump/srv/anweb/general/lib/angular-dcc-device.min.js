webpackJsonp(
  [0],
  [
    function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__(1);
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var device = angular.module('dcc.device', []);
      __webpack_require__(2)('dcc.device'),
        device.factory('device', [
          'somovd',
          function(somovd) {
            return {
              funcs: __webpack_require__(5),
              profile: __webpack_require__(80),
              system: {
                reboot: somovd.reboot,
                save: somovd.save,
                reset: somovd.reset,
                backup: somovd.backup,
              },
            };
          },
        ]);
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      function somovdToNative(profile) {
        var result = {};
        return (
          (profile = prepareProfile(profile, 'somovd')),
          funcs.deepExtend(result, getBasicParams(profile)),
          funcs.deepExtend(result, convertParams(profile, 'native')),
          result
        );
      }
      function nativeToSomovd(profile) {
        var result = {};
        return (
          (profile = prepareProfile(profile, 'native')),
          funcs.deepExtend(result, getBasicParams(profile)),
          funcs.deepExtend(result, convertParams(profile, 'somovd')),
          result
        );
      }
      function getConvertModule(name) {
        var modules = {
          WAN: wan,
          LAN: lan,
          VLAN: vlan,
          WiFi: wifi,
          TR69: tr69,
          SystemPassword: syspassword,
          RemoteUpdate: remoteupdate,
          SystemTime: systime,
          SystemLanguage: syslang,
          VoIP: voip,
          EtherWAN: etherwan,
          DeviceMode: devicemode,
        };
        return _.isUndefined(modules[name]) ? null : modules[name];
      }
      function getConvertViewModules(view) {
        var modules = _.map(view, function(value, name) {
          return /^Config.SystemPassword./.test(name)
            ? 'SystemPassword'
            : void 0;
        });
        return _.compact(_.uniq(modules));
      }
      function moduleUnsupported(module) {
        return _.isObject(module) && _.isEmpty(module);
      }
      function moduleIsNotSet(module) {
        return _.isNull(module);
      }
      function getPrepareModule(classDevice) {
        var modules = { DIR: [], DSL: [ifgroups] };
        return _.isUndefined(modules[classDevice]) ? [] : modules[classDevice];
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        wan = __webpack_require__(81),
        wifi = __webpack_require__(89),
        vlan = __webpack_require__(98),
        ifgroups = __webpack_require__(106),
        tr69 = __webpack_require__(108),
        remoteupdate = __webpack_require__(109),
        syspassword = __webpack_require__(110),
        systime = __webpack_require__(111),
        syslang = __webpack_require__(112),
        voip = __webpack_require__(113),
        etherwan = __webpack_require__(118),
        lan = __webpack_require__(119),
        devicemode = __webpack_require__(123);
      module.exports = {
        somovdToNative: somovdToNative,
        nativeToSomovd: nativeToSomovd,
        wan: wan,
        wifi: wifi,
        vlan: vlan.converter,
      };
      var getBasicParams = function(profile) {
          return {
            RegionID: profile.RegionID,
            Provider: profile.Provider,
            Description: profile.Description,
            LinkType: profile.LinkType,
            DeviceClass: profile.DeviceClass,
          };
        },
        convertParams = function(profile, type) {
          var result = { Config: {} },
            config = profile.Config;
          if (!config) return result;
          _.each(config, function(section, name) {
            var module = getConvertModule(name);
            if (!moduleUnsupported(module)) {
              if (moduleIsNotSet(module))
                return void (result.Config[name] = funcs.deepClone(section));
              'native' == type &&
                funcs.deepExtend(result, module.convertSomovdToNative(profile)),
                'somovd' == type &&
                  funcs.deepExtend(
                    result,
                    module.convertNativeToSomovd(profile)
                  );
            }
          });
          var view = profile.View,
            viewModules = getConvertViewModules(view);
          return (
            _.each(viewModules, function(name) {
              var module = getConvertModule(name);
              moduleUnsupported(module) ||
                ('native' == type &&
                  _.has(module, 'convertViewSomovdToNative') &&
                  funcs.deepExtend(
                    result,
                    module.convertViewSomovdToNative(profile)
                  ));
            }),
            result
          );
        },
        prepareProfile = function(profile, type) {
          var workCopy = funcs.deepClone(profile),
            deviceClass = (workCopy.Config,
            _.isUndefined(profile.DeviceClass) ? 'DIR' : profile.DeviceClass),
            modules = getPrepareModule(deviceClass);
          return (
            _.each(modules, function(module) {
              'native' == type && module.transformNative(workCopy),
                'somovd' == type && module.transformSomovd(workCopy);
            }),
            workCopy
          );
        };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        convertSomovdToNative: __webpack_require__(82),
        convertNativeToSomovd: __webpack_require__(86),
        pppoe: __webpack_require__(88).pppoe,
        pppoedual: __webpack_require__(88).pppoedual,
        pppoev6: __webpack_require__(88).pppoev6,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function wan(data) {
          function prepare(wan) {
            return _.map(wan, function(conn) {
              var mKey = _.keys(conn)[0];
              return (conn[mKey].is_wan = !0), conn;
            });
          }
          function convert(wan) {
            function normalize(data) {
              function isNotConnection(obj) {
                return _.isUndefined(obj.Connection);
              }
              function isEmptyConnection(obj) {
                return 0 == obj.ConnectionNumberOfEntries;
              }
              return (
                _.each(data, function(obj, key) {
                  (isNotConnection(obj) || isEmptyConnection(obj)) &&
                    delete data[key];
                }),
                data
              );
            }
            return _.map(wan, function(conn) {
              return normalize(native.build({ iface_names: conn }));
            });
          }
          function merge(data) {
            function has(type) {
              return wan[type];
            }
            function add(obj, type, index) {
              (wan[type] = { Connection: {} }), set(obj, type, index);
            }
            function set(obj, type, index) {
              var inst = maxInstance(type) + 1;
              (obj.Connection[1].__Index = index),
                (wan[type].Connection[inst] = obj.Connection[1]),
                (wan[type].ConnectionNumberOfEntries = inst);
            }
            function maxInstance(type) {
              return wan[type].ConnectionNumberOfEntries || 0;
            }
            var wan = {};
            return (
              _.each(data, function(conns, index) {
                _.each(conns, function(obj, type) {
                  has(type) ? set(obj, type, index) : add(obj, type, index);
                });
              }),
              wan
            );
          }
          return merge(convert(prepare(data)));
        }
        function view(views, wan) {
          function isWAN(path) {
            return /^Config.WAN/.test(path);
          }
          function isMedia(path) {
            return !isServices(path) && !isTunnels(path);
          }
          function isServices(path) {
            return /services/.test(path);
          }
          function isTunnels(path) {
            return /tunnels/.test(path);
          }
          function getSomovdParams(path) {
            if (isTunnels(path))
              var regexp = /^Config\.WAN\[(.+)\]\.([^.]+)\.services\.([^.]+)\.tunnels\.([^.]+)\.(.+)/g;
            else if (isServices(path))
              var regexp = /^Config\.WAN\[(.+)\]\.([^.]+)\.services\.([^.]+)\.(.+)/g;
            else var regexp = /^Config\.WAN\[(.+)\]\.([^.]+)\.(.+)/g;
            var params = regexp.exec(path),
              len = params.length;
            return {
              index: params[1],
              mediaKey: isTunnels(path) ? void 0 : params[2],
              connectionKey: isMedia(path) ? void 0 : params[len - 2],
              layer: (len - 2).toString(),
              lowerLayer: isMedia(path) ? void 0 : params[len - 3],
              param: params[len - 1],
            };
          }
          function getConnectionsParams(wan) {
            function getMediaKey(conn) {
              for (var obj = conn.Media; ; ) {
                if (!obj) return;
                if (obj.__Key) return obj.__Key;
                var obj = obj[_.keys(obj)[0]];
              }
            }
            var result = [];
            return (
              _.each(wan, function(obj, type) {
                var conns = obj.Connection;
                _.each(conns, function(conn, inst) {
                  result.push({
                    type: type,
                    inst: inst,
                    index: conn.__Index,
                    mediaKey: getMediaKey(conn),
                    connectionKey: conn.__Key,
                    layer: conn.__Layer,
                    lowerLayer: conn.__LowerLayer,
                    mediaType: conn.MediaType,
                  }),
                    delete conn.__Index;
                });
              }),
              result
            );
          }
          function namingSchema(param) {
            var schema = {
              name: 'Name',
              username: 'Username',
              password: 'Password',
              servicename: 'ServiceName',
              apn: 'APN',
              dial_num: 'DialNumber',
              ip: 'StaticIP.1.Address',
              mask: 'StaticIP.1.SubnetMask',
              gwip: 'GatewayIPAddress',
              dns_prim: 'DNSServer1',
              dns_sec: 'DNSServer2',
              mac: 'Media.Ethernet.MACAddress',
              'pvc_settings.vpi': 'Media.DSL.ATM.DestinationAddress',
              'pvc_settings.vci': 'Media.DSL.ATM.DestinationAddress',
            };
            return schema[param];
          }
          function findMedia(connsParams, somovdParams) {
            return _.find(connsParams, function(conn) {
              return (
                compareParam(conn.index, somovdParams.index) &&
                compareParam(conn.mediaKey, somovdParams.mediaKey)
              );
            });
          }
          function findConnection(connsParams, somovdParams) {
            return _.find(connsParams, function(conn) {
              return (
                compareParam(conn.index, somovdParams.index) &&
                compareParam(conn.layer, somovdParams.layer) &&
                compareParam(conn.mediaKey, somovdParams.mediaKey) &&
                compareParam(conn.connectionKey, somovdParams.connectionKey) &&
                compareParam(conn.lowerLayer, somovdParams.lowerLayer)
              );
            });
          }
          function compareParam(val1, val2) {
            return (_.isUndefined(val1) && _.isUndefined(val2)) || val1 == val2;
          }
          var result = {},
            connsParams = getConnectionsParams(wan);
          return (
            _.each(views, function(value, path) {
              if (isWAN(path)) {
                var somovdParams = getSomovdParams(path),
                  nativeParams = isMedia(path)
                    ? findMedia(connsParams, somovdParams)
                    : findConnection(connsParams, somovdParams),
                  param = namingSchema(somovdParams.param);
                if (nativeParams && param) {
                  var newPath =
                    'Config.WAN.' +
                    nativeParams.type +
                    '.Connection.' +
                    nativeParams.inst +
                    '.' +
                    param;
                  result[newPath] = value;
                }
              }
            }),
            result
          );
        }
        return { wan: wan, view: view };
      }
      var _ = __webpack_require__(3),
        native = __webpack_require__(83);
      module.exports = function(profile) {
        var build = new Build(),
          wan = build.wan(profile.Config.WAN),
          view = build.view(profile.View, wan);
        return { Config: { WAN: wan }, View: view };
      };
    },
    ,
    ,
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function wan(data) {
          return somovd(data);
        }
        return { wan: wan };
      }
      var somovd = (__webpack_require__(3), __webpack_require__(87));
      module.exports = function(profile) {
        var build = new Build(),
          wan = build.wan(profile.Config.WAN);
        return { Config: { WAN: wan } };
      };
    },
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      function _nativeToSomovd(data, type) {
        var input = template(data, type),
          output = somovd(input.Config.WAN);
        return getService(output[0]);
      }
      function template(data, type) {
        function simpleMedia() {
          return {
            MediaType: 'Ethernet',
            Media: { Ethernet: { __Key: 'create' } },
          };
        }
        function simpleConnection() {
          return { __Key: 'create', __Layer: '3', __LowerLayer: 'create' };
        }
        var connection = _.extend(data, simpleMedia(), simpleConnection()),
          wan = {};
        return (
          (wan[type] = {
            Connection: { 1: connection },
            ConnectionNumberOfEntries: 1,
          }),
          { Config: { WAN: wan } }
        );
      }
      function getService(ifaces) {
        var mKey = _.keys(ifaces)[0];
        if (!mKey) return null;
        var sKey = _.keys(ifaces[mKey].services)[0];
        return sKey ? ifaces[mKey].services[sKey] : null;
      }
      var _ = __webpack_require__(3),
        somovd = __webpack_require__(87);
      module.exports = {
        pppoe: {
          nativeToSomovd: function(data) {
            return _nativeToSomovd(data, 'PPPoE');
          },
        },
        pppoedual: {
          nativeToSomovd: function(data) {
            return _nativeToSomovd(data, 'PPPoEDual');
          },
        },
        pppoev6: {
          nativeToSomovd: function(data) {
            return _nativeToSomovd(data, 'PPPoEv6');
          },
        },
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        convertSomovdToNative: __webpack_require__(90),
        convertNativeToSomovd: __webpack_require__(92),
        convertSomovdToNativeFull: __webpack_require__(97),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function wifi(data) {
          prepareData(data);
          var result = native.build({ $wifi: { 35: data } });
          return (
            delete result.EndPoint,
            delete result.EndPointNumberOfEntries,
            result
          );
        }
        function view(views) {
          function isWiFi(key) {
            return !/^Config.WiFi./.test(key);
          }
          function is5GHz(key) {
            return /5G_/.test(key);
          }
          function hasMbssid(key) {
            return /(5G_)?mbssid/.test(key);
          }
          function getMbssidInx(key) {
            var inx = key.match(/(?:5G_)?mbssid\[(.)\]/)[1];
            return parseInt(inx) + 1;
          }
          function namingSchema(param) {
            var schema = {
              Radio: 'Enable',
              Channel: 'Channel',
              '5G_Radio': 'Enable',
              '5G_Channel': 'Channel',
              SSID: 'SSID',
              AuthMode: 'ModeEnabled',
              WPAPSK: 'PreSharedKey',
              WifiBroadcast: 'Broadcast',
              apcli: 'EndPoint',
            };
            return schema[param];
          }
          var newView = {};
          return (
            _.each(views, function(value, key) {
              if (!isWiFi(key)) {
                var param = key.match(/(?:.+)\.(.+)$/)[1],
                  newKey = 'Config.WiFi.Radio.';
                (newKey += is5GHz(key) ? '2.' : '1.'),
                  hasMbssid(key) &&
                    (newKey += 'AccessPoint.' + getMbssidInx(key) + '.');
                var newParam = namingSchema(param);
                newParam && ((newKey += newParam), (newView[newKey] = value));
              }
            }),
            newView
          );
        }
        function prepareData(data) {
          var params = {
            ModeAvailable: [
              { Name: '802.11 B/G/N mixed', Id: '9' },
              { Name: '802.11 N', Id: '15' },
              { Name: '802.11 B', Id: '1' },
              { Name: '802.11 G', Id: '4' },
            ],
            '5G_ModeAvailable': [
              { Name: '802.11 A', Id: '5' },
              { Name: '802.11 A/N mixed', Id: '12' },
              { Name: '802.11 N', Id: '15' },
              { Name: '802.11 AC', Id: '18' },
              { Name: '802.11 AC/N mixed', Id: '21' },
              { Name: '802.11 AC/A/N mixed', Id: '24' },
            ],
            AuthAvailable: [
              { Name: 'Open', Id: 'OPEN' },
              { Name: 'Shared', Id: 'SHARED' },
              { Name: 'WPA', Id: 'WPA' },
              { Name: 'WPA-PSK', Id: 'WPAPSK' },
              { Name: 'WPA2', Id: 'WPA2' },
              { Name: 'WPA2-PSK', Id: 'WPA2PSK' },
              { Name: 'WPA/WPA2 mixed', Id: 'WPA1WPA2' },
              { Name: 'WPA-PSK/WPA2-PSK mixed', Id: 'WPAPSKWPA2PSK' },
            ],
          };
          data.ModeAvailable || (data.ModeAvailable = params.ModeAvailable),
            data['5G_ModeAvailable'] ||
              (data['5G_ModeAvailable'] = params['5G_ModeAvailable']),
            data.AuthAvailable || (data.AuthAvailable = params.AuthAvailable);
        }
        return { wifi: wifi, view: view };
      }
      var _ = __webpack_require__(3),
        native = __webpack_require__(91);
      module.exports = function(profile) {
        var build = new Build(),
          wifi = build.wifi(profile.Config.WiFi),
          view = build.view(profile.View);
        return { Config: { WiFi: wifi }, View: view };
      };
    },
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function wifi(data) {
          var result = somovd.build({ $wifi: data });
          return result[35];
        }
        return { wifi: wifi };
      }
      var somovd = (__webpack_require__(3), __webpack_require__(93));
      module.exports = function(profile) {
        var build = new Build(),
          wifi = build.wifi(profile.Config.WiFi);
        return { Config: { WiFi: wifi } };
      };
    },
    ,
    ,
    ,
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      var native = __webpack_require__(91);
      module.exports = function(params) {
        return native.build({ $wifi: params });
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        vlan = (__webpack_require__(3), __webpack_require__(99));
      module.exports = (function() {
        function somovdToNative(profile) {
          var workCopy = funcs.deepClone(profile),
            profileVlan = workCopy.Config.VLAN,
            profileView = workCopy.View;
          vlan.normalization.somovd.ports(profileVlan);
          var initVlans = vlan.initialization(profileVlan),
            convertProfile = vlan.converter.somovdToNative(initVlans),
            convertView = vlan.view['native'](profileView, profileVlan),
            result = { Config: { VLAN: convertProfile }, View: convertView };
          return result;
        }
        function nativeToSomovd(profile) {
          var workCopy = funcs.deepClone(profile),
            profileVlan = workCopy.Config.VLAN,
            profileView = workCopy.View,
            convertProfile = vlan.converter.nativeToSomovd(profileVlan),
            convertView = vlan.view.somovd(
              profileView,
              convertProfile,
              profileVlan
            ),
            result = { Config: { VLAN: convertProfile }, View: convertView };
          return result;
        }
        return {
          convertSomovdToNative: somovdToNative,
          convertNativeToSomovd: nativeToSomovd,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        initialization: __webpack_require__(100),
        normalization: __webpack_require__(103),
        view: __webpack_require__(104),
        converter: __webpack_require__(105),
        template: __webpack_require__(102),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var helper = (__webpack_require__(5),
        __webpack_require__(3),
        __webpack_require__(101)),
        template = __webpack_require__(102);
      module.exports = function(profile, options) {
        function completeVlansGroup(groups, portsMap, options) {
          var lan = groups.lan,
            wanu = groups.wanu,
            want = groups.want;
          if (
            (groups.bridge,
            lan.length ||
              lan.push(template.createLanGroup({ ports: portsMap.lanGroup })),
            !wanu.length && !options.withoutDefaultWanU)
          ) {
            var options = { ports: portsMap.wan };
            want.length && (options.name = want[0].name),
              wanu.push(template.createWanUGroup(options));
          }
        }
        var options = options || {},
          vlans = [],
          portsMap = helper.groupPortsByType(profile),
          groups = helper.groupVlansByType(profile);
        return (
          completeVlansGroup(groups, portsMap, options),
          (vlans = helper.unionGroupVlansByType(groups)),
          { avail_ports: profile.avail_ports, vlans: vlans }
        );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = (__webpack_require__(5), __webpack_require__(3));
      module.exports = (function() {
        function unionGroupVlansByType(groups) {
          var vlans = [];
          return (
            (vlans = vlans.concat(groups.lan)),
            (vlans = vlans.concat(groups.wanu)),
            (vlans = vlans.concat(groups.want)),
            (vlans = vlans.concat(groups.bridge))
          );
        }
        function groupPortsByType(config) {
          var avail = config.avail_ports,
            wan = getWanPorts(avail),
            lan = getLanPorts(avail),
            wifi = getUseWifiPorts(avail),
            wifina = getNotUseWifiPorts(avail),
            busy = getBusyPorts(config.vlans),
            lanGroup = _.union(_.difference(lan, busy), wifi);
          return {
            all: avail,
            wan: wan,
            lan: lan,
            wifi: wifi,
            wifina: wifina,
            lanGroup: lanGroup,
            busy: busy,
          };
        }
        function groupVlansByType(config) {
          var vlans = config.vlans,
            groups = { lan: [], wanu: [], want: [], bridge: [] },
            lan = groups.lan,
            wanu = groups.wanu,
            want = groups.want,
            bridge = groups.bridge;
          return (
            _.each(vlans, function(vlan) {
              var type = getVlanSectionType(vlan);
              switch (type) {
                case 'lan':
                  lan.push(vlan);
                  break;
                case 'wanu':
                  wanu.push(vlan);
                  break;
                case 'want':
                  want.push(vlan);
                  break;
                case 'bridge':
                  bridge.push(vlan);
              }
            }),
            groups
          );
        }
        function getVlanSectionService(vlan) {
          return vlan.name && !isLanType(vlan) ? vlan.name : '';
        }
        function getVlanSectionType(vlan) {
          var type = vlan.dest;
          return (
            'wan' == type && (type = isWanUGroup(vlan) ? 'wanu' : 'want'), type
          );
        }
        function getVlanSectionVlanID(vlan) {
          return vlan.vid ? vlan.vid : null;
        }
        function getVlanSectionQoS(vlan) {
          var qos = 0,
            ports = vlan.ports,
            wports = getWanPorts(_.keys(ports));
          if (wports.length) {
            var wport = wports[0];
            qos = _.isUndefined(ports[wport].qos) ? 0 : ports[wport].qos;
          }
          return qos;
        }
        function getVlanSectionConnections(vlan) {
          return _.isUndefined(vlan.connections) ? null : vlan.connections;
        }
        function getVlanSectionPorts(vlan) {
          return vlan.ports ? _.keys(vlan.ports) : [];
        }
        function getVlanSectionPortsWithQoS(vlan) {
          var ports = vlan.ports;
          return _.map(ports, function(port, name) {
            return { name: name, qos: _.isUndefined(port.qos) ? 0 : port.qos };
          });
        }
        function getLanPorts(ports) {
          var __ports = _.chain(ports)
            .difference(getWanPorts(ports))
            .difference(getAllWifiPorts(ports))
            .value();
          return __ports;
        }
        function getWanPorts(ports) {
          return filterByRegExp(ports, /^(internet|port5)/i);
        }
        function getAllWifiPorts(ports) {
          return filterByRegExp(ports, /^wifi/i);
        }
        function getUseWifiPorts(ports) {
          return filterByRegExp(getAllWifiPorts(ports), /[^na]$/);
        }
        function getNotUseWifiPorts(ports) {
          return _.difference(getAllWifiPorts(ports), getUseWifiPorts(ports));
        }
        function getBusyPorts(vlans) {
          return _.chain(vlans)
            .map(function(vlan) {
              return isLanType(vlan) ? [] : getVlanSectionPorts(vlan);
            })
            .flatten()
            .uniq()
            .value();
        }
        function isWanUGroup(vlan) {
          return isWanUports(vlan.ports);
        }
        function isWanUports(vports) {
          function checkPortU(port) {
            return (
              !_.isUndefined(port) &&
              !_.isUndefined(port.tag) &&
              port.tag === !1
            );
          }
          var wports = getWanPorts(_.keys(vports));
          return _.some(wports, function(name) {
            return checkPortU(vports[name]);
          });
        }
        function isLanType(vlan) {
          return 'lan' == getVlanSectionType(vlan);
        }
        function isWanUType(vlan) {
          return 'wanu' == getVlanSectionType(vlan);
        }
        function isWanTType(vlan) {
          return 'want' == getVlanSectionType(vlan);
        }
        function isBridgeType(vlan) {
          return 'bridge' == getVlanSectionType(vlan);
        }
        function isVlanSection(name) {
          var re = new RegExp('^Config.VLAN.');
          return re.test(name);
        }
        function filterByRegExp(data, re) {
          return _.filter(data, function(value) {
            return re.test(value);
          });
        }
        return {
          unionGroupVlansByType: unionGroupVlansByType,
          groupPortsByType: groupPortsByType,
          groupVlansByType: groupVlansByType,
          getVlanSectionService: getVlanSectionService,
          getVlanSectionType: getVlanSectionType,
          getVlanSectionVlanID: getVlanSectionVlanID,
          getVlanSectionQoS: getVlanSectionQoS,
          getVlanSectionConnections: getVlanSectionConnections,
          getVlanSectionPorts: getVlanSectionPorts,
          getVlanSectionPortsWithQoS: getVlanSectionPortsWithQoS,
          isLanType: isLanType,
          isWanUType: isWanUType,
          isWanTType: isWanTType,
          isBridgeType: isBridgeType,
          isVlanSection: isVlanSection,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = (__webpack_require__(5), __webpack_require__(3)),
        template = {};
      (module.exports = template),
        (template.createLanGroup = function(options) {
          var obj = {
            name: 'lan',
            dest: 'lan',
            vid: null,
            ports: template.createVlanPorts(options.ports),
            en: !0,
          };
          return obj;
        }),
        (template.createWanUGroup = function(options) {
          var obj = {
            name: options.name ? options.name : 'internet',
            dest: 'wan',
            en: !0,
            vid: null,
            ports: template.createVlanPorts(options.ports),
          };
          return (
            _.isUndefined(options.connections) ||
              (obj.connections = options.connections),
            obj
          );
        }),
        (template.createWanTGroup = function(options) {
          var obj = {
            name: options.name,
            dest: 'wan',
            vid: options.vid,
            en: !0,
            ports: template.createVlanPorts(options.ports),
          };
          return (
            _.isUndefined(options.connections) ||
              (obj.connections = options.connections),
            obj
          );
        }),
        (template.createBridgeGroup = function(options) {
          var obj = {
            name: options.name,
            dest: 'bridge',
            vid: options.vid,
            en: !0,
            ports: template.createVlanPorts(options.ports),
          };
          return (
            _.isUndefined(options.connections) ||
              (obj.connections = options.connections),
            obj
          );
        }),
        (template.createVlanPorts = function(ports) {
          var result = {};
          return (
            _.each(ports, function(port) {
              if (_.isString(port))
                var name = port,
                  tag = !1,
                  qos = 0;
              else
                var name = port.name,
                  tag = _.isUndefined(port.tag) ? !1 : port.tag,
                  qos = _.isUndefined(port.qos) ? 0 : port.qos;
              result[name] = { tag: tag, qos: qos };
            }),
            result
          );
        });
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      module.exports = (function() {
        function somovdPorts(config) {
          function updateAvailPorts(config) {
            config.avail_ports = _.map(config.avail_ports, function(port) {
              var newPort = getNativePortName(port);
              return _.isNull(newPort) ? port : newPort;
            });
          }
          function updateSomovdVlans(config) {
            var vlans = config.vlans;
            vlans = _.map(vlans, function(vlan) {
              return updateSomovdVlanPorts(vlan), vlan;
            });
          }
          function updateSomovdVlanPorts(vlan) {
            var ports = vlan.ports;
            for (var port in ports) {
              var portObj = ports[port],
                newPort = getNativePortName(port);
              _.isNull(newPort) ||
                ((ports[newPort] = funcs.deepClone(portObj)),
                delete ports[port]);
            }
          }
          updateAvailPorts(config), updateSomovdVlans(config);
        }
        function nativePorts(config) {
          function updateNativeGroups(config) {
            var groups = config.groups;
            _.each(groups, function(group) {
              _.each(group, function(portObj, index) {
                var name = group[index].name,
                  newName = getSomovdPortName(name);
                _.isNull(newName) || (group[index].name = newName);
              });
            });
          }
          updateNativeGroups(config);
        }
        function getNativePortName(port) {
          var newPorts = null,
            portParam = dividePortByParam(port);
          if (_.isEmpty(portParam)) return newPorts;
          var name = portParam.name,
            num = portParam.num,
            schema = _.invert(portsSchema);
          return (
            _.has(schema, name) && (newPorts = schema[name] + num), newPorts
          );
        }
        function getSomovdPortName(port) {
          var newPorts = null,
            portParam = dividePortByParam(port);
          if (_.isEmpty(portParam)) return newPorts;
          var name = portParam.name,
            num = portParam.num;
          return (
            _.has(portsSchema, name) && (newPorts = portsSchema[name] + num),
            newPorts
          );
        }
        function dividePortByParam(port) {
          var re = /^(\w+)(\d+)$/g,
            execes = re.exec(port);
          if (_.isNull(execes)) return {};
          var portName = execes[1] ? execes[1] : '',
            portNum = execes[2] ? execes[2] : '';
          return { name: portName, num: portNum };
        }
        var portsSchema = { port: 'LAN', wifi: 'WIFI' };
        return {
          somovd: { ports: somovdPorts },
          native: { ports: nativePorts },
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = (__webpack_require__(5), __webpack_require__(3)),
        helper = __webpack_require__(101);
      module.exports = (function() {
        function native(view, profile) {
          function getIndex(name) {
            var index = null,
              re = new RegExp('^Config.VLAN.vlans\\[(.*)\\]');
            return re.test(name) && (index = name.match(re)[1]), index;
          }
          var nativeView = {};
          return (
            _.each(view, function(value, name) {
              if (helper.isVlanSection(name)) {
                var arrName = name.split('.'),
                  param = arrName[arrName.length - 1];
                switch (param) {
                  case 'ports':
                    var nativeName = 'Config.VLAN.groups';
                    break;
                  case 'vid':
                  case 'vci':
                  case 'vpi':
                    var index = getIndex(name),
                      vlan = profile.vlans[parseInt(index)],
                      service = helper.getVlanSectionService(vlan),
                      nativeName =
                        'Config.VLAN.services.' + service + '.' + param;
                }
                nativeView[nativeName] = value;
              }
            }),
            nativeView
          );
        }
        function somovd(view, profile, native) {
          var vlans = profile.vlans,
            nativeServices = native.services,
            result = {};
          return (
            _.each(view, function(value, name) {
              if (helper.isVlanSection(name)) {
                name = name.replace(/^Config.VLAN./, '');
                var arrName = name.split('.'),
                  param = arrName[0];
                switch (param) {
                  case 'services':
                    name = name.replace(/^services./, '');
                    var serviceName = name.replace(/.vid$/, ''),
                      nativeParams = {
                        name: serviceName,
                        vid: nativeServices[serviceName].vid,
                      };
                    _.each(vlans, function(vlan, index) {
                      var somovdParams = {
                        name: helper.getVlanSectionService(vlan).split('_')[0],
                        vid: helper.getVlanSectionVlanID(vlan),
                      };
                      if (_.isEqual(nativeParams, somovdParams)) {
                        var somovdName = 'Config.VLAN.vlans[' + index + '].vid';
                        result[somovdName] = value;
                      }
                    });
                    break;
                  case 'groups':
                    _.each(vlans, function(vlan, index) {
                      var somovdName = 'Config.VLAN.vlans[' + index + '].ports';
                      result[somovdName] = value;
                    });
                }
              }
            }),
            result
          );
        }
        return { native: native, somovd: somovd };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = (__webpack_require__(5), __webpack_require__(3)),
        helper = __webpack_require__(101),
        initialization = __webpack_require__(100),
        template = __webpack_require__(102);
      module.exports = (function() {
        function somovdToNative(input, options) {
          function groupVlansServicesByDestination(vlans, portsMap) {
            var services = groupVlansPortsByServices(vlans),
              lan = getNativeGroup(services, portsMap.lan),
              wifi = getNativeGroup(services, portsMap.wifi);
            return { lan: lan, wifi: wifi };
          }
          function groupVlansServicesByType(vlans) {
            var result = {};
            return (
              _.each(vlans, function(vlan) {
                var service = helper.getVlanSectionService(vlan);
                if (
                  !helper.isLanType(vlan) &&
                  (options.useDefaultWANU ||
                    !helper.isWanUType(vlan) ||
                    'internet' != service)
                ) {
                  var type = helper.getVlanSectionType(vlan),
                    vlanId = helper.getVlanSectionVlanID(vlan),
                    qos = helper.getVlanSectionQoS(vlan),
                    connections = helper.getVlanSectionConnections(vlan);
                  (result[service] = { type: type, qos: qos }),
                    helper.isWanUType(vlan) || (result[service].vid = vlanId),
                    _.isNull(connections) ||
                      (result[service].connections = connections);
                }
              }),
              result
            );
          }
          function groupVlansPortsByServices(vlans) {
            var result = {};
            return (
              _.each(vlans, function(vlan) {
                var ports = helper.getVlanSectionPortsWithQoS(vlan),
                  service = helper.getVlanSectionService(vlan);
                result[service] = result[service]
                  ? _.union(result[service], ports)
                  : ports;
              }),
              result
            );
          }
          function getNativeGroup(services, ports) {
            var result = [];
            return (
              _.each(ports, function(port) {
                var service = getServiceByPort(services, port);
                result.push(service);
              }),
              result
            );
          }
          function getServiceByPort(services, port) {
            function containsPort(ports, port) {
              var portNames = _.pluck(ports, 'name');
              return _.contains(portNames, port);
            }
            var result = { name: port, service: '' };
            return (
              _.each(services, function(ports, key) {
                containsPort(ports, port) && (result.service = key);
              }),
              result
            );
          }
          options = options || {};
          var vlans = input.vlans,
            portsMap = helper.groupPortsByType(input),
            groups = groupVlansServicesByDestination(vlans, portsMap),
            services = groupVlansServicesByType(input.vlans);
          return { services: services, groups: groups };
        }
        function nativeToSomovd(input, options) {
          function addToWan(config, options) {
            var vlans = config.vlans,
              ports = options.ports,
              name = options.name;
            _.each(vlans, function(vlan, index) {
              helper.isWanUType(vlan) &&
                (updateVlanSectionPorts(vlan, ports),
                name && (vlan.name = name));
            });
          }
          function addTaggedNAT(config, options) {
            options.name = options.name;
            var portsMap = helper.groupPortsByType(config),
              wports = portsMap.wan;
            options.ports = _.filter(options.ports, function(obj) {
              return _.contains(wports, obj.name);
            });
            var groups = helper.groupVlansByType(config),
              want = groups.want;
            want.push(template.createWanTGroup(options)),
              (config.vlans = helper.unionGroupVlansByType(groups));
          }
          function addToBridge(config, options) {
            var vlans = config.vlans;
            vlans.push(template.createBridgeGroup(options));
          }
          function cutFromLan(config, ports) {
            var vlans = config.vlans;
            _.each(vlans, function(vlan, index) {
              helper.isLanType(vlan) && removeVlanSectionPorts(vlan, ports);
            });
          }
          function cutFromWan(config, ports) {
            var vlans = config.vlans;
            _.each(vlans, function(vlan, index) {
              helper.isWanUType(vlan) && removeVlanSectionPorts(vlan, ports);
            });
          }
          function groupNativeServicesByPorts(input) {
            var result = {},
              services = input.services,
              groups = input.groups;
            return (
              _.each(groups, function(group) {
                _.each(group, function(obj) {
                  var service = obj.service,
                    name = obj.name,
                    qos = getNativeQoS(input, service);
                  result[service] || (result[service] = []),
                    result[service].push({ name: name, qos: qos, tag: !1 });
                });
              }),
              _.each(services, function(obj, name) {
                var type = obj.type;
                switch ((result[name] || (result[name] = []), type)) {
                  case 'wanu':
                    result[name].push({
                      name: internetPort,
                      qos: obj.qos ? obj.qos : 0,
                      tag: !1,
                    });
                    break;
                  case 'want':
                  case 'bridge':
                    result[name].push({
                      name: internetPort,
                      qos: obj.qos ? obj.qos : 0,
                      tag: !0,
                    });
                }
              }),
              result
            );
          }
          function getNativePorts(input, internetPort) {
            var portsGroup = groupNativeServicesByPorts(input);
            return _.chain(portsGroup)
              .values()
              .flatten()
              .pluck('name')
              .concat(internetPort)
              .uniq()
              .sort()
              .value();
          }
          function getInternetPort(input) {
            return _.isUndefined(input.__internetPort)
              ? 'internet'
              : input.__internetPort;
          }
          function getNativeQoS(input, name) {
            var services = input.services,
              service = services[name];
            return service && service.qos ? service.qos : 0;
          }
          function correctVlansName(config) {
            var names = [],
              vlans = config.vlans;
            _.each(vlans, function(vlan, index) {
              var name = vlan.name;
              if (_.contains(names, name)) {
                var vid = helper.getVlanSectionVlanID(vlan);
                vlans[index].name =
                  name +
                  '_' +
                  (_.isNull(vid) ? _.random(4096) : vid.toString());
              } else names.push(name);
            });
          }
          function updateVlanSectionPorts(vlan, ports) {
            var vports = vlan.ports;
            _.each(vports, function(obj, port) {
              _.contains(ports, port) || delete vports[port];
            });
            var mports = _.compact(
              _.difference(ports, _.intersection(_.keys(vports), ports))
            );
            if (mports.length) var newPorts = template.createVlanPorts(mports);
            _.extend(vports, newPorts);
          }
          function removeVlanSectionPorts(vlan, ports) {
            var vports = vlan.ports;
            _.each(vports, function(obj, port) {
              _.contains(ports, port) && delete vports[port];
            });
          }
          options = options || {};
          var internetPort = getInternetPort(input),
            availPorts = getNativePorts(input, internetPort),
            nativeVlan = initialization(
              { avail_ports: availPorts, vlans: [] },
              { withoutDefaultWanU: input.__withoutDefaultWanU }
            ),
            servicesPorts = groupNativeServicesByPorts(input),
            portsMap = helper.groupPortsByType(nativeVlan),
            wports = portsMap.wan;
          return (
            _.each(input.services, function(serviceObject, serviceName) {
              var type = serviceObject.type,
                ports = servicesPorts[serviceName],
                portNames = _.pluck(ports, 'name'),
                lports = _.difference(portNames, wports),
                options = {
                  name: serviceName,
                  ports: ports,
                  vid: serviceObject.vid,
                };
              switch (type) {
                case 'wanu':
                  cutFromLan(nativeVlan, lports), addToWan(nativeVlan, options);
                  break;
                case 'want':
                  addTaggedNAT(nativeVlan, options);
                  break;
                case 'bridge':
                  cutFromLan(nativeVlan, lports),
                    cutFromWan(nativeVlan, lports),
                    addToBridge(nativeVlan, options);
              }
            }),
            correctVlansName(nativeVlan),
            nativeVlan
          );
        }
        return {
          somovdToNative: somovdToNative,
          nativeToSomovd: nativeToSomovd,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        converter = __webpack_require__(107),
        vlan = __webpack_require__(99),
        dms = {
          transformSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profileWan = workCopy.Config.WAN,
              profileIfgroups = workCopy.Config.GroupingInterfaces,
              initVlans = converter.createInitVlans(
                profileWan,
                profileIfgroups
              );
            initVlans.length > 0 &&
              (funcs.setValue('Config.VLAN.vlans', initVlans, profile),
              converter.updateSomovdView(profile),
              delete profile.Config.GroupingInterfaces);
          },
          transformNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profileWan = workCopy.Config.WAN,
              profileVlans = workCopy.Config.VLAN;
            if (profileVlans && _.size(profileVlans) > 0) {
              vlan.normalization['native'].ports(profileVlans);
              var result = converter.splitVlans(profileWan, profileVlans);
              converter.updateNativeView(profile),
                funcs.setValue('Config.WAN', result.WAN, profile),
                funcs.setValue(
                  'Config.GroupingInterfaces',
                  result.GroupingInterfaces,
                  profile
                ),
                delete profile.Config.VLAN;
            }
          },
        };
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        vlan = __webpack_require__(99),
        converter = {};
      (module.exports = converter),
        (converter.createInitVlans = function(wan, ifgroups) {
          var vlans = [],
            wanTree = createWanTree(wan),
            wanBridges = findBridgeLevels(wanTree);
          return (
            _.each(ifgroups, function(group) {
              var wanConnections = getWanParams(group, wanBridges),
                vlanOptions = createOptionsByParams(group, wanConnections),
                vlanGroup = createVlanGroup(vlanOptions);
              _.isNull(vlanGroup) || vlans.push(vlanGroup);
            }),
            vlans
          );
        });
      var createWanTree = function(wan) {
          return _.chain(wan)
            .map(function(wanObject) {
              return formObjects(wanObject, !1);
            })
            .flatten()
            .value();
        },
        getWanParams = function(group, bridges) {
          var result = [],
            data = group.create,
            wans = data.wans;
          return (
            _.each(wans, function(name) {
              var level = findLevelbyName(bridges, name);
              result.push(getBridgeParams(level));
            }),
            result
          );
        },
        formObjects = function(config, is_wan) {
          function getObjectForLevel(lConfig, level) {
            var buflConfig = funcs.deepClone(lConfig);
            return 'l2' == level
              ? (_.isUndefined(buflConfig.services) ||
                  delete buflConfig.services,
                buflConfig)
              : 'l3' == level
                ? (_.isUndefined(buflConfig.tunnels) ||
                    delete buflConfig.tunnels,
                  buflConfig)
                : buflConfig;
          }
          var result = [],
            pushLevel = function() {
              var args = Array.prototype.slice.call(arguments, 0),
                l2 = args[0] ? args[0] : {},
                l3 = args[1] ? args[1] : {},
                l4 = args[2] ? args[2] : {};
              return this.push({ l2: l2, l3: l3, l4: l4 }), this;
            };
          for (var l2Key in config) {
            var l2 = config[l2Key],
              l2Result = {};
            if (
              ((l2Result.data = getObjectForLevel(l2, 'l2')),
              !is_wan || l2Result.data.is_wan)
            ) {
              l2Result.key = l2Key;
              var services = l2.services;
              if (services && !_.isEmpty(services))
                for (var l3Key in services) {
                  var l3 = services[l3Key],
                    l3Result = {};
                  (l3Result.data = getObjectForLevel(l3, 'l3')),
                    (l3Result.key = l3Key);
                  var tunnels = l3.tunnels;
                  if (tunnels && !_.isEmpty(tunnels))
                    for (var l4Key in tunnels) {
                      var l4Result = {};
                      (l4Result.data = tunnels[l4Key]),
                        (l4Result.key = l4Key),
                        pushLevel.call(result, l2Result, l3Result, l4Result);
                    }
                  else pushLevel.call(result, l2Result, l3Result);
                }
              else pushLevel.call(result, l2Result);
            }
          }
          return result;
        },
        findLevelbyName = function(levels, name) {
          return _.find(levels, function(__level) {
            var l3 = __level.l3.data;
            return !_.isEmpty(l3) && l3.name == name;
          });
        },
        findBridgeLevels = function(levels) {
          return _.filter(levels, function(__level) {
            var l3 = __level.l3.data;
            return 'bridge' == l3.type;
          });
        },
        getBridgeParams = function(level) {
          var atm = level.l2.data,
            bridge = level.l3.data,
            vlan = bridge.vlan,
            name = bridge.name,
            vid = vlan && vlan.vlanid ? vlan.vlanid : null,
            qos = vlan && vlan.vlanpr ? vlan.vlanpr : 0,
            vpi =
              atm.pvc_settings && atm.pvc_settings.vpi
                ? atm.pvc_settings.vpi
                : 0,
            vci =
              atm.pvc_settings && atm.pvc_settings.vci
                ? atm.pvc_settings.vci
                : 0;
          return { name: name, vid: vid, qos: qos, vpi: vpi, vci: vci };
        },
        createVlanGroup = function(options) {
          var type = options.type;
          switch (type) {
            case 'wanu':
              return vlan.template.createWanUGroup(options);
            case 'want':
              return vlan.template.createWanTGroup(options);
            case 'bridge':
              return vlan.template.createBridgeGroup(options);
          }
          return null;
        },
        createOptionsByParams = function(group, connections) {
          var groupData = group.create,
            name = groupData.name,
            qos = connections[0].qos,
            vid = connections[0].vid,
            connections = _.map(connections, function(conn) {
              return _.omit(conn, 'vid', 'qos');
            }),
            type = getVlanType(group, vid),
            ports = createPorts(groupData, type, qos);
          return {
            name: name,
            type: type,
            vid: vid,
            ports: ports,
            connections: connections,
          };
        },
        getVlanType = function(group, vid) {
          return group ? (vid ? 'bridge' : 'wanu') : 'want';
        },
        createPorts = function(group, type, qos) {
          function getWanPortsParams(type, qos) {
            return {
              ports: ['internet'],
              tag: 'wanu' == type ? !1 : !0,
              qos: qos,
            };
          }
          function getLanPortsParams(ports, qos) {
            return { ports: ports, qos: qos };
          }
          var ports = [],
            wanPortsParams = getWanPortsParams(type, qos),
            wanPorts = createWanPorts(wanPortsParams);
          if (((ports = _.union(ports, wanPorts)), 'want' != type)) {
            var lans = group.lans,
              lanPortsParams = getLanPortsParams(lans, qos),
              lanPorts = createLanPorts(lanPortsParams);
            ports = _.union(ports, lanPorts);
          }
          return ports;
        },
        createLanPorts = function(options) {
          var ports = options.ports;
          return _.map(ports, function(port) {
            return { name: port, tag: !1, qos: options.qos ? options.qos : 0 };
          });
        },
        createWanPorts = function(options) {
          var ports = options.ports;
          return _.map(ports, function(port) {
            return {
              name: port,
              tag: options.tag ? options.tag : !1,
              qos: options.qos ? options.qos : 0,
            };
          });
        };
      converter.splitVlans = function(wan, vlans) {
        var workCopyWan = funcs.deepClone(wan),
          services = vlans.services,
          ifgroups = (vlans.groups, []);
        return (
          _.each(services, function(service, name) {
            var type = service.type;
            switch (type) {
              case 'bridge':
                updateWanAtmParams(workCopyWan, service),
                  updateWanVlanParams(workCopyWan, service),
                  addGroup(ifgroups, vlans, name);
                break;
              case 'wanu':
                updateWanAtmParams(workCopyWan, service),
                  addGroup(ifgroups, vlans, name);
                break;
              case 'want':
                updateWanAtmParams(workCopyWan, service),
                  updateWanVlanParams(workCopyWan, service);
            }
          }),
          { WAN: workCopyWan, GroupingInterfaces: ifgroups }
        );
      };
      var findBridgeByName = function(wan, name) {
          var connection = wan.Bridge.Connection;
          for (var key in connection) {
            var conn = connection[key];
            if (conn.Name == name) return conn;
          }
        },
        updateWanAtmParams = function(wan, service) {
          _.each(service.connections, function(conn) {
            var name = conn.name,
              wanBridge = findBridgeByName(wan, name),
              vpi = conn.vpi,
              vci = conn.vci;
            _.isUndefined(vpi) ||
              _.isUndefined(vci) ||
              funcs.setValue(
                'Media.DSL.ATM.DestinationAddress',
                vpi + '/' + vci,
                wanBridge
              );
          });
        },
        updateWanVlanParams = function(wan, service) {
          _.each(service.connections, function(conn) {
            var name = conn.name,
              wanBridge = findBridgeByName(wan, name),
              vid = service.vid,
              qos = service.qos;
            funcs.setValue('VLAN.ID', vid, wanBridge),
              funcs.setValue('VLAN.Priority', qos, wanBridge);
          });
        },
        addGroup = function(ifgroups, vlans, name) {
          ifgroups.push({ create: createGroup(vlans, name) });
        },
        createGroup = function(vlans, name) {
          var groups = vlans.groups,
            services = vlans.services;
          return {
            lans: getLanPortsByServiceName(groups, name),
            wans: getWANPorts(services, name),
            name: name,
          };
        },
        getLanPortsByServiceName = function(groups, name) {
          return _.chain(groups)
            .values()
            .flatten()
            .map(function(obj) {
              var port = obj.name,
                serviceName = obj.service;
              return serviceName == name ? port : null;
            })
            .compact()
            .value();
        },
        getWANPorts = function(services, name) {
          var service = services[name],
            connections = service.connections;
          return _.map(connections, function(conn) {
            return conn.name;
          });
        };
      converter.updateSomovdView = function(profile) {
        var config = profile.Config,
          view = profile.View;
        _.each(view, function(value, path) {
          isWanSection(path) && updateSomovdWanView(config, view, path),
            isIfgroupsSection(path) &&
              updateSomovdIfgroupsView(config, view, path);
        });
      };
      var updateSomovdWanView = function(config, view, path) {
          var wanIndex = getWanSomovdIndex(path),
            param = getParamName(path),
            connection = config.WAN[wanIndex];
          if (isBridgeConnection(connection)) {
            var name = funcs.fetchBranch(
                connection,
                'create.services.create.name'
              ),
              vlanIndex = getVlanIndex(config.VLAN.vlans, name),
              newPath = 'Config.VLAN.vlans[' + vlanIndex + '].';
            switch (param) {
              case 'vpi':
              case 'vci':
                newPath += param;
                break;
              case 'vlanid':
                newPath += 'vid';
            }
            updateViewParam(view, path, newPath);
          }
        },
        updateSomovdIfgroupsView = function(config, view, path) {
          var param = getParamName(path),
            ifgroupsIndex = getIfgroupsIndex(path);
          if ('lans' == param) {
            var newPath = 'Config.VLAN.vlans[' + ifgroupsIndex + '].ports';
            updateViewParam(view, path, newPath);
          }
        };
      converter.updateNativeView = function(profile) {
        var config = profile.Config,
          view = profile.View;
        _.each(view, function(value, path) {
          isVlanServiceSection(path) && updateNativeWanView(config, view, path),
            isVlanGroupsSection(path) &&
              updateNativeIfgroupsView(config, view, path);
        });
      };
      var updateNativeWanView = function(config, view, path) {
          var name = getVlanServiceName(path),
            param = getParamName(path),
            index = getWanNativeIndex(config.WAN, name),
            newPath = 'Config.WAN.Bridge.Connection.' + index + '.';
          switch (param) {
            case 'vid':
              newPath += 'VLAN.ID';
              break;
            case 'vpi':
            case 'vci':
              newPath += 'DSL.ATM.DestinationAddress';
          }
          updateViewParam(view, path, newPath);
        },
        updateNativeIfgroupsView = function(config, view, path) {
          var vlan = config.VLAN,
            param = getParamName(path);
          if ('groups' == param) {
            var value = funcs.deepClone(view[path]),
              index = 0;
            _.each(vlan.services, function(obj, key) {
              var newPath =
                'Config.GroupingInterfaces[' + index + '].create.lans';
              (view[newPath] = value), index++;
            }),
              delete view[path];
          }
        },
        updateViewParam = function(view, oldPath, newPath) {
          var value = view[oldPath];
          (view[newPath] = value), delete view[oldPath];
        },
        getWanNativeIndex = function(wan, name) {
          var connection = wan.Bridge.Connection;
          for (var key in connection) {
            var conn = connection[key];
            if (conn.Name == name) return key;
          }
        },
        getWanSomovdIndex = function(path) {
          var index = null,
            re = new RegExp('^Config.WAN\\[(.*)\\]');
          return re.test(path) && (index = path.match(re)[1]), index;
        },
        getIfgroupsIndex = function(path) {
          var index = null,
            re = new RegExp('^Config.GroupingInterfaces\\[(.*)\\]');
          return re.test(path) && (index = path.match(re)[1]), index;
        },
        getVlanIndex = function(vlans, name) {
          for (var i = 0; i < vlans.length; i++) {
            var vlan = vlans[i];
            if (vlan.name == name) return i;
          }
        },
        getVlanServiceName = function(path) {
          var name = '',
            re = new RegExp('^Config.VLAN.services\\.(.*)\\.');
          return re.test(path) && (name = path.match(re)[1]), name;
        },
        getParamName = function(path) {
          return _.last(path.split('.'));
        },
        isWanSection = function(path) {
          var re = new RegExp('^Config.WAN');
          return re.test(path);
        },
        isIfgroupsSection = function(path) {
          var re = new RegExp('^Config.GroupingInterfaces');
          return re.test(path);
        },
        isVlanServiceSection = function(path) {
          var re = new RegExp('^Config.VLAN.services');
          return re.test(path);
        },
        isVlanGroupsSection = function(path) {
          var re = new RegExp('^Config.VLAN.groups');
          return re.test(path);
        },
        isBridgeConnection = function(connection) {
          var type = funcs.fetchBranch(
            connection,
            'create.services.create.type'
          );
          return type && 'bridge' == type;
        };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function somovdToNative(data) {
        var result = {};
        return (
          copyParam(data, 'Enable', result, 'Enable'),
          copyParam(
            data,
            'InformEnable',
            result,
            'Settings.Information.Enable'
          ),
          copyParam(
            data,
            'InformInterval',
            result,
            'Settings.Information.Interval'
          ),
          copyParam(data, 'AcsURL', result, 'Settings.Acs.URL'),
          copyParam(data, 'AcsUser', result, 'Settings.Acs.User'),
          copyParam(data, 'AcsPwd', result, 'Settings.Acs.Password'),
          copyParam(
            data,
            'ConnReqUser',
            result,
            'Settings.ConnectionRequest.User'
          ),
          copyParam(
            data,
            'ConnReqPwd',
            result,
            'Settings.ConnectionRequest.Password'
          ),
          copyParam(
            data,
            'ConnReqPort',
            result,
            'Settings.ConnectionRequest.Port'
          ),
          copyParam(
            data,
            'ConnReqPath',
            result,
            'Settings.ConnectionRequest.Path'
          ),
          copyParam(data, 'iface', result, 'InterfaceName'),
          copyParam(data, 'l2_key', result, 'MediaKey'),
          copyParam(data, 'l3_key', result, 'ConnectionKey'),
          copyParam(data, '__ConnectionName', result, '__ConnectionName'),
          result
        );
      }
      function nativeToSomovd(data) {
        var result = {};
        return (
          copyParam(data, 'Enable', result, 'Enable'),
          copyParam(
            data,
            'Settings.Information.Enable',
            result,
            'InformEnable'
          ),
          copyParam(
            data,
            'Settings.Information.Interval',
            result,
            'InformInterval'
          ),
          copyParam(data, 'Settings.Acs.URL', result, 'AcsURL'),
          copyParam(data, 'Settings.Acs.User', result, 'AcsUser'),
          copyParam(data, 'Settings.Acs.Password', result, 'AcsPwd'),
          copyParam(
            data,
            'Settings.ConnectionRequest.User',
            result,
            'ConnReqUser'
          ),
          copyParam(
            data,
            'Settings.ConnectionRequest.Password',
            result,
            'ConnReqPwd'
          ),
          copyParam(
            data,
            'Settings.ConnectionRequest.Port',
            result,
            'ConnReqPort'
          ),
          copyParam(
            data,
            'Settings.ConnectionRequest.Path',
            result,
            'ConnReqPath'
          ),
          copyParam(data, 'InterfaceName', result, 'iface'),
          copyParam(data, 'MediaKey', result, 'l2_key'),
          copyParam(data, 'ConnectionKey', result, 'l3_key'),
          copyParam(data, '__ConnectionName', result, '__ConnectionName'),
          result
        );
      }
      function copyParam(from, fromPath, to, toPath) {
        var value = funcs.fetchBranch(from, fromPath);
        _.isNull(value) ||
          funcs.deepExtend(to, funcs.setValue(toPath, value, {}));
      }
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.TR69,
              convert = somovdToNative(profile),
              result = { Config: { TR69: convert } };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.TR69,
              convert = nativeToSomovd(profile),
              result = { Config: { TR69: convert } };
            return result;
          },
        };
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.RemoteUpdate,
              convert = {};
            _.isUndefined(profile.enable) || (convert.Enable = profile.enable),
              _.isUndefined(profile.server) ||
                (convert.ServerName = profile.server);
            var result = { Config: { RemoteUpdate: convert } };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.RemoteUpdate,
              convert = {};
            _.isUndefined(profile.Enable) || (convert.enable = profile.Enable),
              _.isUndefined(profile.ServerName) ||
                (convert.server = profile.ServerName);
            var result = { Config: { RemoteUpdate: convert } };
            return result;
          },
        };
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function getNativeView(view) {
        var result = {};
        return (
          _.each(view, function(value, name) {
            if (isSystemPasswordSection(name)) {
              var nativeName = getViewNativeParamName(name);
              result[nativeName] = value;
            }
          }),
          result
        );
      }
      function getViewNativeParamName(name) {
        var re = /^(Config.SystemPassword.)(.*)/,
          schema = { login: 'Login', pass: 'Password' };
        return name.replace(re, function(match, p1, p2) {
          var newP2 = schema[p2];
          return p1 + newP2;
        });
      }
      function isSystemPasswordSection(name) {
        var re = new RegExp('^Config.SystemPassword.');
        return re.test(name);
      }
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemPassword,
              result = {
                Config: {
                  SystemPassword: {
                    Login: profile.login ? profile.login : '',
                    Password: profile.pass ? profile.pass : '',
                  },
                },
              };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemPassword,
              result = {
                Config: {
                  SystemPassword: {
                    login: profile.Login ? profile.Login : '',
                    pass: profile.Password ? profile.Password : '',
                  },
                },
              };
            return result;
          },
          convertViewSomovdToNative: function(profile) {
            var view = profile.View,
              result = { View: getNativeView(view) };
            return result;
          },
        };
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function somovdToNative(data) {
        var result = {},
          ntp = data.ntpclient;
        return (
          (result.Mode =
            _.isUndefined(ntp.enable) || ntp.enable ? 'NTP' : 'Manual'),
          copyParam(ntp, 'hour', result, 'TimeZone'),
          !_.isUndefined(ntp.servers) &&
            _.isArray(ntp.servers) &&
            (result.Servers = ntp.servers.join(',')),
          copyParam(ntp, 'time.tm_min', result, 'Time.Minute'),
          copyParam(ntp, 'time.tm_hour', result, 'Time.Hour'),
          copyParam(ntp, 'time.tm_mday', result, 'Time.Day'),
          copyParam(ntp, 'time.tm_mon', result, 'Time.Month'),
          copyParam(ntp, 'time.tm_year', result, 'Time.Year'),
          copyParam(ntp, 'use_dhcp', result, 'UseDHCP'),
          result
        );
      }
      function nativeToSomovd(data) {
        var ntp = {};
        return (
          (ntp.enable = 'NTP' == data.Mode ? !0 : !1),
          copyParam(data, 'TimeZone', ntp, 'hour'),
          !_.isUndefined(data.Servers) &&
            _.isArray(data.Servers) &&
            (ntp.servers = data.Servers.split(',')),
          copyParam(data, 'Time.Minute', ntp, 'time.tm_min'),
          copyParam(data, 'Time.Hour', ntp, 'time.tm_hour'),
          copyParam(data, 'Time.Day', ntp, 'time.tm_mday'),
          copyParam(data, 'Time.Month', ntp, 'time.tm_mon'),
          copyParam(data, 'Time.Year', ntp, 'time.tm_year'),
          copyParam(data, 'UseDHCP', ntp, 'use_dhcp'),
          ntp
        );
      }
      function copyParam(from, fromPath, to, toPath) {
        var value = funcs.fetchBranch(from, fromPath);
        _.isNull(value) ||
          funcs.deepExtend(to, funcs.setValue(toPath, value, {}));
      }
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemTime,
              convert = somovdToNative(profile),
              result = { Config: { SystemTime: convert } };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemTime,
              convert = nativeToSomovd(profile),
              result = { Config: { SystemTime: convert } };
            return result;
          },
        };
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        dms = (__webpack_require__(3),
        {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemLanguage,
              result = {
                Config: { SystemLanguage: { Language: profile.lang } },
              };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.SystemLanguage,
              result = {
                Config: { SystemLanguage: { lang: profile.Language } },
              };
            return result;
          },
        });
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        convertSomovdToNative: __webpack_require__(114),
        convertNativeToSomovd: __webpack_require__(116),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function voip(data) {
          return native.build({ $voip: data });
        }
        function view(views) {
          function isVoIP(key) {
            return !/^Config.VoIP./.test(key);
          }
          var newView = {};
          return (
            _.each(views, function(value, key) {
              if (!isVoIP(key)) {
                var newKey = key.replace(
                  /VoiceService\.1\.VoiceProfile\.1\./,
                  ''
                );
                newView[newKey] = value;
              }
            }),
            newView
          );
        }
        return { voip: voip, view: view };
      }
      var _ = __webpack_require__(3),
        native = __webpack_require__(115);
      module.exports = function(profile) {
        if (profile.Config.VoIP.AutoProvision)
          var voip = profile.Config.VoIP,
            view = profile.View;
        else
          var build = new Build(),
            voip = build.voip(profile.Config.VoIP),
            view = build.view(profile.View);
        return { Config: { VoIP: voip }, View: view };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function getNumberOfEntries(obj) {
        return _.size(_.omit(obj, 'max_instance'));
      }
      function withoutMaxInstance(obj, key) {
        return 'max_instance' != key;
      }
      var _ = __webpack_require__(3),
        T = __webpack_require__(84).T;
      module.exports = T({
        '->': ['$voipRoot', '$extend', '$line', 'Line', 'LineNumberOfEntries'],
        $voip: ':external',
        $voipRoot: [
          '$voip',
          function(v) {
            return v.VoiceService[1].VoiceProfile[1];
          },
        ],
        $extend: function() {
          _.extend(this, _.omit(this.$voipRoot, 'Line', 'LineNumberOfEntries'));
        },
        $line: [
          '$voipRoot',
          function(p) {
            return p.Line;
          },
        ],
        LineNumberOfEntries: [
          '$line*',
          function(l) {
            return getNumberOfEntries(l);
          },
        ],
        Line: {
          '->': ['?', '$line', '$index', ':', '$extend'],
          '?': [
            '$parent',
            function(p) {
              return !!p.$line;
            },
          ],
          '{$line, $index}': [
            '$parent',
            function(p) {
              return _.filter(p.$line, withoutMaxInstance);
            },
          ],
          ':': [
            '$index*',
            function(i) {
              return i + 1;
            },
          ],
          $extend: function() {
            _.extend(this, this.$line);
          },
        },
      });
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function voip(data) {
          return somovd.build({ $voip: data });
        }
        return { voip: voip };
      }
      var somovd = (__webpack_require__(3), __webpack_require__(117));
      module.exports = function(profile) {
        if (profile.Config.VoIP.AutoProvision) var voip = profile.Config.VoIP;
        else
          var build = new Build(),
            voip = build.voip(profile.Config.VoIP);
        return { Config: { VoIP: voip } };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        T = __webpack_require__(84).T;
      module.exports = T({
        '->': ['$voip', 'VoiceService'],
        $voip: ':external',
        VoiceService: {
          1: {
            VoiceProfile: {
              1: {
                '->': ['$voip', '$extend', '$line', 'Line'],
                $voip: [
                  '$root',
                  function(r) {
                    return r.$voip;
                  },
                ],
                $extend: function() {
                  _.extend(
                    this,
                    _.omit(this.$voip, 'Line', 'LineNumberOfEntries')
                  );
                },
                $line: [
                  '$voip',
                  function(v) {
                    return v.Line;
                  },
                ],
                Line: {
                  '->': ['?', '$line', '$index', ':', '$extend'],
                  '?': [
                    '$parent',
                    function(p) {
                      return !!p.$line;
                    },
                  ],
                  '{$line, $index}': [
                    '$parent',
                    function(p) {
                      return p.$line;
                    },
                  ],
                  ':': [
                    '$index*',
                    function(i) {
                      return i;
                    },
                  ],
                  $extend: function() {
                    _.extend(this, this.$line);
                  },
                },
              },
            },
          },
        },
      });
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        dms = (__webpack_require__(3),
        {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.EtherWAN,
              result = { Config: { EtherWAN: { Port: profile.port } } };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.EtherWAN,
              result = { Config: { EtherWAN: { port: profile.Port } } };
            return result;
          },
        });
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        convertSomovdToNative: __webpack_require__(120),
        convertNativeToSomovd: __webpack_require__(122),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function lan(data) {
          var result = {},
            inst = 0;
          return (
            _.each(data, function(elem) {
              var obj = converter.somovdToNative(elem);
              if (obj && obj.LAN) {
                var key = (++inst).toString(),
                  value = obj.LAN[1];
                result[key] = value;
              }
            }),
            result
          );
        }
        function view(views) {
          function isLAN(key) {
            return !/^Config.LAN./.test(key);
          }
          function getSomovdParams(path) {
            var regexp = /^Config\.LAN\[(.+)\]\.([^.]+)\.services\.([^.]+)\.(.+)/g,
              params = regexp.exec(path),
              len = params.length;
            return { index: params[1], param: params[len - 1] };
          }
          function namingSchema(param) {
            var schema = {
              ip: 'IPv4.StaticIP.1.Address',
              mask: 'IPv4.StaticIP.1.SubnetMask',
              'dhcpd.start_ip': 'IPv4.DHCP.Server.MinAddress',
              'dhcpd.end_ip': 'IPv4.DHCP.Server.MaxAddress',
            };
            return schema[param];
          }
          var newView = {};
          return (
            _.each(views, function(value, key) {
              if (!isLAN(key)) {
                var somovdParams = getSomovdParams(key),
                  inst = (parseInt(somovdParams.index) + 1).toString(),
                  param = namingSchema(somovdParams.param),
                  newPath = 'Config.LAN.' + inst + '.' + param;
                newView[newPath] = value;
              }
            }),
            newView
          );
        }
        return { lan: lan, view: view };
      }
      var _ = __webpack_require__(3),
        converter = __webpack_require__(121);
      module.exports = function(profile) {
        var build = new Build(),
          lan = build.lan(profile.Config.LAN),
          view = build.view(profile.View);
        return { Config: { LAN: lan }, View: view };
      };
    },
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      function Build() {
        function lan(data) {
          var result = [];
          return (
            _.each(data, function(elem) {
              var obj = converter.nativeToSomovd({ LAN: { 1: elem } });
              result.push(obj);
            }),
            result
          );
        }
        return { lan: lan };
      }
      var _ = __webpack_require__(3),
        converter = __webpack_require__(121);
      module.exports = function(profile) {
        var build = new Build(),
          lan = build.lan(profile.Config.LAN);
        return { Config: { LAN: lan } };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        dms = (__webpack_require__(3),
        {
          convertSomovdToNative: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.DeviceMode,
              result = {
                Config: { DeviceMode: { Mode: profile.device_mode } },
              };
            return result;
          },
          convertNativeToSomovd: function(profile) {
            var workCopy = funcs.deepClone(profile),
              profile = workCopy.Config.DeviceMode,
              result = {
                Config: { DeviceMode: { device_mode: profile.Mode } },
              };
            return result;
          },
        });
      module.exports = dms;
    },
  ]
);
