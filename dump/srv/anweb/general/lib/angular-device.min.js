webpackJsonp(
  [2],
  [
    function(module, exports, __webpack_require__) {
      module.exports = __webpack_require__(128);
    },
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      __webpack_require__(129);
      var device = angular.module('device', ['angular-es6-promise']);
      __webpack_require__(2)('device'),
        __webpack_require__(130)('device'),
        device.factory('device', [
          'somovd',
          '$q',
          function(somovd, Q) {
            __webpack_require__(139).set(Q),
              __webpack_require__(140).set(somovd),
              __webpack_require__(141).set(__webpack_require__(142));
            var portSegmentation = __webpack_require__(166),
              dosSettings = __webpack_require__(169),
              openVPN = __webpack_require__(172);
            return {
              funcs: __webpack_require__(5),
              info: __webpack_require__(174),
              wan: __webpack_require__(175),
              wifi: __webpack_require__(189),
              wifiMacFilter: __webpack_require__(197),
              wifiShaping: __webpack_require__(198),
              lan: __webpack_require__(199),
              vlan: __webpack_require__(209),
              portAllocation: __webpack_require__(210)(),
              portSegmentation: _.size(portSegmentation.oldConfig)
                ? portSegmentation.oldConfig
                : portSegmentation.newConfig,
              dosSettings: _.size(dosSettings.oldConfig)
                ? dosSettings.oldConfig
                : dosSettings.newConfig,
              openVPN: _.size(openVPN.oldConfig)
                ? openVPN.oldConfig
                : openVPN.newConfig,
              dns: __webpack_require__(213),
              vservers: __webpack_require__(214),
              macfilter: __webpack_require__(217),
              ipfilter: __webpack_require__(220),
              urlfilter: __webpack_require__(223),
              yandexDns: __webpack_require__(225),
              ipsec: __webpack_require__(228),
              statsRouting: __webpack_require__(229),
              system: __webpack_require__(231),
              voip: __webpack_require__(232),
              etherwan: __webpack_require__(233),
              ifgroups: __webpack_require__(234),
              snmp: __webpack_require__(235),
              qosSw: __webpack_require__(236),
              qosHw: __webpack_require__(237),
              hotWifi: __webpack_require__(238),
              safeDns: __webpack_require__(239),
              nsg: __webpack_require__(240),
              systemTime: __webpack_require__(241),
              systemLog: __webpack_require__(245),
              firmware: __webpack_require__(248),
              statsDHCP: __webpack_require__(251),
              portSettings: __webpack_require__(255),
              wanReservation: __webpack_require__(259),
              udpxy: __webpack_require__(262),
              usbInfo: __webpack_require__(266),
              ddns: __webpack_require__(267),
              filebrowser: __webpack_require__(270),
              dlna: __webpack_require__(272),
            };
          },
        ]);
    },
    ,
    function(module, exports, __webpack_require__) {
      'use strict';
      var cpe = __webpack_require__(131),
        transportCpe = __webpack_require__(132).cpe,
        cpex = __webpack_require__(135),
        transportCpex = __webpack_require__(136);
      module.exports = function(moduleName) {
        angular.module(moduleName).service('cpe', [
          '$http',
          function($http) {
            return transportCpe.__setHttp && transportCpe.__setHttp($http), cpe;
          },
        ]),
          angular.module(moduleName).service('cpex', [
            '$http',
            function($http) {
              return (
                transportCpex.__setHttp && transportCpex.__setHttp($http), cpex
              );
            },
          ]);
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var somovd = __webpack_require__(133),
        cpe = __webpack_require__(134);
      module.exports = {
        somovd: somovd,
        cpe: cpe,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }
      var _promise = __webpack_require__(7),
        _promise2 = _interopRequireDefault(_promise),
        _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        cpe = __webpack_require__(131),
        transport = __webpack_require__(136),
        jsonrpc = __webpack_require__(138);
      module.exports = (function() {
        function applyChanges(changes) {
          var params = {
              Changes: changes,
            },
            data = jsonrpc('ApplyChanges', params);
          return transport.request({
            data: data,
          });
        }

        function parallel(requests) {
          var input = __prepareRequests(requests);
          return _promise2['default'].all(input);
        }

        function add(path, order) {
          function getIndex(res) {
            return _promise2['default'].resolve(res.result.InstanceNumber);
          }
          return _.isUndefined(order)
            ? cpe.AddObject(path).then(getIndex)
            : cpe.AddObject(path, order).then(getIndex);
        }

        function set(path, index, obj) {
          var config = funcs.setValue(path + index, obj, {}),
            parameterList = funcs.splitTree(config);
          return parameterList.length
            ? cpe.SetParameterValues(parameterList)
            : _promise2['default'].resolve();
        }

        function remove(indexes, root) {
          var promise = funcs.sequencePromises(indexes, function(index) {
            return cpe.DeleteObject(root + index + '.');
          });
          return promise;
        }

        function createAndSet(input) {
          function prepareOrders(orders, oldInst, newInst) {
            return _.map(orders, function(value) {
              return value == oldInst ? newInst : value;
            });
          }
          var output = {},
            inst = input.id ? input.id : '+100500';
          return (
            funcs.setValue(input.path + inst, input.data, output),
            input.order &&
              (inst != input.id &&
                (input.order = prepareOrders(input.order, input.id, inst)),
              funcs.setValue(input.path + 'order', input.order, output)),
            cpe.ApplyDifference(output)
          );
        }

        function __prepareRequests(requests) {
          return _.map(requests, function(request) {
            var method = request.method;
            return cpe[method].apply(cpe, request.args);
          });
        }
        return {
          applyChanges: applyChanges,
          parallel: parallel,
          add: add,
          set: set,
          remove: remove,
          createAndSet: createAndSet,
          subscribe: transport.subscribe,
          unsubscribe: transport.unsubscribe,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var Transport = __webpack_require__(137).Transport;
      module.exports = new Transport({
        endPoint: '/cpex',
      });
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }

      function Transport(options) {
        function request(options) {
          return (
            (options.config = options.config || {}),
            new _promise2['default'](function(resolve, reject) {
              (options.resolve = resolve),
                (options.reject = reject),
                taskLimit > taskCount
                  ? __post(options)
                  : taskQueue.push(options);
            })
          );
        }

        function preSubscribe(opt) {
          return __subscribe(opt, 'pre');
        }

        function postSubscribe(opt) {
          return __subscribe(opt, 'post');
        }

        function __subscribe(opt, publishTime) {
          return (
            subscribesId[publishTime]++,
            (opt.id = subscribesId[publishTime]),
            (opt.context = opt.context || null),
            subscribes[publishTime].push(opt),
            opt.id
          );
        }

        function preUnsubscribe(id) {
          return __unsubscribe(id, 'pre');
        }

        function postUnsubscribe(id) {
          return __unsubscribe(id, 'post');
        }

        function __unsubscribe(id, publishTime) {
          _.each(subscribes[publishTime], function(elem, index) {
            elem.id == id && subscribes[publishTime].splice(index, 1);
          });
        }

        function prePublish() {
          __publish(arguments, 'pre');
        }

        function postPublish() {
          __publish(arguments, 'post');
        }

        function __publish(args, publishTime) {
          var request = args[0];
          _.each(subscribes[publishTime], function(elem) {
            checkSubscribe(request, elem) &&
              _.has(elem, 'handler') &&
              elem.handler.apply(elem.context, args);
          });
        }

        function checkSubscribe(request, subscribe) {
          return request && request.method == subscribe.method;
        }

        function __setHttp(http) {
          $http = http;
        }

        function __post(options) {
          function success(response) {
            var data = response.data,
              resolve = !1,
              reject = !1;
            data && (data.result || data.error)
              ? (data.result && (resolve = !0), data.error && (reject = !0))
              : (reject = !0),
              resolve &&
                (postPublish(options.data, response.data, !1),
                options.resolve(data)),
              reject &&
                (postPublish(options.data, response.data, !0),
                options.reject(data)),
              applyQueueNext();
          }

          function error(err) {
            postPublish(options.data, err, !0),
              options.reject(err),
              applyQueueNext();
          }

          function applyQueueNext() {
            taskCount--, taskQueue.length && __post(taskQueue.shift());
          }
          return (
            taskCount++,
            prePublish(options.data),
            $http
              .post(endPointPath, options.data, options.config)
              .then(success, error)
          );
        }
        var $http,
          endPointPath = options.endPoint,
          taskQueue = [],
          taskLimit = 1,
          taskCount = 0,
          subscribes = {
            pre: [],
            post: [],
          },
          subscribesId = {
            pre: 0,
            post: 0,
          };
        return {
          request: request,
          subscribe: {
            pre: preSubscribe,
            post: postSubscribe,
          },
          unsubscribe: {
            pre: preUnsubscribe,
            post: postUnsubscribe,
          },
          __setHttp: __setHttp,
        };
      }
      var _promise = __webpack_require__(7),
        _promise2 = _interopRequireDefault(_promise),
        _ = __webpack_require__(3);
      module.exports = {
        Transport: Transport,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3);
      module.exports = function(method, params, id) {
        var obj = {
          jsonrpc: '2.0',
          method: method,
        };
        return (
          params && (obj.params = params),
          (obj.id = id || _.random(1, 1e3)),
          obj
        );
      };
    },
    function(module, exports) {
      'use strict';
      var Q = null;
      module.exports = {
        set: function(actualModule) {
          return (Q = actualModule);
        },
        get: function() {
          return Q;
        },
      };
    },
    function(module, exports) {
      'use strict';
      var somovd = null;
      module.exports = {
        set: function(actualModule) {
          return (somovd = actualModule);
        },
        get: function() {
          return somovd;
        },
      };
    },
    function(module, exports) {
      'use strict';
      var dms = null;
      module.exports = {
        set: function(actualModule) {
          return (dms = actualModule);
        },
        get: function() {
          return dms;
        },
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        wan: __webpack_require__(143),
        wifi: __webpack_require__(147),
        wifiMacFilter: __webpack_require__(149),
        wifiShaping: __webpack_require__(155),
        dns: __webpack_require__(156),
        lan: __webpack_require__(158),
        vlan: __webpack_require__(159),
        portAllocation: __webpack_require__(163),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        somovd = __webpack_require__(140),
        funcs = __webpack_require__(5),
        converter = __webpack_require__(144),
        supported = __webpack_require__(145),
        template = __webpack_require__(146),
        constants = {
          CONFIG_ID_WAN_TEMP: 1,
          CONFIG_ID_WAN_DEFAULTGW: 62,
          CONFIG_ID_WAN_DEFAULTGW_IPV6: 131,
          CONFIG_ID_RESTART_WAN: 250,
          RPC_NEED_REBOOT: 12,
          RPC_NEED_SAVE: 13,
          RPC_OK: 20,
        };
      module.exports = (function() {
        function pull(cb) {
          function readCb(response) {
            if (!isRPCSuccess(response.status))
              return void (cb && cb(response.status));
            var wan = converter.somovdToNative(response.data);
            (dms.data = {
              Device: {
                WAN: wan,
              },
            }),
              (__initialData = funcs.deepClone(dms.data)),
              (__initialSomovdData = funcs.deepClone(response.data)),
              cb && cb();
          }
          var transport = somovd.get();
          transport.read(constants.CONFIG_ID_WAN_TEMP, readCb);
        }

        function status() {
          return funcs.getChanges(__initialData, dms.data);
        }

        function push(cb) {
          var changed = (somovd.get(), dms.data, dms.status());
          if (_.size(changed)) {
            var actions = getActions(),
              list = applyList(actions);
            somovd.get().multi(list, !1, function(response) {
              var error = getRQError(response.rq);
              cb && cb(error);
            });
          }
        }

        function getWanUpdateArea() {
          return constants.CONFIG_ID_WAN_TEMP.toString();
        }

        function setData(data) {
          if (data) {
            var wan = converter.somovdToNative(data);
            (dms.data = {
              Device: {
                WAN: wan,
              },
            }),
              (__initialData = funcs.deepClone(dms.data)),
              (__initialSomovdData = funcs.deepClone(data));
          }
        }

        function reconnect(paths, cb) {
          var keys = _.map(paths, function(path) {
            return funcs.fetchBranch(dms.data, path + '.__Key');
          });
          somovd
            .get()
            .write(constants.CONFIG_ID_RESTART_WAN, keys, -1, function(
              response
            ) {
              cb && cb();
            });
        }

        function isRPCSuccess(status) {
          return (
            status == constants.RPC_OK ||
            status == constants.RPC_NEED_SAVE ||
            status == constants.RPC_NEED_REBOOT
          );
        }

        function getRQError(rq) {
          for (var i = 0; i < rq.length; i++) {
            var status = rq[i].status;
            if (!isRPCSuccess(status)) return rq[i].status;
          }
          return null;
        }

        function getActions() {
          function getActionsWrite(data, paths) {
            var result = {
                write: [],
              },
              wPaths = onlyWritePaths(paths);
            if (!wPaths.length) return result;
            var config = normalize(pickConnections(data, wPaths)),
              connections = converter.nativeToSomovd(config.Device.WAN);
            return (
              (connections = mixture(connections)),
              (result.write = _.union(result.write, connections)),
              result
            );
          }

          function getActionsRemove(data, paths) {
            var result = {
                remove: [],
              },
              rPaths = onlyRemovePaths(paths);
            if (!rPaths.length) return result;
            var connKeys = getSomovdKeys(data, rPaths);
            return (result.remove = _.union(result.remove, connKeys)), result;
          }

          function getActionsGwif(data, changed) {
            var result = {
                gwifv4: [],
                gwifv6: [],
              },
              versions = ['v4', 'v6'];
            return (
              _.each(versions, function(version) {
                var key = 'Device.WAN.IP' + version + 'DefaultGateway';
                if (changed[key]) {
                  var path = changed[key].Value,
                    somovdKey = getSomovdKey(data, path);
                  result['gwif' + version].push(somovdKey);
                }
              }),
              result
            );
          }

          function getSomovdKey(data, path) {
            var obj = funcs.fetchBranch(data, path + '.');
            return obj.__Key;
          }

          function getSomovdKeys(data, paths) {
            return _.map(paths, function(path) {
              return getSomovdKey(data, path);
            });
          }

          function isRemovePath(path) {
            return /-$/.test(path);
          }

          function isWritePath(path) {
            return !/-$/.test(path);
          }

          function onlyWritePaths(paths) {
            return _.filter(paths, isWritePath);
          }

          function onlyRemovePaths(paths) {
            return _.filter(paths, isRemovePath);
          }

          function pickConnections(data, paths) {
            var result = {};
            return (
              _.each(paths, function(path) {
                var obj = funcs.fetchBranch(data, path + '.');
                funcs.setValue(path, obj, result);
              }),
              result
            );
          }

          function normalize(config) {
            var conns = config.Device.WAN;
            return (
              _.each(conns, function(obj, type) {
                var list = obj.Connection;
                _.each(list, function(elem) {
                  if (elem.Media) {
                    var media = funcs.fetchBranch(
                      elem.Media,
                      elem.MediaType + '.'
                    );
                    media.__Key || (media.__Key = 'create');
                  }
                  elem.__Key || (elem.__Key = 'create'),
                    elem.__Layer || (elem.__Layer = '3'),
                    elem.__LowerLayer ||
                      (elem.__LowerLayer = media ? media.__Key : 'create');
                });
              }),
              config
            );
          }

          function mixture(connections) {
            function merge(origin, admix, without) {
              if (origin && admix)
                for (var key in admix)
                  _.isUndefined(origin[key]) &&
                    ((without && _.contains(without, key)) ||
                      (origin[key] = admix[key]));
            }

            function levelKeys(conn) {
              var keys = {};
              keys.l2 = _.keys(conn)[0];
              var services = conn[keys.l2].services;
              if (!services || _.isEmpty(services)) return keys;
              keys.l3 = _.keys(services)[0];
              var tunnels = services[keys.l3].tunnels;
              return !tunnels || _.isEmpty(tunnels)
                ? keys
                : ((keys.l4 = _.keys(tunnels)[0]), keys);
            }
            var ifaceKey = _.keys(__initialSomovdData)[0],
              ifaces = __initialSomovdData[ifaceKey];
            return (
              _.each(connections, function(conn) {
                var keys = levelKeys(conn);
                _.keys(conn)[0],
                  keys.l2 &&
                    'create' != keys.l2 &&
                    (merge(conn[keys.l2], ifaces[keys.l2], ['services']),
                    keys.l3 &&
                      'create' != keys.l3 &&
                      (merge(
                        conn[keys.l2].services[keys.l3],
                        ifaces[keys.l2].services[keys.l3],
                        ['tunnels', 'kabinet']
                      ),
                      keys.l4 &&
                        'create' != keys.l4 &&
                        merge(
                          conn[keys.l2].services[keys.l3].tunnels[keys.l4],
                          ifaces[keys.l2].services[keys.l3].tunnels[keys.l4]
                        )));
              }),
              connections
            );
          }

          function getChangesConnsPaths(data, changed) {
            function getLowerLayer(data, path) {
              var conn = funcs.fetchBranch(data, path + '.');
              if (conn.__LowerConnection) return conn.__LowerConnection;
              var params = {
                __Layer: '3',
                __Key: conn.__LowerLayer,
              };
              return findConnectionPath(data.Device.WAN, params);
            }

            function getHigherLayer(data, path) {
              var conn = funcs.fetchBranch(data, path + '.'),
                params = {
                  __Layer: '4',
                  __LowerLayer: conn.__Key,
                };
              return findConnectionPath(data.Device.WAN, params);
            }
            var paths = [],
              keys = _.keys(changed);
            return (
              _.each(keys, function(key) {
                var re = /Device\.WAN\.\w+.Connection\.\d+(\+|\-)?/,
                  result = key.match(re);
                if (result && result.length) {
                  var path = result[0];
                  if (
                    !_.contains(paths, path) &&
                    (paths.push(path), isWritePath(path))
                  ) {
                    var lowerLayer = getLowerLayer(data, path),
                      higherLayer = getHigherLayer(data, path);
                    lowerLayer &&
                      !_.contains(paths, lowerLayer) &&
                      paths.push(lowerLayer),
                      higherLayer &&
                        !_.contains(paths, higherLayer) &&
                        paths.push(higherLayer);
                  }
                }
              }),
              paths
            );
          }

          function findConnectionPath(wan, params) {
            function checkParams(elem, params) {
              return _.every(params, function(value, name) {
                return elem[name] == value;
              });
            }
            var path;
            return (
              _.every(wan, function(obj, type) {
                return obj.Connection
                  ? (_.every(obj.Connection, function(elem, inst) {
                      return checkParams(elem, params)
                        ? ((path =
                            'Device.WAN.' + type + '.Connection.' + inst),
                          !1)
                        : !0;
                    }),
                    _.isUndefined(path) ? !0 : !1)
                  : !0;
              }),
              path ? path : null
            );
          }
          var actions = {},
            data = dms.data,
            changed = dms.status(),
            paths = getChangesConnsPaths(data, changed);
          return (
            _.extend(actions, getActionsWrite(data, paths)),
            _.extend(actions, getActionsRemove(data, paths)),
            _.extend(actions, getActionsGwif(data, changed)),
            actions
          );
        }

        function applyList(actions) {
          function getParams(id, data, pos) {
            return {
              id: id,
              data: data,
              pos: pos,
            };
          }
          var list = {};
          if (
            ((actions.write.length ||
              actions.gwifv4.length ||
              actions.gwifv6.length) &&
              (list.write = []),
            actions.remove.length && (list.remove = []),
            _.each(actions.write, function(elem) {
              var params = getParams(constants.CONFIG_ID_WAN_TEMP, elem, -1);
              list.write.push(params);
            }),
            actions.remove.length)
          ) {
            var params = getParams(
              constants.CONFIG_ID_WAN_TEMP,
              actions.remove,
              -1
            );
            list.remove.push(params);
          }
          if (actions.gwifv4.length) {
            var params = getParams(
              constants.CONFIG_ID_WAN_DEFAULTGW,
              actions.gwifv4,
              -1
            );
            list.write.push(params);
          }
          if (actions.gwifv6.length) {
            var params = getParams(
              constants.CONFIG_ID_WAN_DEFAULTGW_IPV6,
              actions.gwifv6,
              -1
            );
            list.write.push(params);
          }
          return list;
        }
        var __initialData = null,
          __initialSomovdData = null,
          dms = {
            pull: pull,
            push: push,
            status: status,
            getWanUpdateArea: getWanUpdateArea,
            setData: setData,
            reconnect: reconnect,
            supported: supported,
            template: template,
            data: null,
          };
        return dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        somovdToNative: __webpack_require__(83).build,
        nativeToSomovd: __webpack_require__(87),
      };
    },
    function(module, exports) {
      'use strict';

      function supported(opts) {
        function isDefined(param) {
          return constants[param];
        }

        function connections() {
          function addSupportedTypes() {
            var argsArray = Array.prototype.slice.call(arguments, 0);
            result = result.concat(argsArray);
          }
          var result = [];
          return (
            addSupportedTypes('dynip', 'statip'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_IPOA') &&
              addSupportedTypes('ipv4oa'),
            isDefined('BR2_PACKAGE_ANWEB_IPV6') &&
              addSupportedTypes('dynipv6', 'statipv6'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE') &&
              addSupportedTypes('pppoe'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE_IPV6') &&
              addSupportedTypes('pppoev6'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE_DUAL') &&
              addSupportedTypes('pppoeDual'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOA') &&
              addSupportedTypes('pppoa'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_PPTP') &&
              addSupportedTypes('pptp'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_L2TP') &&
              addSupportedTypes('l2tp'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_3G') && addSupportedTypes('3g'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_LTE') && addSupportedTypes('lte'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_BRIDGE') &&
              addSupportedTypes('bridge'),
            isDefined('BR2_PACKAGE_ANWEB_WAN_IPOEDUAL') &&
              addSupportedTypes('ipoeDual'),
            result
          );
        }

        function dynip() {
          return ipv4('dynip');
        }

        function statip() {
          return ipv4('statip');
        }

        function lte() {
          return ipv4('lte');
        }

        function ipv4oa() {
          return ipv4('ipv4oa');
        }

        function dynipv6() {
          return ipv6('dynipv6');
        }

        function statipv6() {
          return ipv6('statipv6');
        }

        function ipoeDual() {
          return ipv6('dynipv6');
        }

        function pppoe() {
          return ppp('pppoe');
        }

        function pppoa() {
          return ppp('pppoa');
        }

        function pptp() {
          return ppp('pptp');
        }

        function l2tp() {
          return ppp('l2tp');
        }

        function g3() {
          return ppp('3g');
        }

        function pppoev6() {
          return ppp('pppoev6');
        }

        function pppoeDual() {
          return ppp('pppoeDual');
        }

        function atm() {
          return isDefined('BR2_modems');
        }

        function flags(type) {
          function IGMP(type) {
            return _.contains(['ipv4oe'], type);
          }

          function RIP(type) {
            var unsupportedTypes = ['3g', 'lte'];
            return (
              isDefined('BR2_PACKAGE_ANWEB_SUPPORT_RIP') &&
              !_.contains(unsupportedTypes, type)
            );
          }

          function Firewall(type) {
            return !(isDefined('BRCM_CMS_BUILD') && 'pptp' == type);
          }

          function NAT(type) {
            var unsupportedTypes = ['ipv6oe', 'pppoev6'];
            return !_.contains(unsupportedTypes, type);
          }

          function Ping(type) {
            return !isDefined('BRCM_CMS_BUILD');
          }

          function RTSP(type) {
            return (
              isDefined('DVG_N5402SP1S') ||
              (isDefined('DVG_N5402SP2S1U') && 'ipv4oe' == type)
            );
          }

          function AltRoutingTable(type) {
            return !(isDefined('BRCM_CMS_BUILD') || isDefined('BR2_modems'));
          }

          function MLD(type) {
            return _.contains(['ipv6oe'], type);
          }
          return {
            IGMP: IGMP(type),
            RIP: RIP(type),
            Firewall: Firewall(type),
            NAT: NAT(type),
            Ping: Ping(type),
            RTSP: RTSP(type),
            AltRoutingTable: AltRoutingTable(type),
            MLD: MLD(type),
          };
        }

        function vlan(type) {
          var unsupportedTypes = ['ipoa', 'pppoa', '3g', 'lte'];
          return {
            all:
              isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
              !_.contains(unsupportedTypes, type),
            useMultiPVC: isDefined('BRCM_CMS_BUILD'),
          };
        }

        function ipv4(type) {
          function Address(type) {
            return 'statip' == type || 'ipv4oa' == type;
          }

          function SubnetMask(type) {
            return 'statip' == type || 'ipv4oa' == type;
          }

          function GatewayIPAddress(type) {
            return 'statip' == type || 'ipv4oa' == type;
          }

          function DNSAutomatical(type) {
            return 'dynip' == type || 'lte' == type;
          }

          function Hostname(type) {
            return (
              ('dynip' == type || 'lte' == type) && !isDefined('BRCM_CMS_BUILD')
            );
          }

          function VendorID(type) {
            return 'dynip' == type || 'lte' == type;
          }

          function APN(type) {
            return 'lte' == type;
          }

          function Login(type) {
            return 'lte' == type;
          }

          function Password(type) {
            return 'lte' == type;
          }

          function WithoutAuth(type) {
            return 'lte' == type;
          }

          function AuthenticationProtocol(type) {
            return 'lte' == type;
          }
          return {
            Enable: !0,
            Name: !0,
            Status: !0,
            AddressingType: !0,
            StaticIP: {
              Address: Address(type),
              SubnetMask: SubnetMask(type),
            },
            GatewayIPAddress: GatewayIPAddress(type),
            DNSAutomatical: DNSAutomatical(type),
            DNSServer1: !0,
            DNSServer2: !0,
            Hostname: Hostname(type),
            VendorID: VendorID(type),
            APN: APN(type),
            Login: Login(type),
            Password: Password(type),
            WithoutAuth: WithoutAuth(type),
            AuthenticationProtocol: AuthenticationProtocol(type),
          };
        }

        function ipv6(type) {
          function Origin() {
            return !isDefined('BRCM_CMS_BUILD');
          }

          function GatewayIPAddressBySlaac(type) {
            return 'dynipv6' == type;
          }

          function DNSAutomatical(type) {
            return 'dynipv6' == type;
          }
          return {
            Enable: !0,
            Name: !0,
            Status: !0,
            Origin: Origin(),
            StaticIP: {
              Address: !0,
              Prefix: !0,
            },
            GatewayIPAddress: !0,
            GatewayIPAddressBySlaac: GatewayIPAddressBySlaac(type),
            DNSAutomatical: DNSAutomatical(type),
            DNSServer1: !0,
            DNSServer2: !0,
          };
        }

        function ppp(type) {
          function isPPPoE(type) {
            return 'pppoe' == type;
          }

          function isXXTP(type) {
            return 'pptp' == type || 'l2tp' == type;
          }

          function isPPPv6(type) {
            return 'pppoev6' == type || 'pppoeDual' == type;
          }

          function is3G(type) {
            return '3g' == type;
          }

          function ServiceName(type) {
            return isPPPoE(type) || isXXTP(type) || isPPPv6(type);
          }

          function APN(type) {
            return is3G(type);
          }

          function DialNumber(type) {
            return is3G(type);
          }

          function EncryptionProtocol(type) {
            return isXXTP(type);
          }

          function AutoConnection(type) {
            return !isDefined('BRCM_CMS_BUILD') && isXXTP(type);
          }

          function IPExtension(type) {
            return !is3G(type) && !isXXTP(type);
          }

          function ExtraOptions(type) {
            return !isDefined('BRCM_CMS_BUILD') && isXXTP(type);
          }

          function StaticIP(type) {
            return !(is3G(type) || 'pppoev6' == type);
          }

          function PPPMPPC(type) {
            return 'pptp' == type;
          }

          function Origin(type) {
            return !isDefined('BRCM_CMS_BUILD') && isPPPv6(type);
          }

          function Address(type) {
            return isPPPv6(type);
          }

          function Prefix(type) {
            return isPPPv6(type);
          }

          function GatewayIPAddress(type) {
            return isPPPv6(type);
          }

          function GatewayIPAddressBySlaac(type) {
            return isPPPv6(type);
          }

          function DNSAutomatical(type) {
            return isPPPv6(type);
          }

          function DNSServer1(type) {
            return isPPPv6(type);
          }

          function DNSServer2(type) {
            return isPPPv6(type);
          }
          return {
            Username: !0,
            Password: !0,
            ServiceName: ServiceName(type),
            WithoutAuth: !0,
            MaxMRUSize: !0,
            KeepAlive: !0,
            LCPEcho: !0,
            LCPEchoRetry: !0,
            APN: APN(type),
            DialNumber: DialNumber(type),
            AuthenticationProtocol: !0,
            EncryptionProtocol: EncryptionProtocol(type),
            AutoConnection: AutoConnection(type),
            ConnectionTrigger: !0,
            IdleDisconnectTime: !0,
            IPExtension: IPExtension(type),
            ExtraOptions: ExtraOptions(type),
            StaticIP: StaticIP(type),
            PPPDebug: !0,
            PPPMPPC: PPPMPPC(type),
            Origin: Origin(type),
            Address: Address(type),
            Prefix: Prefix(type),
            GatewayIPv6Address: GatewayIPAddress(type),
            GatewayIPv6AddressBySlaac: GatewayIPAddressBySlaac(type),
            DNSIPv6Automatical: DNSAutomatical(type),
            DNSIPv6Server1: DNSServer1(type),
            DNSIPv6Server2: DNSServer2(type),
          };
        }

        function mld() {
          return isDefined('BR2_PACKAGE_ANWEB_MLD');
        }
        var constants = opts.constants;
        return {
          connections: connections,
          connection: {
            dynip: dynip,
            ipoeDual: ipoeDual,
            statip: statip,
            ipv4oa: ipv4oa,
            lte: lte,
            dynipv6: dynipv6,
            statipv6: statipv6,
            '3g': g3,
            pppoe: pppoe,
            pppoa: pppoa,
            pptp: pptp,
            l2tp: l2tp,
            pppoev6: pppoev6,
            pppoeDual: pppoeDual,
          },
          media: {
            atm: atm,
          },
          flags: flags,
          vlan: vlan,
          simpleMode: isDefined('BR2_PACKAGE_ANWEB_WAN_SIMPLE_MODE'),
          mld: mld,
          dsysinit: !1,
        };
      }
      module.exports = supported;
    },
    function(module, exports) {
      'use strict';

      function template(opts) {
        function isDefined(name) {
          return constants[name];
        }

        function addAuth8021xSection(output) {
          output.Authorization8021x = {
            Enable: !1,
            EAPMethod: 'EAP-MD5',
            Username: '',
            Password: '',
          };
        }

        function addVLANSection(output) {
          output.VLAN = {
            Enable: !1,
          };
        }

        function addKabinetSection(output) {
          output.Kabinet = {
            Enable: !1,
            Password: '',
          };
        }

        function getPingValue() {
          return isDefined('BR2_PACKAGE_ANWEB_WAN_PING_FOR_ALL');
        }

        function getVendorIDValue() {
          return isDefined('SUPPORT_DYNIP_DEFAULT_VENDER_ID')
            ? constants.DYNIP_DEFAULT_VENDER_ID
            : '';
        }
        var constants = opts.constants,
          media = {};
        media['DSL.ATM'] = function() {
          var output = {
            Enable: !0,
            Encapsulation: 'LLC',
            QoSClass: 'UBR',
            ConnectionMode: 'NewMode',
          };
          return (
            isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
              (output.UseMultiPVC = !1),
            output
          );
        };
        var connection = {};
        return (
          (connection.dynip = function() {
            var output = {
              AddressingType: 'DHCP',
              DNSAutomatical: !0,
              DNSServer1: '',
              DNSServer2: '',
              VendorID: getVendorIDValue(),
              Hostname: '',
              DefaultGateway: !1,
              Flags: {
                NAT: !0,
                Firewall: !0,
                IGMP: !0,
                Ping: getPingValue(),
                RIP: !1,
                AltRoutingTable: !1,
              },
            };
            return (
              isDefined('BR2_PACKAGE_ANWEB_WAN_AUTH_802_1X') &&
                addAuth8021xSection(output),
              isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                addVLANSection(output),
              isDefined('BR2_PACKAGE_ANWEB_WAN_AUTH_KABINET') &&
                addKabinetSection(output),
              output
            );
          }),
          (connection.statip = function() {
            var output = {
              AddressingType: 'Static',
              StaticIPAddress0: '',
              StaticIPSubnetMask0: '',
              GatewayIPAddress: '',
              DNSServer1: '',
              DNSServer2: '',
              DefaultGateway: !1,
              Flags: {
                NAT: !0,
                Firewall: !0,
                IGMP: !0,
                Ping: getPingValue(),
                RIP: !1,
                AltRoutingTable: !1,
              },
            };
            return (
              isDefined('BR2_PACKAGE_ANWEB_WAN_AUTH_802_1X') &&
                addAuth8021xSection(output),
              isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                addVLANSection(output),
              isDefined('BR2_PACKAGE_ANWEB_WAN_AUTH_KABINET') &&
                addKabinetSection(output),
              output
            );
          }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_IPOA') &&
            (connection.ipv4oa = function() {
              return {
                StaticIPAddress0: '',
                StaticIPSubnetMask0: '',
                GatewayIPAddress: '',
                DNSServer1: '',
                DNSServer2: '',
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  IGMP: !0,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
            }),
          isDefined('BR2_PACKAGE_ANWEB_IPV6') &&
            (isDefined('BR2_PACKAGE_ANWEB_WAN_IPOEDUAL') &&
              (connection.ipoeDual = function() {
                var output = {
                  Origin: 'AutoConfigured',
                  GatewayIPAddressBySlaac: !0,
                  GatewayIPAddress: '',
                  DNSAutomatical: !0,
                  DNSServer1: '',
                  DNSServer2: '',
                  DefaultGateway: !1,
                  Flags: {
                    NAT: !1,
                    Firewall: !0,
                    IGMP: !1,
                    Ping: getPingValue(),
                    RIP: !1,
                    AltRoutingTable: !1,
                  },
                };
                return (
                  isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                    addVLANSection(output),
                  (output.AdditionalConnection = {
                    AddressingType: 'DHCP',
                    DNSAutomatical: !0,
                    DNSServer1: '',
                    DNSServer2: '',
                    VendorID: getVendorIDValue(),
                    Hostname: '',
                    DefaultGateway: !1,
                    Flags: {
                      NAT: !0,
                      Firewall: !0,
                      IGMP: !0,
                      Ping: !1,
                      RIP: !1,
                      AltRoutingTable: !1,
                    },
                  }),
                  isDefined('BR2_PACKAGE_ANWEB_WAN_AUTH_802_1X') &&
                    addAuth8021xSection(output.AdditionalConnection),
                  isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                    addVLANSection(output.AdditionalConnection),
                  output
                );
              }),
            (connection.dynipv6 = function() {
              var output = {
                Origin: 'AutoConfigured',
                GatewayIPAddressBySlaac: !0,
                GatewayIPAddress: '',
                DNSAutomatical: !0,
                DNSServer1: '',
                DNSServer2: '',
                DefaultGateway: !1,
                Flags: {
                  NAT: !1,
                  Firewall: !0,
                  IGMP: !1,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                  MLD: !1,
                },
              };
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            }),
            (connection.statipv6 = function() {
              var output = {
                Origin: 'Static',
                Address: '',
                Prefix: '',
                StaticIPAddress0: '',
                StaticIPPrefix0: '',
                GatewayIPAddress: '',
                DNSServer1: '',
                DNSServer2: '',
                DefaultGateway: !1,
                Flags: {
                  Firewall: !0,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                  MLD: !1,
                },
              };
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            })),
          isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE') &&
            (connection.pppoe = function() {
              var output = {
                Username: '',
                Password: '',
                WithoutAuth: !1,
                MaxMRUSize: 1492,
                ServiceName: '',
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                IPExtension: !1,
                StaticIP: '',
                PPPDebug: !1,
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  IGMP: isDefined('BR2_PACKAGE_ANWEB_PPPOE_IGMP_TRUE')
                    ? !0
                    : !1,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE_IPV6') &&
            (connection.pppoev6 = function() {
              var output = {
                Username: '',
                Password: '',
                WithoutAuth: !1,
                MaxMRUSize: 1492,
                ServiceName: '',
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                IPExtension: !1,
                PPPDebug: !1,
                Origin: 'AutoConfigured',
                GatewayIPv6AddressBySlaac: !0,
                GatewayIPv6Address: '',
                DNSIPv6Automatical: !0,
                DNSIPv6Server1: '',
                DNSIPv6Server2: '',
                DefaultGatewayv6: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  IGMP: !1,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOE_DUAL') &&
            (connection.pppoeDual = function() {
              var output = {
                Username: '',
                Password: '',
                WithoutAuth: !1,
                MaxMRUSize: 1492,
                ServiceName: '',
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                IPExtension: !1,
                StaticIP: '',
                PPPDebug: !1,
                Origin: 'AutoConfigured',
                GatewayIPv6AddressBySlaac: !0,
                GatewayIPv6Address: '',
                DNSIPv6Automatical: !0,
                DNSIPv6Server1: '',
                DNSIPv6Server2: '',
                DefaultGatewayv6: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  IGMP: !1,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_PPPOA') &&
            (connection.pppoa = function() {
              var output = {
                Username: '',
                Password: '',
                MaxMRUSize: 1492,
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                IPExtension: !1,
                StaticIP: '',
                PPPDebug: !1,
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  IGMP: !1,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return output;
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_PPTP') &&
            (connection.pptp = function() {
              var output = {
                ActualType: 'PPTP',
                Username: '',
                Password: '',
                WithoutAuth: !1,
                ServiceName: '',
                MaxMRUSize: 1456,
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                StaticIP: '',
                PPPDebug: !1,
                PPPMPPC: !0,
                ExtraOptions: '',
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return output;
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_L2TP') &&
            (connection.l2tp = function() {
              var output = {
                ActualType: 'L2TP',
                Username: '',
                Password: '',
                WithoutAuth: !1,
                MaxMRUSize: 1456,
                KeepAlive: !0,
                LCPEcho: 30,
                LCPEchoRetry: 3,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                EncryptionProtocol: 'None',
                StaticIP: '',
                PPPDebug: !1,
                ExtraOptions: '',
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  Ping: getPingValue(),
                  RIP: !1,
                  AltRoutingTable: !1,
                },
              };
              return output;
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_3G') &&
            (connection['3g'] = function() {
              var output = {
                Username: '',
                Password: '',
                WithoutAuth: !1,
                MaxMRUSize: 1370,
                APN: '',
                DialNumber: '',
                KeepAlive: !0,
                LCPEcho: 20,
                LCPEchoRetry: 10,
                ConnectionTrigger: 'AlwaysOn',
                IdleDisconnectTime: 0,
                AuthenticationProtocol: 'AUTO',
                ExtraOptions: '',
                PPPDebug: !1,
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  Ping: getPingValue(),
                },
              };
              return output;
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_LTE') &&
            (connection.lte = function() {
              var output = {
                AddressingType: 'DHCP',
                DNSAutomatical: !0,
                DNSServer1: '',
                DNSServer2: '',
                VendorID: '',
                Hostname: '',
                APN: '',
                WithoutAuth: !0,
                Login: '',
                Password: '',
                DefaultGateway: !1,
                Flags: {
                  NAT: !0,
                  Firewall: !0,
                  Ping: getPingValue(),
                },
              };
              return (
                isDefined('BR2_SUPPORT_HEALTH_CHECK_LTE') &&
                  (output.HealthCheck = {
                    Enable: !1,
                    PingAddress: '8.8.8.8',
                    MaxPing: 10,
                  }),
                output
              );
            }),
          isDefined('BR2_PACKAGE_ANWEB_WAN_BRIDGE') &&
            (connection.bridge = function() {
              var output = {};
              return (
                isDefined('BR2_PACKAGE_ANWEB_WAN_VLAN_SECTION') &&
                  addVLANSection(output),
                output
              );
            }),
          {
            media: media,
            connection: connection,
          }
        );
      }
      module.exports = template;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        somovd = __webpack_require__(140),
        _ = __webpack_require__(3),
        converter = __webpack_require__(148),
        constants = {
          CONFIG_ID_WIFI: 35,
          CONFIG_ID_WIFI_ADV: 36,
          CONFIG_ID_GET_WIFI_CHANELS: 37,
          CONFIG_ID_GET_WIFI_COUNTRYS: 38,
          CONFIG_ID_WIFI_ONOFF: 39,
          CONFIG_ID_WIFI_STATION: 64,
          CONFIG_ID_WIFI_ADVANCED: 105,
          CONFIG_ID_WIFI_WPS: 106,
          CONFIG_ID_WIFI_WPS_CONNECT: 107,
          CONFIG_ID_WIFI_CLI: 110,
          CONFIG_ID_WIFI_WMM: 111,
          CONFIG_ID_WIFI_SCAN: 133,
          CONFIG_ID_WIFI_SCAN_5G: 185,
          CONFIG_ID_WIFI_CLI_5G: 186,
          CONFIG_ID_WIFI_WDS: 109,
          RPC_NEED_REBOOT: 12,
          RPC_NEED_SAVE: 13,
          RPC_OK: 20,
        };
      module.exports = (function() {
        function getInitData() {
          return funcs.deepClone(__initialData);
        }

        function pull(cb) {
          __pull(
            [
              constants.CONFIG_ID_WIFI,
              constants.CONFIG_ID_GET_WIFI_CHANELS,
              constants.CONFIG_ID_GET_WIFI_COUNTRYS,
              constants.CONFIG_ID_WIFI_STATION,
              constants.CONFIG_ID_WIFI_WMM,
              constants.CONFIG_ID_WIFI_SCAN,
              constants.CONFIG_ID_WIFI_SCAN_5G,
            ],
            null,
            cb
          );
        }

        function pullCommon(cb) {
          __pull(
            [
              constants.CONFIG_ID_WIFI,
              constants.CONFIG_ID_GET_WIFI_CHANELS,
              constants.CONFIG_ID_GET_WIFI_COUNTRYS,
            ],
            null,
            cb
          );
        }

        function pullClient(cb) {
          __pull(
            [constants.CONFIG_ID_WIFI, constants.CONFIG_ID_GET_WIFI_CHANELS],
            null,
            cb
          );
        }

        function pullAdv(cb) {
          __pull([constants.CONFIG_ID_WIFI], null, cb);
        }

        function pullWMM(cb) {
          __pull(
            [constants.CONFIG_ID_WIFI, constants.CONFIG_ID_WIFI_WMM],
            null,
            cb
          );
        }

        function pullWDS(cb) {
          __pull([constants.CONFIG_ID_WIFI], null, cb);
        }

        function updateScan(rq) {
          var responseData = {};
          _.each(rq, function(data, index) {
            responseData[index] = data;
          });
          var wifi = converter.somovdToNative.build({
            $wifi: responseData,
          });
          dms.scanData || (dms.scanData = {});
          var data = funcs.fetchBranch(wifi, 'ScanList.');
          funcs.setValue('Device.WiFi.ScanList', data, dms.scanData);
        }

        function push(cb, forward) {
          var changes = status();
          if (forward || (changes && !_.isEmpty(changes))) {
            var wifi = __prepareChanges(
              changes.Device.WiFi,
              __initialData.Device.WiFi
            );
            wifi = converter.nativeToSomovd.build({
              $wifi: wifi,
            });
            var requests = __prepareRequests(wifi);
            (requests = __addRequestsDeferredReboot(requests)),
              somovd.get().multi(
                {
                  write: requests,
                },
                !1,
                function(response) {
                  var error = __getRQError(response.rq);
                  cb && cb(error);
                }
              );
          }
        }

        function status() {
          return funcs.buildTree(
            funcs.configToResponse(funcs.getChanges(__initialData, dms.data))
          );
        }

        function __pull(rpc, branch, cb) {
          somovd.get().read(rpc, function(response) {
            var error = __getRQError(response.rq);
            if (error) return void (cb && cb(error));
            var responseData = {},
              rq = response.rq;
            _.each(rq, function(elem, index) {
              var rpcID = rpc[index];
              responseData[rpcID] = elem.data;
            });
            var wifi = converter.somovdToNative.build({
              $wifi: responseData,
            });
            if ((dms.data || (dms.data = {}), branch)) {
              var data = funcs.fetchBranch(wifi, branch + '.');
              funcs.setValue('Device.WiFi.' + branch, data, dms.data);
            } else funcs.setValue('Device.WiFi', wifi, dms.data);
            (__initialData = funcs.deepClone(dms.data)), cb && cb();
          });
        }

        function __prepareChanges(changes, init) {
          function radioPrepare(changes, init) {
            accessPointsPrepare(changes, init),
              endPointPrepare(changes, init),
              wmmPrepare(changes, init),
              addRadioRequiredParams(changes.Radio, init.Radio);
          }

          function wdsPrepare(changes, init) {
            changes.WDS = funcs.deepExtend(init.WDS, changes.WDS);
          }

          function wmmPrepare(changes, init) {
            var radio = funcs.fetchBranch(changes, 'Radio.1.'),
              wmm = funcs.fetchBranch(changes, 'Radio.1.WMM.'),
              initWMM = funcs.fetchBranch(init, 'Radio.1.WMM.');
            (wmm || initWMM) &&
              (radio.WMM = funcs.deepExtend(initWMM, wmm || {}));
          }

          function accessPointsPrepare(changes, init) {
            _.each(changes.Radio, function(elem, inst) {
              if (elem.AccessPoint) {
                var radio = changes.Radio[inst],
                  initRadio = init.Radio[inst],
                  aps = changes.Radio[inst].AccessPoint,
                  initAps = init.Radio[inst].AccessPoint;
                isChangeNumberAP(aps) &&
                  (radio.AccessPointNumberOfEntries = getAPNumber(
                    radio,
                    initRadio
                  )),
                  deleteAP(aps, initAps),
                  addPreventAP(aps, initAps),
                  addAccessPointRequiredParams(aps, initAps);
              }
            });
          }

          function endPointPrepare(changes, init) {
            _.each(changes.Radio, function(elem, inst) {
              if (elem.EndPoint) {
                var eps = changes.Radio[inst].EndPoint,
                  initEps = init.Radio[inst].EndPoint;
                addEndPointRequiredParams(eps, initEps);
              }
            });
          }

          function addRadioRequiredParams(changes, init) {
            function hasSomeParams(obj, params) {
              return _.some(params, function(param) {
                return _.has(obj, param);
              });
            }
            var requiredParams = ['OperatingFrequencyBand'],
              bundlesParams = [
                [
                  'AutoChannelEnable',
                  'Channel',
                  'HighChannelEnable',
                  'AutoChannelReselect',
                  'AutoChannelReselectPeriod',
                ],
                [
                  'OperatingChannelBandwidth',
                  'Coexistence',
                  'SecondChannel',
                  'BeaconPeriod',
                  'RTSThreshold',
                  'FragmentationThreshold',
                  'DTIMPeriod',
                  'StationKeepAlive',
                  'HTGI',
                  'AdaptivityMode',
                  'Igmpdrop',
                  'BGProtection',
                  'TxPreamble',
                  'TxBeamforming',
                  'TransmitPower',
                ],
              ];
            _.each(changes, function(elem, inst) {
              _.each(requiredParams, function(param) {
                _.has(elem, param) ||
                  (changes[inst][param] = _.clone(init[inst][param]));
              }),
                _.each(bundlesParams, function(params) {
                  hasSomeParams(elem, params) &&
                    _.each(params, function(param) {
                      _.has(elem, param) ||
                        (changes[inst][param] = _.clone(init[inst][param]));
                    });
                });
            });
          }

          function addAccessPointRequiredParams(aps, initAps) {
            var requiredParams = [
              'SSID',
              'BSSID',
              'Broadcast',
              'GuestAccess',
              'SSIDAdvertisementEnabled',
              'MaxAssociatedDevices',
              'BandwidthRestricted',
              'CPEBlock',
              'ClientIsolation',
            ];
            _.each(aps, function(ap, inst) {
              if (initAps[inst]) {
                _.each(requiredParams, function(param) {
                  _.has(ap, param) ||
                    (aps[inst][param] = _.clone(initAps[inst][param]));
                });
                var sec = aps[inst].Security,
                  initSec = initAps[inst].Security,
                  wps = aps[inst].WPS,
                  initWps = initAps[inst].WPS;
                sec && addPointSecurityRequiredParams(sec, initSec),
                  wps && addPointWPSRequiredParams(wps, initWps);
              }
            });
          }

          function addEndPointRequiredParams(eps, initEps) {
            var requiredParams = [
              'Enable',
              'SSID',
              'BSSID',
              'Band',
              'Security',
            ];
            _.each(eps, function(elem, inst) {
              _.each(requiredParams, function(param) {
                _.has(elem, param) ||
                  (eps[inst][param] = _.clone(initEps[inst][param]));
              });
            }),
              _.each(eps, function(ep, inst) {
                if (initEps[inst]) {
                  var sec = eps[inst].Security,
                    initSec = initEps[inst].Security;
                  sec && addPointSecurityRequiredParams(sec, initSec);
                }
              });
          }

          function addPointSecurityRequiredParams(sec, initSec) {
            var params = [
              'RekeyingInterval',
              'RadiusServerIPAddr',
              'RadiusServerPort',
              'RadiusSecret',
              'ModeEnabled',
              'OpenWEP',
              'OpenWEPType',
              'WEPasHEX',
              'PreSharedKey',
              'DefaultKeyID',
              'EncryptionType',
              'WEPKey1',
              'WEPKey2',
              'WEPKey3',
              'WEPKey4',
              'WEPKey1Type',
              'WEPKey2Type',
              'WEPKey3Type',
              'WEPKey4Type',
            ];
            _.each(params, function(param) {
              _.has(sec, param) || (sec[param] = initSec[param]);
            });
          }

          function addPointWPSRequiredParams(wps, initWps) {
            var params = ['Enable'];
            _.each(params, function(param) {
              _.has(wps, param) || (wps[param] = initWps[param]);
            });
          }

          function isChangeNumberAP(aps) {
            return _.some(_.keys(aps), function(inst) {
              return /\+$/.test(inst) || /\-$/.test(inst);
            });
          }

          function getAPNumber(radio, initRadio) {
            var number = initRadio.AccessPointNumberOfEntries;
            return (
              _.each(_.keys(radio.AccessPoint), function(inst) {
                /\-$/.test(inst) && number--, /\+$/.test(inst) && number++;
              }),
              number
            );
          }

          function deleteAP(aps, initAps) {
            var initSize = _.size(initAps);
            _.each(_.keys(aps), function(inst) {
              if (/-$/.test(inst))
                for (
                  delete aps[inst], delete initAps[parseInt(inst)];
                  parseInt(inst) <= initSize &&
                  ((inst = (parseInt(inst) + 1).toString()),
                  !_.has(aps, inst + '-'));

                )
                  !aps[inst] && initAps[inst] && (aps[inst] = initAps[inst]);
            });
          }

          function addPreventAP(aps, initAps) {
            _.each(aps, function(elem, inst) {
              if (!/-$/.test(inst))
                for (; parseInt(inst) > 1; )
                  (inst = (parseInt(inst) - 1).toString()),
                    !aps[inst] && initAps[inst] && (aps[inst] = initAps[inst]);
            });
          }
          return (
            changes.Radio && radioPrepare(changes, init),
            changes.WDS && wdsPrepare(changes, init),
            changes
          );
        }

        function __prepareRequests(wifi) {
          function getMbssidLen(obj35) {
            var mbssid = obj35.mbssid,
              mbssid_5g = obj35['5G_mbssid'];
            return mbssid || mbssid_5g
              ? mbssid
                ? mbssid.length
                : mbssid_5g
                  ? mbssid_5g.length
                  : mbssid && mbssid_5g
                    ? Math.max(mbssid.length, mbssid_5g.length)
                    : void 0
              : 0;
          }

          function addRequest(rpc, obj35) {
            var data = buildRequestData(rpc, obj35);
            _.isEmpty(data) ||
              requests.push({
                id: rpc,
                data: data,
                pos: -1,
              });
          }

          function addWPSRequest(obj35) {
            var data = _.pick(obj35, 'wps', '5G_wps'),
              wps = obj35.wps || obj35['5G_wps'];
            requests.push(
              _.has(wps, 'WscMethod')
                ? {
                    id: constants.CONFIG_ID_WIFI_WPS_CONNECT,
                    data: data,
                    pos: -1,
                  }
                : {
                    id: constants.CONFIG_ID_WIFI_WPS,
                    data: data,
                    pos: -1,
                  }
            );
          }

          function addWDSRequest(obj35) {
            var data = _.pick(obj35, 'wds');
            requests.push({
              id: constants.CONFIG_ID_WIFI_WDS,
              data: data,
              pos: -1,
            });
          }

          function buildRequestData(rpc, obj35) {
            var data = {},
              mask = getMask(rpc, obj35);
            return (
              _.each(mask, function(param) {
                if (
                  /^mbssid\<index\>/.test(param) ||
                  /^5G_mbssid\<index\>/.test(param)
                ) {
                  var mbssid = {
                      key: param.split('<index>.')[0],
                      index: {},
                      param: param.split('<index>.')[1],
                    },
                    maxIndex = (obj35.mbssidCur || obj35['5G_mbssidCur']) - 1;
                  if (rpc == constants.CONFIG_ID_WIFI)
                    (mbssid.index.input = maxIndex),
                      (mbssid.index.output = 0),
                      hasMbssidParam(obj35, mbssid) &&
                        copyMbssidParam(obj35, data, mbssid);
                  else if (rpc == constants.CONFIG_ID_WIFI_ADV)
                    for (; maxIndex >= 0; )
                      (mbssid.index.input = maxIndex),
                        (mbssid.index.output = maxIndex),
                        hasMbssidParam(obj35, mbssid) &&
                          copyMbssidParam(obj35, data, mbssid),
                        --maxIndex;
                } else _.has(obj35, param) && (data[param] = obj35[param]);
              }),
              data
            );
          }

          function getMask(rpc, obj35) {
            var masks = {};
            (masks[constants.CONFIG_ID_WIFI.toString()] = [
              'CountryCode',
              'WirelessMode',
              '5G_WirelessMode',
              'Channel',
              '5G_Channel',
              'HideSSID',
              'ReselectAutoChannel',
              '5G_ReselectAutoChannel',
              'PeriodReselectChannel',
              '5G_PeriodReselectChannel',
              'allowHighChannels',
              'mbssid<index>.SSID',
              '5G_mbssid<index>.SSID',
              'mbssid<index>.CPE_block',
              '5G_mbssid<index>.CPE_block',
              'mbssid<index>.GuestAccess',
              '5G_mbssid<index>.GuestAccess',
              'mbssid<index>.MaxStaNum',
              '5G_mbssid<index>.MaxStaNum',
              'mbssid<index>.BwRestrict',
              '5G_mbssid<index>.BwRestrict',
              'mbssid<index>.HideSSID',
              '5G_mbssid<index>.HideSSID',
              'mbssid<index>.WifiBroadcast',
              '5G_mbssid<index>.WifiBroadcast',
              'mbssid<index>.Isolation',
              '5G_mbssid<index>.Isolation',
              'mbssid<index>.nsg',
              '5G_mbssid<index>.nsg',
            ]),
              (masks[constants.CONFIG_ID_WIFI_ADV.toString()] = [
                'mbssid<index>.RADIUS_Server',
                '5G_mbssid<index>.RADIUS_Server',
                'mbssid<index>.RADIUS_Port',
                '5G_mbssid<index>.RADIUS_Port',
                'mbssid<index>.RADIUS_Key',
                '5G_mbssid<index>.RADIUS_Key',
                'mbssid<index>.RekeyInterval',
                '5G_mbssid<index>.RekeyInterval',
                'mbssid<index>.AuthMode',
                '5G_mbssid<index>.AuthMode',
                'mbssid<index>.WPAPSK',
                '5G_mbssid<index>.WPAPSK',
                'mbssid<index>.Key1Str',
                '5G_mbssid<index>.Key1Str',
                'mbssid<index>.Key1Type',
                '5G_mbssid<index>.Key1Type',
                'mbssid<index>.Key2Str',
                '5G_mbssid<index>.Key2Str',
                'mbssid<index>.Key2Type',
                '5G_mbssid<index>.Key2Type',
                'mbssid<index>.Key3Str',
                '5G_mbssid<index>.Key3Str',
                'mbssid<index>.Key3Type',
                '5G_mbssid<index>.Key3Type',
                'mbssid<index>.Key4Str',
                '5G_mbssid<index>.Key4Str',
                'mbssid<index>.Key4Type',
                '5G_mbssid<index>.Key4Type',
                'mbssid<index>.DefaultKeyID',
                '5G_mbssid<index>.DefaultKeyID',
                'mbssid<index>.PreAuth',
                '5G_mbssid<index>.PreAuth',
                'mbssid<index>.EncrypType',
                '5G_mbssid<index>.EncrypType',
              ]),
              (masks[constants.CONFIG_ID_WIFI_ONOFF.toString()] = [
                'Radio',
                'mbssidNum',
                'mbssidCur',
                '5G_Radio',
                '5G_mbssidNum',
                '5G_mbssidCur',
              ]),
              (masks[constants.CONFIG_ID_WIFI_ADVANCED.toString()] = [
                'addon_settings',
                '5G_addon_settings',
              ]),
              (masks[constants.CONFIG_ID_WIFI_CLI.toString()] = []),
              obj35 &&
                obj35.apcli &&
                masks[constants.CONFIG_ID_WIFI_CLI.toString()].push('apcli'),
              obj35 &&
                obj35['5G_apcli'] &&
                masks[constants.CONFIG_ID_WIFI_CLI.toString()].push('5G_apcli'),
              (masks[constants.CONFIG_ID_WIFI_WMM.toString()] = [
                'WmmCapable',
                'WmmMode',
                'ap',
                'sta',
              ]);
            var id = rpc.toString();
            return masks[id] ? masks[id] : [];
          }

          function hasMbssidParam(obj35, opts) {
            return (
              _.has(obj35, opts.key) &&
              obj35[opts.key][opts.index.input] &&
              _.has(obj35[opts.key][opts.index.input], opts.param)
            );
          }

          function copyMbssidParam(input, output, opts) {
            var value = input[opts.key][opts.index.input][opts.param];
            output[opts.key] || (output[opts.key] = []),
              output[opts.key][opts.index.output] ||
                (output[opts.key][opts.index.output] = {}),
              (output[opts.key][opts.index.output][opts.param] = _.clone(
                value
              ));
          }
          var requests = [];
          if (wifi[35] && !_.isEmpty(wifi[35])) {
            var obj35 = wifi[35],
              mbssidLen = getMbssidLen(obj35);
            if (mbssidLen) {
              addRequest(constants.CONFIG_ID_WIFI_ONOFF, obj35);
              for (var index = mbssidLen - 1; index >= 0; index--)
                obj35.mbssid &&
                  obj35.mbssid[index] &&
                  (obj35.mbssidCur = index + 1),
                  obj35['5G_mbssid'] &&
                    obj35['5G_mbssid'] &&
                    (obj35['5G_mbssidCur'] = index + 1),
                  addRequest(constants.CONFIG_ID_WIFI_ONOFF, obj35),
                  addRequest(constants.CONFIG_ID_WIFI, obj35),
                  addRequest(constants.CONFIG_ID_WIFI_ADV, obj35);
            } else
              addRequest(constants.CONFIG_ID_WIFI_ONOFF, obj35),
                addRequest(constants.CONFIG_ID_WIFI, obj35);
            addRequest(constants.CONFIG_ID_WIFI_ADVANCED, obj35),
              addRequest(constants.CONFIG_ID_WIFI_CLI, obj35),
              (obj35.wps || obj35['5G_wps']) && addWPSRequest(obj35),
              obj35.wds && addWDSRequest(obj35);
          }
          return (
            wifi[111] &&
              !_.isEmpty(wifi[111]) &&
              addRequest(constants.CONFIG_ID_WIFI_WMM, wifi[111]),
            requests
          );
        }

        function __addRequestsDeferredReboot(requests) {
          return requests.length <= 1
            ? requests
            : _.map(requests, function(elem, index) {
                return (
                  requests.length - 1 != index && (elem.data.wifiReboot = !1),
                  elem
                );
              });
        }

        function __getRQError(rq) {
          for (var i = 0; i < rq.length; i++) {
            var status = rq[i].status;
            if (!__isRPCSuccess(status)) return rq[i].status;
          }
          return null;
        }

        function __isRPCSuccess(status) {
          return (
            status == constants.RPC_OK ||
            status == constants.RPC_NEED_SAVE ||
            status == constants.RPC_NEED_REBOOT
          );
        }
        var __initialData = null,
          dms = {
            getInitData: getInitData,
            data: null,
            scanData: null,
            pull: pull,
            pullCommon: pullCommon,
            pullClient: pullClient,
            pullAdv: pullAdv,
            pullWMM: pullWMM,
            pullWDS: pullWDS,
            updateScan: updateScan,
            push: push,
            status: status,
          };
        return dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        somovdToNative: __webpack_require__(91),
        nativeToSomovd: __webpack_require__(93),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }
      var _defineProperty2 = __webpack_require__(94),
        _defineProperty3 = _interopRequireDefault(_defineProperty2),
        _promise = __webpack_require__(7),
        _promise2 = _interopRequireDefault(_promise),
        _keys = __webpack_require__(150),
        _keys2 = _interopRequireDefault(_keys);
      !(function() {
        function pull(cb) {
          function getWifiCb(res) {
            var errorMsg = "Can't get data from " + rpcs.wifi + ' RPC';
            checkResponse(errorMsg, cb)(res) &&
              (_keys2['default'](prefixes).forEach(function(prefix) {
                res.data &&
                  res.data[prefix + 'Radio'] &&
                  (bandsCursors.push({
                    prefix: prefix,
                    current: 1,
                    number: res.data[prefix + 'mbssidNum'],
                  }),
                  (networks[networkCur++] = {
                    Band: prefixes[prefix],
                    List: res.data[prefix + 'mbssid'].reduce(function(
                      lst,
                      mbssid,
                      inx
                    ) {
                      return (
                        (lst[inx + 1] = {
                          BSSID: mbssid.BSSID,
                          SSID: mbssid.SSID,
                        }),
                        lst
                      );
                    },
                    {}),
                  }));
              }),
              getNextMbssids());
          }

          function getNextMbssids() {
            var data = {};
            bandsCursors.forEach(function(band, inx) {
              data[band.prefix + 'mbssidCur'] = band.current;
            }),
              somovd.write(rpcs.current, data, getMbssids);
          }

          function getMbssids(res) {
            function getMbssidsCb(res) {
              var errorMsg = "Can't get data from " + rpcs.macFilter + ' RPC';
              if (checkResponse(errorMsg, cb)(res)) {
                if (
                  (bandsCursors.forEach(function(band, bandInx) {
                    var networkInx =
                        bandsCursors[getBandInx(band.prefix)].current,
                      network = networks[bandInx].List[networkInx],
                      accessPolicyKey = res.data[band.prefix + 'AccessPolicy'],
                      macFilterList = res.data[band.prefix + 'MacFilterList'];
                    (network.AccessPolicy = accessPolicy[accessPolicyKey]),
                      (network.Enable = '0' != accessPolicyKey);
                    for (var inx in macFilterList)
                      /^\d+$/.test(inx) &&
                        (rules[ruleCur++] = {
                          Network: networkInx + '',
                          Band: bandInx + '',
                          Hostname: macFilterList[inx].hostname,
                          MAC: macFilterList[inx].mac,
                          Enable: macFilterList[inx].active,
                          Inx: inx,
                        });
                    return band.current >= band.number
                      ? void delete bandsCursors[bandInx]
                      : void bandsCursors[bandInx].current++;
                  }),
                  bandsCursors.some(function(el) {
                    return el;
                  }))
                )
                  return void getNextMbssids();
                (dms.data = {
                  Device: {
                    WiFiMACFilter: {
                      Networks: networks,
                      Rules: rules,
                      MaxRulesCount: res.data.MaxNumMacFilter,
                    },
                  },
                }),
                  (dms.__initialData = funcs.deepClone(dms.data)),
                  cb && cb();
              }
            }
            var errorMsg = "Can't get data from " + rpcs.current + ' RPC';
            checkResponse(errorMsg, cb)(res) &&
              somovd.read(rpcs.macFilter).then(getMbssidsCb);
          }

          function getBandInx(prefix) {
            for (var inx in networks)
              if (networks[inx].Band == prefixes[prefix]) return inx;
          }

          function dummy() {}
          var networks = {},
            rules = {},
            cb = cb || dummy,
            bandsCursors = Array(1),
            networkCur = 1,
            ruleCur = 1;
          somovd.read(rpcs.wifi).then(getWifiCb);
        }

        function push(cb) {
          function createPromise(executor) {
            return function() {
              return new _promise2['default'](executor);
            };
          }

          function getNetworksChanged() {
            function addUniqNetworkChanges(networks, key) {
              var path = key.split('.'),
                newKey = path[3] + '.' + path[5];
              return networks.concat(
                isNetworkChange(path) && isUniqNetwork(newKey, networks)
                  ? newKey
                  : []
              );
            }

            function isNetworkChange(path) {
              return 'Networks' == path[2] && 'List' == path[4];
            }

            function isUniqNetwork(key, networks) {
              return !~networks.indexOf(key);
            }
            var networksChanged = _keys2['default'](changes)
              .reduce(addUniqNetworkChanges, [])
              .map(function(key) {
                var path = key.split('.');
                return {
                  band: path[0],
                  network: path[1],
                };
              });
            return networksChanged;
          }

          function getRulesAdded() {
            var list = getWiFiMACFilter().__toAdd;
            return list
              ? list.split(',').map(function(el) {
                  return el.replace(/Rules.(.+)/, '$1');
                })
              : [];
          }

          function getRulesChanged() {
            function addUniqRulesChanges(rules, key) {
              function isRuleChange(path) {
                return 'Rules' == path[2] && /^\d+$/.test(newKey);
              }
              var path = key.split('.'),
                newKey = path[3];
              return rules.concat(
                isRuleChange(path) && isUniqRule(newKey, rules) ? newKey : []
              );
            }

            function isUniqRule(key, rules) {
              return !~rules.indexOf(key);
            }
            var rulesChanged = _keys2['default'](changes).reduce(
              addUniqRulesChanges,
              []
            );
            return rulesChanged;
          }

          function getRulesDeleted() {
            var list = getWiFiMACFilter().__toDel;
            return list
              ? list.split(',').map(function(el) {
                  return el.replace(/Rules.(.+)/, '$1');
                })
              : [];
          }

          function applyNetworksChanges(resolve, reject) {
            var changes = getNetworksChanged(),
              networkInxs = changes[0],
              changeMbssidCur = function(networkInxs) {
                var prefix = getBandPrefix(networkInxs.band),
                  data = _defineProperty3['default'](
                    {},
                    prefix + 'mbssidCur',
                    +networkInxs.network
                  );
                somovd.write(rpcs.current, data, applyNetwork(networkInxs));
              },
              applyNetwork = function(networkInxs) {
                return function(res) {
                  checkResponse('mbssidCur changing is unsuccessful', reject)(
                    res
                  );
                  var prefix = getBandPrefix(networkInxs.band),
                    data = _defineProperty3['default'](
                      {},
                      prefix + 'AccessPolicy',
                      getAccessPolicy(networkInxs)
                    );
                  somovd.write(rpcs.macFilter, data, applyCb);
                };
              },
              applyCb = function(res) {
                var errorMsg = 'AccessPolicy changing is unsuccessful';
                checkResponse(errorMsg, reject), resolve();
              };
            return networkInxs ? void changeMbssidCur(networkInxs) : resolve();
          }

          function applyAddedRules(resolve, reject) {
            var addedRulesChanges = getRulesAdded(),
              addedRuleInx = addedRulesChanges[0],
              rule = getRule(addedRuleInx),
              changeMbssidCur = function(rule) {
                var prefix = getBandPrefix(rule.Band),
                  data = _defineProperty3['default'](
                    {},
                    prefix + 'mbssidCur',
                    +rule.Network
                  );
                somovd.write(rpcs.current, data, applyRule(rule));
              },
              applyRule = function(rule) {
                return function(res) {
                  checkResponse('mbssidCur changing is unsuccessful', reject)(
                    res
                  );
                  var prefix = getBandPrefix(rule.Band),
                    data = _defineProperty3['default'](
                      {},
                      prefix + 'MacFilterList',
                      ruleNativeToSomovd(rule)
                    );
                  somovd.write(rpcs.macFilter, data, -1, applyCb);
                };
              },
              applyCb = function(res) {
                var errorMsg = 'Rule adding is unsuccessful';
                checkResponse(errorMsg, reject), resolve();
              };
            return rule ? void changeMbssidCur(rule) : resolve();
          }

          function applyUpdatedRules(resolve, reject) {
            var updatedRulesChanges = getRulesChanged(),
              updatedRuleInx = updatedRulesChanges[0],
              rule = getRule(updatedRuleInx),
              changeMbssidCur = function(rule) {
                var prefix = getBandPrefix(rule.Band),
                  data = _defineProperty3['default'](
                    {},
                    prefix + 'mbssidCur',
                    +rule.Network
                  );
                somovd.write(rpcs.current, data, applyRule(rule));
              },
              applyRule = function(rule) {
                return function(res) {
                  checkResponse('mbssidCur changing is unsuccessful', reject)(
                    res
                  );
                  var prefix = getBandPrefix(rule.Band),
                    data = _defineProperty3['default'](
                      {},
                      prefix + 'MacFilterList',
                      ruleNativeToSomovd(rule)
                    );
                  somovd.write(rpcs.macFilter, data, +rule.Inx, applyCb);
                };
              },
              applyCb = function(res) {
                var errorMsg = 'Rule updating is unsuccessful';
                checkResponse(errorMsg, reject), resolve();
              };
            return rule ? void changeMbssidCur(rule) : resolve();
          }

          function applyDeletedRules(resolve, reject) {
            var rules = getRulesDeleted().map(function(inx) {
                return getRule(inx + '-');
              }),
              deleteNext = function() {
                var rule = rules.shift();
                return rule ? void changeMbssidCur(rule) : resolve();
              },
              changeMbssidCur = function(rule) {
                var prefix = getBandPrefix(rule.Band),
                  data = _defineProperty3['default'](
                    {},
                    prefix + 'mbssidCur',
                    +rule.Network
                  );
                somovd.write(rpcs.current, data, applyRule(rule));
              },
              applyRule = function(rule) {
                return function(res) {
                  checkResponse('mbssidCur changing is unsuccessful', reject)(
                    res
                  );
                  var prefix = getBandPrefix(rule.Band),
                    data = _defineProperty3['default'](
                      {},
                      prefix + 'MacFilterList',
                      ruleNativeToSomovd(rule)
                    );
                  somovd.remove(rpcs.macFilter, data, +rule.Inx, applyCb);
                };
              },
              applyCb = function(res) {
                var errorMsg = 'Rule deleting is unsuccessful';
                checkResponse(errorMsg, reject), deleteNext();
              };
            deleteNext();
          }

          function getBandPrefix(inx) {
            var band = getWiFiMACFilter().Networks[inx].Band;
            return _.invert(prefixes)[band];
          }

          function getAccessPolicy(networkInxs) {
            var stringAP =
              dms.data.Device.WiFiMACFilter.Networks[networkInxs.band].List[
                networkInxs.network
              ].AccessPolicy;
            return +_.invert(accessPolicy)[stringAP];
          }

          function ruleNativeToSomovd(rule) {
            return {
              mac: rule.MAC,
              hostname: rule.Hostname,
              active: rule.Enable,
            };
          }
          var changes = dms.status();
          return changes
            ? void createPromise(applyNetworksChanges)()
                .then(createPromise(applyAddedRules))
                .then(createPromise(applyUpdatedRules))
                .then(createPromise(applyDeletedRules))
                .then(function() {
                  return cb && cb();
                })
                ['catch'](function(msg) {
                  return cb && cb(msg);
                })
            : cb && cb();
        }
        var _ = __webpack_require__(3),
          funcs = __webpack_require__(5),
          somovd = __webpack_require__(140).get(),
          rpcs = {
            wifi: 35,
            current: 39,
            macFilter: 42,
          },
          prefixes = {
            '': '24',
            '5G_': '5',
          },
          accessPolicy = {
            0: 'off',
            1: 'allow',
            2: 'deny',
          },
          dms = {
            pull: pull,
            push: push,
            data: null,
            __initialData: null,
          },
          getWiFiMACFilter = function() {
            return dms.data.Device.WiFiMACFilter;
          },
          getRule = function(inx) {
            return getWiFiMACFilter().Rules[inx];
          };
        module.exports = dms;
        var checkResponse = function(msg, reject) {
          return function(res) {
            return funcs.is.RPCSuccess(res) ? 1 : reject(msg);
          };
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      module.exports = {
        default: __webpack_require__(151),
        __esModule: !0,
      };
    },
    function(module, exports, __webpack_require__) {
      __webpack_require__(152),
        (module.exports = __webpack_require__(18).Object.keys);
    },
    function(module, exports, __webpack_require__) {
      var toObject = __webpack_require__(153);
      __webpack_require__(154)('keys', function($keys) {
        return function(it) {
          return $keys(toObject(it));
        };
      });
    },
    function(module, exports, __webpack_require__) {
      var defined = __webpack_require__(13);
      module.exports = function(it) {
        return Object(defined(it));
      };
    },
    function(module, exports, __webpack_require__) {
      var $export = __webpack_require__(16),
        core = __webpack_require__(18),
        fails = __webpack_require__(26);
      module.exports = function(KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
          exp = {};
        (exp[KEY] = exec(fn)),
          $export(
            $export.S +
              $export.F *
                fails(function() {
                  fn(1);
                }),
            'Object',
            exp
          );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function pull(cb) {
          function readCb(response) {
            return isError(response)
              ? void (
                  cb &&
                  cb(
                    "Can't read data from " +
                      constants.CONFIG_ID_STA_BANDWIDTH_CONTROL +
                      ' RPC'
                  )
                )
              : ((dms._data = response.data),
                (dms._backup = funcs.deepClone(dms._data)),
                void (cb && cb()));
          }
          somovd.get().read(constants.CONFIG_ID_STA_BANDWIDTH_CONTROL, readCb);
        }

        function getData() {
          return dms._data;
        }

        function wasModified() {
          return !_.isEqual(dms._data, dms._backup);
        }

        function push(cb) {
          function writeCb(response) {
            return isError(response)
              ? void (
                  cb &&
                  cb(
                    "Can't write data to " +
                      constants.CONFIG_ID_STA_BANDWIDTH_CONTROL +
                      ' RPC'
                  )
                )
              : void (cb && cb());
          }
          somovd
            .get()
            .write(
              constants.CONFIG_ID_STA_BANDWIDTH_CONTROL,
              dms._data,
              writeCb
            );
        }

        function isError(response) {
          return 20 !== response.status;
        }
        var _ = __webpack_require__(3),
          funcs = __webpack_require__(5),
          somovd = __webpack_require__(140),
          constants = {
            CONFIG_ID_STA_BANDWIDTH_CONTROL: 258,
          },
          dms = {
            pull: pull,
            push: push,
            getData: getData,
            wasModified: wasModified,
            _data: null,
            _backup: null,
          };
        module.exports = dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      'use version 6';
      !(function() {
        function pull(cb) {
          function readCb(generalResponse) {
            var data = {};
            rpcs.forEach(function(rpc, inx) {
              var response = generalResponse.rq[inx];
              return isError(response)
                ? void (data[rpc.key] = null)
                : void (data[rpc.key] = response.data);
            }),
              (__backup.iface_names = {
                br0: funcs.deepClone(data.wans.iface_names.br0),
              }),
              (dms.data = {
                Device: {
                  DNS: converter.somovdToNative(data),
                },
              }),
              (dms.__initialData = funcs.deepClone(dms.data)),
              cb && cb();
          }
          somovd.get().read(
            rpcs.map(function(rpc) {
              return rpc.num;
            }),
            readCb
          );
        }

        function push(cb) {
          function listMap(rpc) {
            if (rpc.nativeKey && dms.isChanged(rpc.nativeKey)) {
              var data = converter.nativeToSomovd(dms.data.Device.DNS)[rpc.key];
              if ('wans' == rpc.key) {
                var iface_names = funcs.deepClone(__backup.iface_names);
                (iface_names.br0.services.br0.dhcpd.addn_hosts =
                  data.br0.services.br0.dhcpd.addn_hosts),
                  (data = iface_names);
              }
              return {
                id: rpc.num,
                data: data,
                pos: -1,
              };
            }
          }

          function writeCb(response) {
            try {
              response.rq.forEach(rqHandler);
            } catch (err) {
              cb && (cb = cb.bind(null, err));
            } finally {
              cb && cb();
            }
          }

          function rqHandler(rq) {
            if (isError(rq)) throw rq.status;
          }
          var list = {
            write: rpcs.map(listMap).filter(Boolean),
          };
          return list.write.length
            ? void somovd.get().multi(list, !1, writeCb)
            : cb && cb();
        }

        function isError(response) {
          return 20 !== response.status;
        }
        var funcs = (__webpack_require__(3), __webpack_require__(5)),
          somovd = __webpack_require__(140),
          converter = __webpack_require__(157),
          rpcs = [
            {
              key: 'wans',
              num: 1,
              nativeKey: 'Hosts',
            },
            {
              key: 'v4',
              num: 7,
              nativeKey: 'V4',
            },
            {
              key: 'v6',
              num: 132,
              nativeKey: 'V6',
            },
          ],
          dms = {
            pull: pull,
            push: push,
            data: null,
            __initialData: null,
          },
          __backup = {
            iface_names: null,
          };
        module.exports = dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      'use version 6';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }
      var _keys = __webpack_require__(150),
        _keys2 = _interopRequireDefault(_keys);
      !(function() {
        function somovdToNative(data) {
          function getProtocol(protocol) {
            return [
              '$data',
              function(d) {
                return d[protocol]
                  ? T(getPattern(protocol)).build({
                      $data: d,
                    })
                  : !1;
              },
            ];
          }

          function getPattern(protocol) {
            return {
              '->': ['$protocol', 'Servers'],
              $data: ':external',
              $protocol: [
                '$data',
                function(d) {
                  return d[protocol];
                },
              ],
              Servers: {
                '->': !0,
                '{$server, $i}': [
                  '$parent',
                  function(d) {
                    return d.$protocol.servers.split('|').filter(function(e) {
                      return e;
                    });
                  },
                ],
                ':': [
                  '$i',
                  function(i) {
                    return i + 1;
                  },
                ],
                $return: [
                  '$server',
                  function(server) {
                    return server;
                  },
                ],
              },
              Manual: [
                '$protocol',
                function(d) {
                  return d.manual;
                },
              ],
              Defroute: [
                '$protocol',
                function(d) {
                  return d.defroute;
                },
              ],
              Contag: [
                '$protocol',
                function(d) {
                  return d.contag;
                },
              ],
              Ifname: [
                '$protocol',
                function(d) {
                  return d.ifname;
                },
              ],
            };
          }
          var pattern = T({
            '->': ['$data', 'V4', 'V6', 'Ifaces'],
            $data: ':external',
            V4: getProtocol('v4'),
            V6: getProtocol('v6'),
            AvailIPv6: [
              '$data',
              function(d) {
                return !!d.v6;
              },
            ],
            AvailDefroute: [
              '$data',
              function(d) {
                return 'undefined' != typeof d.v4.defroute;
              },
            ],
            Ifaces: getIfaces(data.wans),
            Hosts:
              data.wans.iface_names.br0.services.br0.dhcpd.addn_hosts || [],
          });
          return pattern.build({
            $data: data,
          });
        }

        function nativeToSomovd(data) {
          function getProtocol(protocol) {
            return data[protocol]
              ? {
                  '->': !0,
                  manual: [
                    '$root',
                    function(d) {
                      return d.$data[protocol].Manual;
                    },
                  ],
                  defroute: [
                    '$root',
                    function(d) {
                      return d.$data[protocol].Defroute;
                    },
                  ],
                  contag: [
                    '$root',
                    function(d) {
                      return d.$data[protocol].Contag;
                    },
                  ],
                  ifname: [
                    '$root',
                    function(d) {
                      return d.$data[protocol].Ifname;
                    },
                  ],
                  servers: ['$root', getServers.bind(null, protocol)],
                }
              : null;
          }

          function getServers(protocol, data) {
            var servers = data.$data[protocol].Servers;
            return _keys2['default'](servers)
              .map(function(k) {
                return servers[k];
              })
              .join('|');
          }
          var pattern = T({
            '->': ['$data', 'v4', 'v6'],
            $data: ':external',
            wans: {
              br0: {
                services: {
                  br0: {
                    dhcpd: {
                      addn_hosts: data.Hosts,
                    },
                  },
                },
              },
            },
            v4: getProtocol('V4'),
            v6: getProtocol('V6'),
          });
          return pattern.build({
            $data: data,
          });
        }

        function getIfaces(wans) {
          function checkAndSetInterfaceForAllProtocols(iface) {
            checkAndSetInterface(iface, V4, isIPv4),
              checkAndSetInterface(iface, V6, isIPv6);
          }

          function checkAndSetInterface(iface, dest, checkFn) {
            checkFn(iface) &&
              'auto' !== iface.type &&
              ((dest[iface.iface] = {
                Name: iface.name,
              }),
              iface.contag && (dest[iface.iface].Contag = iface.contag));
          }

          function isIPv4(iface) {
            return !~['ipv6', 'pppv6'].indexOf(iface.type);
          }

          function isIPv6(iface) {
            return !!~['ipv6', 'pppv6', 'pppdual'].indexOf(iface.type);
          }
          var ifaces = wans.iface_names,
            V4 = {},
            V6 = {};
          for (var ifaceKey in ifaces)
            if (ifaces[ifaceKey].is_wan)
              for (var serviceKey in ifaces[ifaceKey].services)
                if ('bridge' != ifaces[ifaceKey].services[serviceKey].type) {
                  checkAndSetInterfaceForAllProtocols(
                    ifaces[ifaceKey].services[serviceKey]
                  );
                  for (var tunnelKey in ifaces[ifaceKey].services[serviceKey]
                    .tunnels)
                    checkAndSetInterfaceForAllProtocols(
                      ifaces[ifaceKey].services[serviceKey].tunnels[tunnelKey]
                    );
                }
          return {
            V4: V4,
            V6: V6,
          };
        }
        var T = __webpack_require__(84).T;
        __webpack_require__(3),
          (module.exports = {
            somovdToNative: somovdToNative,
            nativeToSomovd: nativeToSomovd,
          });
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        somovd = __webpack_require__(140),
        converter = __webpack_require__(121),
        dms = (function() {
          function pull(cb, constants) {
            function readCb(response) {
              if (!funcs.is.allRPCSuccess(response))
                return cb && cb(response.status), response.status;
              var ifaces = response.rq[0]
                ? response.rq[0].data.iface_names
                : void 0;
              if (__constants.isModem)
                var groups = response.rq[1] ? response.rq[1].data : void 0;
              else
                var vlans = response.rq[1] ? response.rq[1].data.vlans : void 0;
              var lan = converter.somovdToNative(ifaces, vlans, groups);
              normalize(lan.LAN),
                (dms.data = {
                  Device: lan,
                }),
                (__initialData = funcs.deepClone(dms.data)),
                cb && cb();
            }
            __constants = _.extend(__constants, constants);
            var rpc = [1];
            __constants.isModem
              ? rpc.push(14)
              : __constants.BR2_SUPPORT_MULTI_LAN && rpc.push(119),
              somovd.get().read(rpc, readCb);
          }

          function push(cb, constants) {
            var changes = status();
            if (_.size(changes)) {
              var changeInterfaces = getChangeInterfaces(),
                convertInterfaces = converter.nativeToSomovd(
                  changeInterfaces,
                  constants
                ),
                list = {
                  write: _.map(convertInterfaces, function(
                    iface,
                    key,
                    interfaces
                  ) {
                    return {
                      id: 1,
                      data: _.pick(interfaces, key),
                      pos: -1,
                    };
                  }),
                };
              somovd.get().multi(list, !1, function(response) {
                writeCb(response, cb);
              });
            }
          }

          function remove(inx, cb) {
            var lan = (somovd.get(), dms.data.Device.LAN[inx]),
              list = {
                remove: [
                  {
                    id: 1,
                    data: [lan.__l3Key],
                    pos: 0,
                  },
                ],
              };
            somovd.get().multi(list, !1, function(response) {
              writeCb(response, cb);
            });
          }

          function writeCb(response, cb) {
            if (!funcs.is.allRPCSuccess(response)) return cb && cb(!0), status;
            var flags = {
              saveAndReboot: isNeedSaveAndReboot(response),
            };
            cb && cb(null, flags);
          }

          function isNeedSaveAndReboot(response) {
            return _.some(response.rq, function(elem) {
              return 12 == elem.status;
            });
          }

          function status() {
            return _.isNull(dms.data)
              ? {}
              : funcs.getChanges(__initialData, dms.data);
          }

          function getChangeInterfaces() {
            var changes = status(),
              keys = [];
            return (
              _.each(changes, function(value, key) {
                var re = /^Device.LAN.(\d+)./,
                  matcher = key.match(re);
                if (!_.isNull(matcher)) {
                  var instance = matcher[1];
                  _.contains(keys, instance) || keys.push(instance);
                }
              }),
              {
                LAN: _.pick(dms.data.Device.LAN, keys),
              }
            );
          }

          function normalize(lan) {
            function getPostfix(elem, key) {
              if (!elem.__l2Key) return key;
              var postfix = elem.__l2Key;
              return (
                (postfix = postfix.replace(/[^0-9]+/g, '')),
                (parseInt(postfix) + 1).toString()
              );
            }
            _.each(lan, function(elem, key) {
              '1' != key &&
                (_.has(elem, 'Name') ||
                  (elem.Name = 'LAN' + getPostfix(elem, key)),
                _.has(elem, 'Enable') || (elem.Enable = !0),
                elem.IPv4 || (elem.IPv4 = {}),
                elem.IPv4.StaticIP &&
                  (elem.IPv4.StaticIP[1] || (elem.IPv4.StaticIP[1] = {}),
                  _.isEmpty(elem.IPv4.StaticIP[1]) &&
                    ((elem.IPv4.StaticIP[1].Address = ''),
                    (elem.IPv4.StaticIP[1].SubnetMask = '')),
                  _.isEmpty(elem.IPv4.StaticIP[2]) &&
                    delete elem.IPv4.StaticIP[2]),
                elem.IPv4.DHCP || (elem.IPv4.DHCP = {}),
                elem.IPv4.DHCP.Mode || (elem.IPv4.DHCP.Mode = 'Disable'),
                elem.IPv6 || (elem.IPv6 = {}),
                elem.IPv6.AddressingMode || (elem.IPv6.AddressingMode = 'PD'),
                elem.IPv6.StaticIP &&
                  (elem.IPv6.StaticIP[1] || (elem.IPv6.StaticIP[1] = {}),
                  _.isEmpty(elem.IPv6.StaticIP[1]) &&
                    ((elem.IPv6.StaticIP[1].Address = ''),
                    (elem.IPv6.StaticIP[1].Prefix = ''))),
                elem.IPv6.DHCP || (elem.IPv6.DHCP = {}),
                elem.IPv6.DHCP.Mode || (elem.IPv6.DHCP.Mode = 'Disable'));
            });
          }
          var __constants = {},
            __initialData = null;
          return {
            pull: pull,
            push: push,
            remove: remove,
            status: status,
            data: null,
          };
        })();
      module.exports = dms;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function pull(cb) {
          function readCb(generalResponse) {
            if (generalResponse.rq.some(isError)) throw new Error('RPC error');
            var data = generalResponse.rq[0].data;
            (data.port_status = generalResponse.rq[1].data),
              (dms.data = {
                Device: {
                  VLAN: somovdToNative(data),
                },
              }),
              (dms.__initialData = funcs.deepClone(dms.data)),
              cb && cb();
          }
          somovd.get().read([119, 129], readCb);
        }

        function push(cb) {
          function writeCb(response) {
            return isError(response)
              ? cb && cb(response.status)
              : void (cb && cb());
          }
          return dms.isChanged
            ? somovd
                .get()
                .write(119, nativeToSomovd(dms.data.Device.VLAN), writeCb)
            : cb && cb();
        }

        function isError(response) {
          return 20 !== response.status;
        }
        var funcs = (__webpack_require__(3), __webpack_require__(5)),
          somovd = __webpack_require__(140),
          converter = __webpack_require__(160),
          somovdToNative = converter.somovdToNative,
          nativeToSomovd = converter.nativeToSomovd,
          dms = {
            pull: pull,
            push: push,
            data: null,
            __initialData: null,
          };
        module.exports = dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        module.exports = {
          somovdToNative: __webpack_require__(161),
          nativeToSomovd: __webpack_require__(162),
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        var _ = __webpack_require__(3);
        module.exports = function(data) {
          function makePorts(acc, port) {
            return (acc[port] = makePort(port)), acc;
          }

          function makePort(port) {
            return {
              Alias: getAlias(port),
              IsWan: isWan(port),
              IsWifi: isWifi(port),
            };
          }

          function getAlias(port) {
            var portObj = data.port_status[port];
            return portObj ? portObj.alias || port : port;
          }

          function isWan(port) {
            var portObj = data.port_status[port];
            return portObj ? !!portObj.is_wan : !1;
          }

          function isWifi(port) {
            return !port.indexOf('wifi');
          }

          function makeVlans(acc, vlan, inx) {
            return (acc[inx + 1] = makeVlan(vlan)), acc;
          }

          function makeVlan(vlan) {
            var preparedPorts = preparePorts(vlan),
              result = {
                Name: vlan.name,
                Vid: vlan.vid,
                Enable: vlan.en,
                Iface: vlan.ifname,
                OLT: vlan.OLT,
                Type: getType(vlan, preparedPorts),
                PortsUNumberOfEntries: preparedPorts.qty.u,
                PortsU: preparedPorts.u,
                PortsTNumberOfEntries: preparedPorts.qty.t,
                PortsT: preparedPorts.t,
                Qos: preparedPorts.qos,
              };
            return (
              vlan.vid_range_end && (result.VidRangeEnd = vlan.vid_range_end),
              result
            );
          }

          function preparePorts(vlan) {
            function handlePort(port, key) {
              var type = port.tag ? 't' : 'u';
              (qos = port.qos),
                (ports[type][++inx[type]] = {
                  Key: key,
                  Alias: getAlias(key),
                });
            }
            var qos,
              ports = {
                t: {},
                u: {},
              },
              inx = {
                t: 0,
                u: 0,
              };
            return (
              _.each(vlan.ports, handlePort),
              (ports.qty = inx),
              _.isNumber(qos) && (ports.qos = qos),
              ports
            );
          }

          function getType(vlan, ports) {
            var type = vlan.dest;
            return 'bridge' === type ? type : type + (ports.qty.u ? 'u' : 't');
          }
          var result = {};
          return (
            (result.Ports = data.avail_ports.reduce(makePorts, {})),
            (result.ListNumberOfEntries = _.size(data.vlans)),
            (result.List = data.vlans.reduce(makeVlans, {})),
            result
          );
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        var _ = __webpack_require__(3);
        module.exports = function(data) {
          function convertVlan(vlan, inx) {
            var result = {
              name: vlan.Name,
              dest: getDest(vlan),
              vid: vlan.Vid,
              en: vlan.Enable,
              ifname: vlan.Iface,
              OLT: vlan.OLT,
              ports: getPorts(vlan),
            };
            return (result.vid_range_end = vlan.VidRangeEnd), result;
          }

          function getDest(vlan) {
            return vlan.Type.replace(/(u|t)$/, '');
          }

          function getPorts(vlan) {
            function makePort(isTagged) {
              return function(port) {
                (ports[port.Key] = {
                  tag: isTagged,
                }),
                  null != vlan.Qos && (ports[port.Key].qos = vlan.Qos);
              };
            }
            var ports = {};
            return (
              _.each(_.filter(vlan.PortsT, isNotDeleted), makePort(!0)),
              _.each(_.filter(vlan.PortsU, isNotDeleted), makePort(!1)),
              ports
            );
          }

          function isNotDeleted(val, inx) {
            return /[^\-]$/.test(inx);
          }
          var result = {
            vlans: _.map(_.filter(data.List, isNotDeleted), convertVlan),
          };
          return result;
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function pull(cb) {
          return clean(), pullDirData(cb);
        }

        function push(cb) {
          return dms.isChanged() ? pushDirData(cb) : cb && cb();
        }

        function pushDirData(cb) {
          function writeCb(response) {
            return isError(response)
              ? cb && cb(response.status)
              : ((dms.__initialData = funcs.deepClone(dms.data)),
                void (cb && cb()));
          }
          return somovd
            .get()
            .write(
              constants.CONFIG_ID_GROUP_VLAN,
              nativeToSomovd(dms.data),
              writeCb
            );
        }

        function pullDirData(cb) {
          function readCb(response) {
            if (response.rq.some(isError)) throw new Error('RPC error');
            var data = {
              portsData: response.rq[1].data,
              vlansData: response.rq[0].data,
            };
            (dms.data = somovdToNative(data)),
              (dms.__initialData = funcs.deepClone(dms.data)),
              cb && cb();
          }
          return somovd
            .get()
            .read(
              [constants.CONFIG_ID_GROUP_VLAN, constants.CONFIG_ID_PORTS],
              readCb
            );
        }

        function isError(response) {
          return 12 !== response.status && 20 !== response.status;
        }

        function isChanged() {
          if (!dms.data && !dms.__initialData) return !1;
          var hasRemoved =
              _.keys(dms.data.sources).length !=
              _.keys(dms.__initialData.sources).length,
            changes = funcs.getChangesWithRemoved(dms.__initialData, dms.data);
          return hasRemoved || !_.isEmpty(changes);
        }

        function clean() {
          (dms.data = null), (dms.__initialData = null);
        }
        var _ = __webpack_require__(3),
          funcs = __webpack_require__(5),
          somovd = __webpack_require__(140),
          somovdToNative = __webpack_require__(164),
          nativeToSomovd = __webpack_require__(165),
          constants = {
            CONFIG_ID_GROUP_VLAN: 119,
            CONFIG_ID_PORTS: 129,
          },
          dms = {
            pull: pull,
            push: push,
            data: null,
            __initialData: null,
            isChanged: isChanged,
          };
        module.exports = dms;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function toNative(input, options) {
        var sources = getSources(input),
          ports = getPorts(input, sources),
          lanPorts = ports.lanPorts,
          wanPorts = ports.wanPorts,
          model = {
            sources: sources,
            lanPorts: lanPorts,
            wanPorts: wanPorts,
          };
        return model;
      }

      function getPorts(params, sources) {
        var portsData = params.portsData,
          vlansData = params.vlansData,
          result = _.reduce(
            vlansData.avail_ports,
            function(memo, port, index) {
              var mappedPort = mapPort(port, {
                  portsData: portsData,
                  vlansData: vlansData,
                  sources: sources,
                }),
                mapKey = mappedPort.isWan ? 'wanPorts' : 'lanPorts',
                newIndex = _.size(memo[mapKey]);
              return (memo[mapKey][newIndex] = mappedPort), memo;
            },
            {
              lanPorts: {},
              wanPorts: {},
            }
          );
        return result;
      }

      function mapPort(port, params) {
        function isSelected(port) {
          var portVlans = _.filter(vlansData.vlans, function(vlan) {
            return _.contains(_.keys(vlan.ports), port);
          });
          return 0 != portVlans.length;
        }

        function getPortBridge(port) {
          var portVlans = _.filter(vlansData.vlans, function(vlan) {
              return _.contains(_.keys(vlan.ports), port);
            }),
            portSources = _.chain(sources)
              .omit(function(source, sourceId) {
                return !_.some(portVlans, function(vlan) {
                  return (
                    source.name == vlan.name &&
                    (isWan(port) || 'lan' != vlan.dest)
                  );
                });
              })
              .keys()
              .value();
          return isWan(port) ? portSources : _.first(portSources) || null;
        }

        function getAlias(port) {
          var portObj = portsData[port];
          return portObj ? portObj.alias || port : port;
        }

        function isWan(port) {
          var portObj = portsData[port];
          return portObj ? !!portObj.is_wan : !1;
        }

        function isWifi(port) {
          return !port.indexOf('wifi');
        }
        var portsData = params.portsData,
          vlansData = params.vlansData,
          sources = params.sources,
          mappedPort = {
            name: port,
            alias: getAlias(port),
            isWan: isWan(port),
            isWifi: isWifi(port),
            bridge: getPortBridge(port),
            isSelected: isSelected(port),
          };
        return mappedPort;
      }

      function getSources(params) {
        var vlansData = (params.portsData, params.vlansData),
          result = _.reduce(
            vlansData.vlans,
            function(memo, vlan, index) {
              var source = mapSource(vlan);
              return (memo[index] = source), memo;
            },
            {}
          );
        return result;
      }

      function mapSource(vlan) {
        return {
          type: vlan.dest,
          vid: vlan.vid ? vlan.vid : null,
          name: vlan.name,
          enabled: vlan.en,
          iface: vlan.ifname,
        };
      }
      var _ = __webpack_require__(3);
      module.exports = toNative;
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function toSomovd(data) {
        function getVlans() {
          var vlans = _.map(data.sources, function(source, sourceId) {
            return {
              name: source.name,
              dest: source.type,
              vid: source.vid,
              ifname: source.iface,
              en: source.enabled,
              ports: getPorts(source, sourceId),
            };
          });
          return vlans;
        }

        function getPorts(source, sourceId) {
          var lanPorts = _.filter(data.lanPorts, function(port) {
              return (
                (port.isSelected || port.bridge) &&
                bridgeIsSource(port.bridge, source, sourceId)
              );
            }),
            wanPorts = _.filter(data.wanPorts, function(port) {
              return _.some(port.bridge, function(bridge) {
                return bridgeIsSource(bridge, source, sourceId);
              });
            }),
            reducer = function(isWan) {
              return function(memo, port) {
                return (
                  (memo[port.name] = {
                    tag: !!isWan && !!source.vid,
                  }),
                  memo
                );
              };
            },
            ports = _.extend(
              {},
              _.reduce(lanPorts, reducer(!1), {}),
              _.reduce(wanPorts, reducer(!0), {})
            );
          return ports;
        }

        function bridgeIsSource(bridge, source, sourceId) {
          return (!bridge && 'lan' == source.type) || bridge == sourceId;
        }
        var result = {
          vlans: getVlans(),
        };
        return result;
      }
      var _ = __webpack_require__(3);
      module.exports = toSomovd;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var newConfig = __webpack_require__(167),
        oldConfig = __webpack_require__(168);
      module.exports = {
        newConfig: newConfig,
        oldConfig: oldConfig,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var newConfig = __webpack_require__(170),
        oldConfig = __webpack_require__(171);
      module.exports = {
        newConfig: newConfig,
        oldConfig: oldConfig,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }
      var _promise = __webpack_require__(7),
        _promise2 = _interopRequireDefault(_promise),
        funcs = (__webpack_require__(3), __webpack_require__(5)),
        somovd = __webpack_require__(140);
      module.exports = (function() {
        function pull() {
          return new _promise2['default'](function(resolve, reject) {
            function readCb(response) {
              return funcs.is.RPCSuccess(response)
                ? ((data = response.data), void resolve())
                : void reject();
            }
            var transport = somovd.get();
            transport.read(constants.CONFIG_ID_DOS_FILTER, readCb);
          });
        }

        function getData() {
          var initData = workCopy();
          return initData;
        }

        function apply(applyData) {
          return new _promise2['default'](function(resolve, reject) {
            function writeCb(response) {
              return funcs.is.RPCSuccess(response)
                ? void resolve()
                : void reject();
            }
            var transport = somovd.get();
            console.log('applyData', applyData),
              transport.write(
                constants.CONFIG_ID_DOS_FILTER,
                applyData,
                -1,
                writeCb
              );
          });
        }

        function workCopy() {
          return funcs.deepClone(data);
        }
        var constants = {
            CONFIG_ID_DOS_FILTER: 251,
          },
          data = null,
          util = {
            pull: pull,
            getData: getData,
            apply: apply,
          };
        return util;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var oldConfig = __webpack_require__(173);
      module.exports = {
        oldConfig: oldConfig,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }
      var _promise = __webpack_require__(7),
        _promise2 = _interopRequireDefault(_promise),
        _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        somovd = __webpack_require__(140),
        dms = __webpack_require__(141);
      module.exports = (function() {
        function pullStatus() {
          return new _promise2['default'](function(resolve, reject) {
            function readCb(response) {
              return funcs.is.RPCSuccess(response)
                ? ((util.statusData = response.data), void resolve())
                : void reject();
            }
            var transport = somovd.get();
            transport.read(constants.CONFIG_ID_OPENVPN_STATUS, readCb);
          });
        }

        function pullSettings(_constants) {
          return new _promise2['default'](function(resolve, reject) {
            function readCb(response) {
              return funcs.is.allRPCSuccess(response)
                ? ((util.settingsData = response.data),
                  (util.lanSubnet = []),
                  void dmsLan.pull(function(status) {
                    return status
                      ? void reject()
                      : ((util.lanSubnet = _.chain(dmsLan.data.Device.LAN)
                          .map(function(subnet) {
                            var staticIP =
                              subnet.IPv4 &&
                              subnet.IPv4.StaticIP &&
                              subnet.IPv4.StaticIP[1];
                            return staticIP
                              ? _.pick(staticIP, ['Address', 'SubnetMask'])
                              : null;
                          })
                          .compact()
                          .value()),
                        void resolve());
                  }, _constants))
                : void reject();
            }
            var transport = somovd.get(),
              dmsLan = dms.get().lan;
            transport.read(constants.CONFIG_ID_OPENVPN, readCb);
          });
        }

        function pullKeys() {
          return new _promise2['default'](function(resolve, reject) {
            function readCb(response) {
              return funcs.is.RPCSuccess(response)
                ? ((util.keysData = response.data), void resolve())
                : void reject();
            }
            var transport = somovd.get();
            transport.read(constants.CONFIG_ID_OPENVPN_AUTH, readCb);
          });
        }

        function pushSettings() {
          return new _promise2['default'](function(resolve, reject) {
            function writeCb(response) {
              return funcs.is.RPCSuccess(response)
                ? void resolve()
                : void reject();
            }
            var transport = somovd.get();
            transport.write(
              constants.CONFIG_ID_OPENVPN,
              getApplyFields(util.settingsData),
              -1,
              writeCb
            );
          });
        }

        function getApplyFields(applyData) {
          var clientFields = [
              'enable',
              'mode',
              'port',
              'proto',
              'cipher',
              'auth',
              'tls_auth',
              'crl_verify',
              'remote',
            ],
            serverFields = [
              'enable',
              'mode',
              'port',
              'proto',
              'cipher',
              'auth',
              'tls_auth',
              'crl_verify',
              'network',
              'netmask',
              'duplicate_cn',
              'client_to_client',
              'tunnel_type',
              'local_networks',
              'remote_networks',
            ],
            data = {};
          return (
            'client' == applyData.mode &&
              _.each(applyData, function(elem, key) {
                -1 != _.indexOf(clientFields, key) && (data[key] = elem);
              }),
            'server' == applyData.mode &&
              _.each(applyData, function(elem, key) {
                -1 != _.indexOf(serverFields, key) && (data[key] = elem);
              }),
            data
          );
        }

        function pushKey(key) {
          return new _promise2['default'](function(resolve, reject) {
            function writeCb(response) {
              return funcs.is.RPCSuccess(response)
                ? void resolve()
                : void reject();
            }
            var transport = somovd.get();
            transport.write(constants.CONFIG_ID_OPENVPN_AUTH, key, -1, writeCb);
          });
        }

        function restart() {
          return new _promise2['default'](function(resolve, reject) {
            function writeCb(response) {
              return funcs.is.RPCSuccess(response)
                ? void resolve()
                : void reject();
            }
            var transport = somovd.get();
            transport.write(
              constants.CONFIG_ID_OPENVPN_RESTART,
              {},
              -1,
              writeCb
            );
          });
        }

        function checkBelongLanSubnet(ip) {
          return (
            !!ip &&
            funcs.is.ipv4(ip) &&
            _.some(util.lanSubnet, function(subnet) {
              var range = funcs.ipv4.subnet.getNetworkRange(
                subnet.Address,
                subnet.SubnetMask
              );
              return funcs.ipv4.subnet.belongNetworkRange(range, ip);
            })
          );
        }
        var constants = {
            CONFIG_ID_OPENVPN: 252,
            CONFIG_ID_OPENVPN_STATUS: 253,
            CONFIG_ID_OPENVPN_AUTH: 254,
            CONFIG_ID_OPENVPN_RESTART: 255,
          },
          util = {
            statusData: null,
            settingsData: null,
            keysData: null,
            pullStatus: pullStatus,
            pullSettings: pullSettings,
            pullKeys: pullKeys,
            pushSettings: pushSettings,
            pushKey: pushKey,
            restart: restart,
            getApplyFields: getApplyFields,
            checkBelongLanSubnet: checkBelongLanSubnet,
          };
        return util;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var dms = __webpack_require__(141).get().devinfo,
        pull = function(cb) {
          return dms.pull(cb);
        },
        data = function() {
          return dms.data;
        },
        dataModel = function(obj) {
          return obj && (dms.dataModel = obj), dms.dataModel;
        };
      module.exports = {
        pull: pull,
        data: data,
        dataModel: dataModel,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        dms = __webpack_require__(141).get().wan,
        funcs = __webpack_require__(5),
        connections = __webpack_require__(176);
      module.exports = (function() {
        function pull(cb) {
          return dms.pull(cb);
        }

        function push(cb) {
          return dms.push(cb);
        }

        function data() {
          return dms.data;
        }

        function setData(data) {
          dms.setData(data);
        }

        function getWanUpdateArea() {
          return dms.getWanUpdateArea();
        }

        function reconnect(items, cb) {
          var paths = _.map(items, function(elem) {
            var dataModel = getDataModelName(elem.type);
            return 'Device.WAN.' + dataModel + '.Connection.' + elem.inx + '.';
          });
          dms.reconnect(paths, cb);
        }

        function defineConstants(consts) {
          constants = funcs.deepClone(consts);
        }

        function isDefined(name) {
          return constants && constants[name];
        }

        function supportedFn() {
          return dms.supported({
            constants: constants,
          });
        }

        function templateFn() {
          return dms.template({
            constants: constants,
          });
        }

        function getDefaultGateway(version) {
          var key = 'Device.WAN.IP' + version + 'DefaultGateway',
            value = funcs.fetchBranch(wan.data(), key);
          return value ? value : null;
        }

        function setDefaultGateway(version, path) {
          var key = 'IP' + version + 'DefaultGateway';
          wan.data().Device.WAN[key] = path;
        }

        function getIgmpInstance() {
          var list = wan.ipv4oe.list();
          return (
            _.findKey(list, function(elem, inx) {
              return elem.Flags && 1 == elem.Flags.IGMP;
            }) || null
          );
        }

        function setIgmpInstance(instance, cb) {
          var list = wan.ipv4oe.list();
          _.each(list, function(elem, inx) {
            elem.Flags && (elem.Flags.IGMP = instance == inx ? !0 : !1);
          });
        }

        function getMLDInstance() {
          var list = wan.ipv6oe && wan.ipv6oe.list ? wan.ipv6oe.list() : [];
          return (
            _.findKey(list, function(elem, inx) {
              return elem.Flags && 1 == elem.Flags.MLD;
            }) || null
          );
        }

        function setMLDInstance(instance, cb) {
          var list = wan.ipv6oe.list();
          _.each(list, function(elem, inx) {
            elem.Flags && (elem.Flags.MLD = instance == inx ? !0 : !1);
          });
        }

        function useAutomaticalPPTP() {
          return dms.data.Device.WAN.UseAutomaticalPPTP;
        }

        function getDataModelName(type) {
          var dataModelMap = {
            ipv4oe: 'IPv4oE',
            ipv4oa: 'IPoA',
            ipv6oe: 'IPv6oE',
            pppoe: 'PPPoE',
            pppoev6: 'PPPoEv6',
            pppoeDual: 'PPPoEDual',
            pppoa: 'PPPoA',
            pptp: 'PPTP',
            lte: 'LTE',
            '3g': '3G',
            bridge: 'Bridge',
          };
          return dataModelMap[type] ? dataModelMap[type] : null;
        }

        function checkRemoveWarning(items) {
          function isDefaultGateway(connection) {
            return connection.DefaultGateway || connection.DefaultGatewayv6;
          }

          function isNeedHigherRemoveWarning(higher, connection, items) {
            return higher && connection.DefaultGateway
              ? !_.find(items, function(item) {
                  return (
                    item.type == higher.type && item.inx == higher.instance
                  );
                })
              : !1;
          }
          var warnings = [];
          return (
            _.isArray(items) || (items = [items]),
            _.each(items, function(item) {
              var name = getDataModelName(item.type),
                path = 'Device.WAN.' + name + '.Connection.' + item.inx + '.',
                connection = funcs.fetchBranch(dms.data, path),
                higherConnection = getHigherLevelConnection(connection);
              isDefaultGateway(connection) &&
                warnings.push({
                  warning: 'default_gateway',
                  connection: connection,
                }),
                isNeedHigherRemoveWarning(
                  higherConnection,
                  connection,
                  items
                ) &&
                  warnings.push({
                    warning: 'has_higher_level',
                    connection: connection,
                    higher: higherConnection.data,
                  });
            }),
            warnings
          );
        }

        function getHigherLevelConnection(connection) {
          var allConns = connections.flattenConnections();
          return _.find(allConns, function(conn) {
            return (
              '4' == conn.data.__Layer &&
              conn.data.__LowerLayer == connection.__Key
            );
          });
        }
        var constants = null,
          wan = {
            pull: pull,
            push: push,
            data: data,
            setData: setData,
            reconnect: reconnect,
            supported: supportedFn,
            template: templateFn,
            defineConstants: defineConstants,
            isDefined: isDefined,
            getWanUpdateArea: getWanUpdateArea,
            getDefaultGateway: getDefaultGateway,
            setDefaultGateway: setDefaultGateway,
            getIgmpInstance: getIgmpInstance,
            setIgmpInstance: setIgmpInstance,
            getMLDInstance: getMLDInstance,
            setMLDInstance: setMLDInstance,
            useAutomaticalPPTP: useAutomaticalPPTP,
            getDataModelName: getDataModelName,
            checkRemoveWarning: checkRemoveWarning,
            media: __webpack_require__(177),
          };
        return (wan = _.extend(wan, connections));
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function flattenConnections(types, ignoreRemoved) {
        var raws = [];
        if (!types) var types = _.keys(connections);
        return (
          _.each(types, function(type) {
            function isRemoved(inx) {
              return '-' == _.last(inx);
            }
            if (!_.isUndefined(connections[type]) && connections[type].list) {
              var connsList = connections[type].list();
              _.each(connsList, function(conn, inx) {
                if (!ignoreRemoved || !isRemoved(inx)) {
                  var obj = {
                    instance: inx,
                    type: type,
                    data: conn,
                  };
                  raws.push(obj);
                }
              });
            }
          }),
          raws
        );
      }

      function getIfaceConnections(iface) {
        function conTypeHandler(isTunnel) {
          return function(conType) {
            _.each(conType.Connection, connectionHandler(isTunnel));
          };
        }

        function connectionHandler(isTunnel) {
          return function(connection) {
            var layer = isTunnel ? 4 : 3;
            return connection.__Layer == layer
              ? isTunnel
                ? void (
                    ~keys.indexOf(connection.__LowerLayer) &&
                    names.push(connection.Name)
                  )
                : void (
                    connection.__LowerLayer === iface &&
                    (names.push(connection.Name), keys.push(connection.__Key))
                  )
              : void 0;
          };
        }
        var wan = dms.data.Device.WAN,
          names = [],
          keys = [];
        return (
          _.each(wan, conTypeHandler(!1)),
          _.each(wan, conTypeHandler(!0)),
          names
        );
      }

      function conflictsConnections(obj, type, instance) {
        function getConnections(type, instance, needAdditional, ignoreRemoved) {
          function prepareConnections(conns, type, instance) {
            function isRemoved(elem) {
              return '-' == _.last(elem.inst);
            }
            return _.chain(conns)
              .map(function(conn, inst) {
                return {
                  inst: inst,
                  type: type,
                  data: conn,
                };
              })
              .filter(function(elem) {
                return instance && elem.inst == instance
                  ? !1
                  : ignoreRemoved && isRemoved(elem)
                    ? !1
                    : !0;
              })
              .value();
          }
          if (!connections[type].list) return [];
          var conns = connections[type].list(),
            output = prepareConnections(conns, type, instance);
          if (needAdditional)
            switch (type) {
              case 'ipv4oe':
              case 'ipv6oe':
                output = output.concat(getConnections('bridge'));
                break;
              case 'bridge':
                output = output
                  .concat(getConnections('ipv4oe'))
                  .concat(getConnections('ipv6oe'));
            }
          return output;
        }

        function ipv6Conflicts(conns, obj) {
          return 'Static' == obj.Origin
            ? []
            : mediaAndVlanConflicts(conns, obj, 'ipv6oe');
        }

        function lowerLayerConflicts(conns, obj) {
          var result = [];
          return (
            _.each(conns, function(conn) {
              var elem = conn.data;
              if (_.has(elem, '__LowerConnection')) {
                if (!obj.__LowerConnection) return;
                if (obj.__LowerConnection != elem.__LowerConnection) return;
              } else if (
                (elem.AutomaticalConnection &&
                  result.push({
                    type: 'pptp',
                    instance: conn.inst,
                  }),
                obj.__LowerLayer != elem.__LowerLayer)
              )
                return;
              result.push({
                type: 'pptp',
                instance: conn.inst,
              });
            }),
            result
          );
        }

        function mediaAndVlanConflicts(conns, obj, type) {
          if (!conns.length) return [];
          var result = [];
          return (
            _.each(conns, function(conn) {
              isUniqMedia(conn.data, obj) ||
                (isUseVlan(obj) &&
                  isUseMultiVlan(obj) &&
                  isUniqVlan(conn.data, obj)) ||
                result.push({
                  type: conn.type,
                  instance: conn.inst,
                });
            }),
            result
          );
        }

        function isUniqMedia(obj, elem, without) {
          return without && obj.MediaType == without
            ? !0
            : obj.MediaType != elem.MediaType
              ? !0
              : media.isUniqMedia(obj, elem)
                ? !0
                : !1;
        }

        function isUniqVlan(elem, obj) {
          var currentID = funcs.fetchBranch(elem, 'VLAN.ID'),
            compareID = funcs.fetchBranch(obj, 'VLAN.ID');
          return currentID != compareID;
        }

        function isUseVlan(conn) {
          return _.has(conn, 'VLAN');
        }

        function isUseMultiVlan(conn) {
          return 'DSL.ATM' != conn.MediaType;
        }
        var conns = [];
        switch (
          ('ipoeDual' == type
            ? ((conns = conns.concat(
                getConnections('ipv4oe', instance, !0, !0)
              )),
              (conns = conns.concat(
                getConnections('ipv6oe', instance, !0, !0)
              )))
            : (conns = getConnections(type, instance, !0, !0)),
          type)
        ) {
          case 'ipv4oe':
          case '3g':
          case 'lte':
          case 'bridge':
          case 'pppoa':
          case 'ipoa':
          case 'ipoeDual':
            return mediaAndVlanConflicts(conns, obj, type);
          case 'ipv6oe':
          case 'ipoeDual':
            return ipv6Conflicts(conns, obj);
          case 'pptp':
            return lowerLayerConflicts(conns, obj);
          default:
            return [];
        }
      }

      function getConnectionsByMedia(connection) {
        var result = [],
          allConns = flattenConnections();
        return (
          _.each(allConns, function(current) {
            media.isUniqMedia(connection, current.data) || result.push(current);
          }),
          result
        );
      }
      var dms = __webpack_require__(141).get().wan,
        _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        media = __webpack_require__(177),
        ppp = __webpack_require__(179),
        pppv6 = __webpack_require__(181),
        connections = {
          ipv4oa: __webpack_require__(182),
          ipv4oe: __webpack_require__(183),
          ipoeDual: __webpack_require__(184),
          ipv6oe: __webpack_require__(185),
          pppoe: ppp.pppoe,
          pppoa: ppp.pppoa,
          pptp: ppp.pptp,
          pppoev6: pppv6.pppoev6,
          pppoeDual: pppv6.pppoeDual,
          '3g': __webpack_require__(186),
          lte: __webpack_require__(187),
          bridge: __webpack_require__(188),
        },
        connectionsFuncs = {
          flattenConnections: flattenConnections,
          getIfaceConnections: getIfaceConnections,
          conflictsConnections: conflictsConnections,
          getConnectionsByMedia: getConnectionsByMedia,
        };
      module.exports = _.extend(connections, connectionsFuncs);
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = __webpack_require__(141).get().wan,
        atm = __webpack_require__(178);
      module.exports = (function() {
        function data() {
          return dms.data.Device.WAN.Media;
        }

        function flattenData() {
          var result = [],
            types = getTypes();
          return (
            _.each(types, function(type) {
              hasInterfaces(type) &&
                (result = result.concat(getInterfacesFlatten(type)));
            }),
            result
          );
        }

        function getTypes() {
          var types = [
            'Ethernet',
            'WiFi',
            'DSL.ATM',
            'DSL.PTM',
            'Bridging',
            'Dongle',
          ];
          return types;
        }

        function hasInterfaces(type) {
          return getInterfacesCount(type) > 0;
        }

        function getInterfaces(type) {
          var media = data();
          return funcs.fetchBranch(media, type + '.');
        }

        function getInterfacesFlatten(type) {
          var ifaces = getInterfaces(type),
            instanceKey = getInstanceKey(type);
          return _.map(ifaces[instanceKey], function(iface, instance) {
            return {
              data: iface,
              type: type,
              instance: instance,
            };
          });
        }

        function getInterfacesCount(type) {
          var interfaces = getInterfaces(type);
          if (_.isNull(interfaces)) return 0;
          var instKey = getInstanceKey(type);
          return interfaces[instKey + 'NumberOfEntries'];
        }

        function getInterface(type, inst) {
          var media = data(),
            instKey = getInstanceKey(type);
          return funcs.fetchBranch(
            media,
            type + '.' + instKey + '.' + inst + '.'
          );
        }

        function getInstanceKey(type) {
          var instKeyMap = {
            Ethernet: 'Interface',
            WiFi: 'Network',
            'DSL.ATM': 'Link',
            'DSL.PTM': 'Link',
            Dongle: 'Interface',
          };
          return instKeyMap[type] ? instKeyMap[type] : '';
        }

        function isUniqMedia(obj, elem) {
          if (elem.MediaType != obj.MediaType) return !0;
          switch (elem.MediaType) {
            case 'Ethernet':
              return elem.Media.Ethernet.Name != obj.Media.Ethernet.Name;
            case 'WiFi':
              return elem.Media.WiFi.SSID != obj.Media.WiFi.SSID;
            case 'DSL.ATM':
              return (
                elem.Media.DSL.ATM.LinkType != obj.Media.DSL.ATM.LinkType ||
                elem.Media.DSL.ATM.DestinationAddress !=
                  obj.Media.DSL.ATM.DestinationAddress
              );
            case 'DSL.PTM':
              return elem.Media.DSL.PTM.Name != obj.Media.DSL.PTM.Name;
            case 'Bridge':
              return elem.Media.Bridge.Name != obj.Media.Bridge.Name;
            case 'Dongle':
              return elem.Media.Dongle.Type != obj.Media.Dongle.Type;
            default:
              return !0;
          }
        }
        var media = {
          data: data,
          flattenData: flattenData,
          getTypes: getTypes,
          hasInterfaces: hasInterfaces,
          getInterfaces: getInterfaces,
          getInterfacesFlatten: getInterfacesFlatten,
          getInterfacesCount: getInterfacesCount,
          getInterface: getInterface,
          isUniqMedia: isUniqMedia,
          atm: atm,
        };
        return media;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = (__webpack_require__(5), __webpack_require__(3)),
        dms = __webpack_require__(141).get().wan;
      module.exports = (function() {
        function list() {
          return dms.data ? dms.data.Device.WAN.Media.DSL.ATM.Link : null;
        }

        function validation(obj) {
          function destAddrAlreadyUse(obj) {
            var used = getUseDestinationAddress(obj.LinkType);
            return _.contains(used, obj.DestinationAddress);
          }
          var errors = {
            DestinationAddress: [],
          };
          return (
            destAddrAlreadyUse(obj) &&
              errors.DestinationAddress.push(
                'error_destination_address_already_use'
              ),
            errors
          );
        }

        function getUniqDestinationAddress(linkType) {
          function findUniqVpi(vpiList) {
            var min = vpiList[0],
              max = vpiList[vpiList.length - 1];
            1 == vpiList.length && (min = '1');
            for (var i = min; max >= i; i++)
              if (!_.contains(vpiList, i)) return i.toString();
            return (max + 1).toString();
          }

          function getUseVpiList(linkType) {
            var used = getUseDestinationAddress(linkType);
            return _.map(used, function(value) {
              return parseInt(value.split('/')[0]);
            }).sort(function(a, b) {
              return a - b;
            });
          }
          var vpi = '0',
            vci = '35',
            vpiList = getUseVpiList(linkType);
          return (
            vpiList.length && (vpi = findUniqVpi(vpiList)), vpi + '/' + vci
          );
        }

        function getUseDestinationAddress(linkType) {
          var ifaces = list();
          return ifaces
            ? _.chain(ifaces)
                .map(function(elem) {
                  return elem.LinkType != linkType
                    ? null
                    : elem.DestinationAddress;
                })
                .compact()
                .value()
            : [];
        }
        var atm = {
          list: list,
          validation: validation,
          getUniqDestinationAddress: getUniqDestinationAddress,
        };
        return atm;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var connection = __webpack_require__(180),
        pppoe = {
          add: function(obj) {
            return connection.add(obj, 'PPPoE');
          },
          set: function(obj, inx) {
            return connection.set(obj, inx, 'PPPoE');
          },
          cut: function(inx) {
            return connection.cut(inx, 'PPPoE');
          },
          get: function(inx) {
            return connection.get(inx, 'PPPoE');
          },
          list: function() {
            return connection.list('PPPoE');
          },
        },
        pppoa = {
          add: function(obj) {
            return connection.add(obj, 'PPPoA');
          },
          set: function(obj, inx) {
            return connection.set(obj, inx, 'PPPoA');
          },
          cut: function(inx) {
            return connection.cut(inx, 'PPPoA');
          },
          get: function(inx) {
            return connection.get(inx, 'PPPoA');
          },
          list: function() {
            return connection.list('PPPoA');
          },
        },
        pptp = {
          add: function(obj) {
            return connection.add(obj, 'PPTP');
          },
          set: function(obj, inx) {
            return connection.set(obj, inx, 'PPTP');
          },
          cut: function(inx) {
            return connection.cut(inx, 'PPTP');
          },
          get: function(inx) {
            return connection.get(inx, 'PPTP');
          },
          list: function() {
            return connection.list('PPTP');
          },
        };
      module.exports = {
        pppoe: pppoe,
        pppoa: pppoa,
        pptp: pptp,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = (__webpack_require__(177), __webpack_require__(141).get().wan);
      module.exports = (function() {
        function list(type) {
          return dms.data.Device.WAN[type]
            ? dms.data.Device.WAN[type].Connection
            : {};
        }

        function add(obj, type) {
          var path = funcs.addInstance(
            dms.data.Device.WAN[type],
            'Connection',
            obj
          );
          return path.replace('Connection.', '');
        }

        function set(obj, inx, type) {
          var path = funcs.setInstance(
            dms.data.Device.WAN[type],
            'Connection.' + inx,
            obj
          );
          return path.replace('Connection.', '');
        }

        function cut(inx, type) {
          return funcs.cutInstance(
            dms.data.Device.WAN[type],
            'Connection.' + inx
          );
        }

        function get(inx, type) {
          return funcs.deepClone(
            funcs.fetchBranch(
              dms.data.Device.WAN[type],
              'Connection.' + inx + '.'
            )
          );
        }

        function select(params, without, type) {
          function containParams(elem, params) {
            return _.every(params, function(value, name) {
              return elem[name] == value;
            });
          }
          var conns = list(type);
          return _.filter(conns, function(elem) {
            return without && containParams(elem, without)
              ? !1
              : params && !containParams(elem, params)
                ? !1
                : !0;
          });
        }
        return {
          list: list,
          add: add,
          get: get,
          set: set,
          cut: cut,
          select: select,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var connection = (__webpack_require__(5),
        __webpack_require__(3),
        __webpack_require__(180)),
        pppoev6 = {
          add: function(obj) {
            return connection.add(obj, 'PPPoEv6');
          },
          set: function(obj, inx) {
            return connection.set(obj, inx, 'PPPoEv6');
          },
          cut: function(inx) {
            return connection.cut(inx, 'PPPoEv6');
          },
          get: function(inx) {
            return connection.get(inx, 'PPPoEv6');
          },
          list: function() {
            return connection.list('PPPoEv6');
          },
        },
        pppoeDual = {
          add: function(obj) {
            return connection.add(obj, 'PPPoEDual');
          },
          set: function(obj, inx) {
            return connection.set(obj, inx, 'PPPoEDual');
          },
          cut: function(inx) {
            return connection.cut(inx, 'PPPoEDual');
          },
          get: function(inx) {
            return connection.get(inx, 'PPPoEDual');
          },
          list: function() {
            return connection.list('PPPoEDual');
          },
        };
      module.exports = {
        pppoev6: pppoev6,
        pppoeDual: pppoeDual,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var connection = __webpack_require__(180);
      module.exports = {
        list: function() {
          return connection.list('IPv4oE');
        },
        add: function(obj) {
          return connection.add(obj, 'IPv4oE');
        },
        set: function(obj, inx) {
          return connection.set(obj, inx, 'IPv4oE');
        },
        get: function(inx) {
          return connection.get(inx, 'IPv4oE');
        },
        cut: function(inx) {
          return connection.cut(inx, 'IPv4oE');
        },
        select: function(params, without) {
          return connection.select(params, without, 'IPv4oE');
        },
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function validation(obj) {
        function dhsServersIsEqual(obj) {
          return (
            obj.DNSServer1 && obj.DNSServer2 && obj.DNSServer1 == obj.DNSServer2
          );
        }
        var errors = {
          DNSServer1: [],
          DNSServer2: [],
        };
        return (
          dhsServersIsEqual(obj) &&
            (errors.DNSServer1.push('error_dns_servers_is_equal'),
            errors.DNSServer2.push('error_dns_servers_is_equal')),
          errors
        );
      }
      var connection = (__webpack_require__(3), __webpack_require__(180));
      module.exports = {
        list: function() {
          return connection.list('IPv6oE');
        },
        add: function(obj) {
          return connection.add(obj, 'IPv6oE');
        },
        set: function(obj, inx) {
          return connection.set(obj, inx, 'IPv6oE');
        },
        cut: function(inx) {
          return connection.cut(inx, 'IPv6oE');
        },
        get: function(inx) {
          return connection.get(inx, 'IPv6oE');
        },
        select: function(params, without) {
          return connection.select(params, without, 'IPv6oE');
        },
        validation: validation,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var dms = __webpack_require__(141).get().wifi,
        funcs = __webpack_require__(5),
        WiFiAccessPoint = __webpack_require__(190),
        WiFiEndPoint = __webpack_require__(194),
        WiFiWPS = __webpack_require__(195),
        WiFiWMM = __webpack_require__(196),
        helper = __webpack_require__(76);
      module.exports = (function() {
        function isChange() {
          var status = dms.status();
          return status && !_.isEmpty(status);
        }

        function setClientInfo(value) {
          clientInfo = value;
        }

        function getBand(index, freq) {
          var radio = dms.data.Device.WiFi.Radio,
            found = [];
          freq && (bandFreq = freq);
          for (var i in radio)
            if (radio[i].OperatingFrequencyBand == bandFreq) {
              var obj = {
                radio: radio[i],
                ap: new WiFiAccessPoint(dms.data, dms.attrs, i, freq),
                wps: new WiFiWPS(dms.data, i),
              };
              '2.4GHz' == bandFreq &&
                (obj.wmm = new WiFiWMM(dms.data, dms.attrs, i)),
                found.push(obj);
            }
          return _.isUndefined(index) ? found : found[index];
        }

        function hasBand(freq) {
          var radio = dms.data.Device.WiFi.Radio;
          return _.some(radio, function(elem) {
            return elem.OperatingFrequencyBand == freq;
          });
        }

        function setBandFreq(freq) {
          bandFreq = freq;
        }

        function getBandFreq() {
          return bandFreq;
        }

        function getClient(band) {
          var index = band && '2.4GHz' != band ? 2 : 1;
          return new WiFiEndPoint(dms.data, index);
        }

        function getClientBands() {
          var ap = dms.data.Device.WiFi.Radio;
          return _.map(ap, function(elem) {
            return elem.OperatingFrequencyBand;
          });
        }

        function isSeparateClient() {
          var radio = dms.data.Device.WiFi.Radio[1],
            radio5G = dms.data.Device.WiFi.Radio[2];
          return (
            radio &&
            radio5G &&
            radio.EndPointNumberOfEntries > 0 &&
            radio5G.EndPointNumberOfEntries > 0
          );
        }

        function isRadioEnable(freq) {
          var radio = dms.data.Device.WiFi.Radio;
          return _.some(radio, function(elem) {
            return elem.OperatingFrequencyBand == freq && elem.Enable;
          });
        }

        function enableRadio(freq, cb) {
          var radio = getRadioData(freq);
          (radio.Enable = !0), wifi.push(cb);
        }

        function enableRadioBroadcast(freq, cb) {
          var radio = getRadioData(freq);
          (radio.AccessPoint[1].Broadcast = !0), wifi.push(cb);
        }

        function countries() {
          var CountriesList = dms.data.Device.WiFi.CountriesList;
          return CountriesList;
        }

        function scanList(band) {
          if (!dms.scanData || !dms.scanData.Device.WiFi.ScanList) return [];
          var result = _.toArray(dms.scanData.Device.WiFi.ScanList);
          return (
            band &&
              (result = _.filter(result, function(elem) {
                return elem.Band == band;
              })),
            result
          );
        }

        function supportedParam(param) {
          var band = getBand(0);
          if (band && band.radio) {
            var radio = band.radio;
            return _.has(radio, param);
          }
        }

        function getRadioAttrs() {
          var result = funcs.fetchBranch(dms.attrs, 'Device.WiFi.Radio.');
          return result;
        }

        function getRadioData(freq) {
          var radio = dms.data.Device.WiFi.Radio;
          return _.find(radio, function(elem) {
            return elem.OperatingFrequencyBand == freq;
          });
        }

        function getWDSData() {
          return dms.data.Device.WiFi.WDS;
        }

        function checkDeviceLoss() {
          function getCurrentAPPath(init, client) {
            var radioInst,
              apInst,
              radio = funcs.fetchBranch(init, 'Device.WiFi.Radio.');
            return (
              _.each(radio, function(elem, inst1) {
                isCurrentBand(elem.OperatingFrequencyBand, client.band) &&
                  ((radioInst = inst1),
                  _.each(elem.AccessPoint, function(ap, inst2) {
                    ap.SSID == client.SSID && (apInst = inst2);
                  }));
              }),
              radioInst && apInst
                ? 'Device.WiFi.Radio.' +
                  radioInst +
                  '.AccessPoint.' +
                  apInst +
                  '.'
                : ''
            );
          }

          function getAPParams(path, data) {
            var result = {},
              ap = funcs.fetchBranch(data, path);
            switch (
              ((result.SSID = ap.SSID),
              (result.ModeEnabled = wifi.helper.getModeName(
                ap.Security.ModeEnabled,
                ap.OperatingStandards
              )),
              ap.Security.ModeEnabled)
            ) {
              case 'WPA-Personal':
              case 'WPA2-Personal':
              case 'WPA-WPA2-Personal':
                result.PreSharedKey = ap.Security.PreSharedKey;
                break;
              case 'WEP-64':
              case 'WEP-128':
                _.each([1, 2, 3, 4], function(value) {
                  result['WEPKey' + value] = ap.Security['WEPKey' + value];
                });
            }
            return result;
          }

          function isCheckDeviceLoss() {
            return clientInfo && 'WLAN' == clientInfo.name;
          }

          function isCurrentBand(band1, band2) {
            return parseFloat(band1) == parseFloat(band2);
          }
          var result = {
            loss: !1,
            reason: [],
            params: {},
          };
          if (!isCheckDeviceLoss()) return result;
          var init = dms.getInitData(),
            data = dms.data,
            changes = dms.status(),
            apPath = getCurrentAPPath(init, clientInfo);
          if (!apPath) return result;
          var changeParamsList = funcs.splitTree(changes);
          return (
            _.each(changeParamsList, function(obj) {
              var reAP = new RegExp(apPath),
                reParams = [
                  {
                    name: 'ssid',
                    value: [/SSID/],
                  },
                  {
                    name: 'security_mode',
                    value: [/ModeEnabled/],
                  },
                  {
                    name: 'security_encryption',
                    value: [/PreSharedKey/, /WEPKey*/],
                  },
                ],
                name = obj.Name;
              obj.Value,
                _.last(name.split('.')),
                reAP.test(name) &&
                  (_.each(reParams, function(elem) {
                    _.each(elem.value, function(reParam) {
                      reParam.test(name) &&
                        ((result.loss = !0), result.reason.push(elem.name));
                    });
                  }),
                  result.loss &&
                    (result.params = _.extend(
                      result.params,
                      getAPParams(apPath, data)
                    )));
            }),
            result
          );
        }
        var bandFreq = null,
          clientInfo = null,
          wifi = {
            data: dms.data,
            scanData: dms.scanData,
            pull: dms.pull,
            pullCommon: dms.pullCommon,
            pullAdv: dms.pullAdv,
            pullWMM: dms.pullWMM,
            pullWDS: dms.pullWDS,
            pullClient: dms.pullClient,
            getChannels: dms.getChannels,
            setClientInfo: setClientInfo,
            updateScan: dms.updateScan,
            push: dms.push,
            isChange: isChange,
            hasBand: hasBand,
            getBand: getBand,
            getBandFreq: getBandFreq,
            setBandFreq: setBandFreq,
            getClient: getClient,
            getClientBands: getClientBands,
            getWDSData: getWDSData,
            getRadioAttrs: getRadioAttrs,
            isSeparateClient: isSeparateClient,
            isRadioEnable: isRadioEnable,
            enableRadio: enableRadio,
            enableRadioBroadcast: enableRadioBroadcast,
            countries: countries,
            scanList: scanList,
            supportedParam: supportedParam,
            checkDeviceLoss: checkDeviceLoss,
            helper: helper,
          };
        return wifi;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        somovd = __webpack_require__(191),
        dsysinit = __webpack_require__(193);
      module.exports = _.size(somovd) ? somovd : dsysinit;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        WiFiAccessPoint = __webpack_require__(192);
      module.exports = function(data, attrs, radioInx) {
        function getDefault() {
          var _this = this,
            baseAP = this.getBase(),
            obj = {
              SSID: this.getSSID(data.Device.WiFi.Radio[radioInx]),
              Broadcast: !0,
              SSIDAdvertisementEnabled: !1,
              MaxAssociatedDevices: 0,
              ClientIsolation: !1,
              BandwidthRestricted: 0,
              Security: {
                ModesSupported: baseAP.Security.ModesSupported,
                ModeEnabled: 'WPA2-Personal',
                EncryptionType: 'AES',
                OpenWEP: !1,
                OpenWEPType: 'WEP-64',
                WEPKey1: '',
                WEPKey1Type: '1',
                WEPKey2: '',
                WEPKey2Type: '1',
                WEPKey3: '',
                WEPKey3Type: '1',
                WEPKey4: '',
                WEPKey4Type: '1',
                PreSharedKey: funcs.randomString(8),
                DefaultKeyID: '1',
                RekeyingInterval: 3600,
                RadiusServerIPAddr: '192.168.0.254',
                RadiusServerPort: 1812,
                RadiusSecret: 'dlink',
              },
            };
          return (
            (obj = _.pick(obj, function(value, key) {
              return _this.supportedParam(key);
            })),
            (obj.Security = _.pick(obj.Security, function(value, key) {
              return _this.supportedParam(key, 'Security.');
            })),
            obj
          );
        }
        var wifiAP = new WiFiAccessPoint(data, attrs, radioInx);
        return (
          (wifiAP.getDefault = function() {
            return getDefault.call(this);
          }),
          wifiAP
        );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function WiFiAccessPoint(data, attrs, radioInx) {
        function getSSID(radio) {
          var res,
            ssid = radio.AccessPoint[1].SSID,
            inx = _.size(radio.AccessPoint);
          do {
            inx++;
            var resFind = _.find(radio.AccessPoint, function(elem) {
              return elem.SSID == ssid + '.' + inx;
            });
            res = resFind ? !1 : !0;
          } while (0 == res);
          return (ssid = ssid + '.' + inx);
        }
        return {
          get: function(inx) {
            return data.Device.WiFi.Radio[radioInx].AccessPoint[inx];
          },
          getBase: function() {
            return data.Device.WiFi.Radio[radioInx].AccessPoint[1];
          },
          getSSID: getSSID,
          set: function(obj, inx) {
            var path = funcs.setInstance(
              data.Device.WiFi.Radio[radioInx],
              'AccessPoint.' + inx,
              obj
            );
            return path.replace('AccessPoint.', '');
          },
          cut: function(inx) {
            return funcs.cutInstance(
              data.Device.WiFi.Radio[radioInx],
              'AccessPoint.' + inx
            );
          },
          list: function() {
            return data.Device.WiFi.Radio[radioInx].AccessPoint;
          },
          add: function(obj) {
            var path = funcs.addInstance(
              data.Device.WiFi.Radio[radioInx],
              'AccessPoint',
              obj
            );
            return path.replace('AccessPoint.', '');
          },
          conflicts: function(obj) {
            var list = this.list();
            return _.filter(_.keys(list), function(key) {
              var elem = list[key];
              return elem.SSID == obj.SSID ? !0 : void 0;
            });
          },
          supportedParam: function(param, root) {
            var base = this.getBase(),
              obj = root ? funcs.fetchBranch(base, root) : base;
            return _.has(obj, param);
          },
        };
      }
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      module.exports = WiFiAccessPoint;
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function WiFiEndPoint(data, radioInx) {
        var epInx = '1';
        return {
          getBase: function() {
            return data.Device.WiFi.Radio[radioInx].EndPoint[epInx];
          },
          list: function() {
            return data.Device.WiFi.Radio[radioInx].EndPoint;
          },
          conflicts: function(obj) {
            var list = this.list();
            return _.filter(_.keys(list), function(key) {
              var elem = list[key];
              return elem.SSID == obj.SSID ? !0 : void 0;
            });
          },
        };
      }
      var _ = (__webpack_require__(5), __webpack_require__(3));
      module.exports = WiFiEndPoint;
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function WiFiWPS(data, radioInx) {
        var radio = data.Device.WiFi.Radio[radioInx],
          ap = data.Device.WiFi.Radio[radioInx].AccessPoint[1],
          sec = ap.Security,
          wps = ap.WPS;
        return {
          data: wps,
          getConnectMethod: function() {
            return wps.PIN ? 'PIN' : 'PBC';
          },
          getInfo: function() {
            var info = {};
            return (
              _.has(wps, 'Configured') &&
                (info.state = wps.Configured
                  ? 'wifiWPSConfigured'
                  : 'wifiWPSNotConfigured'),
              _.has(wps, 'DefaultPIN') && (info.defpin = wps.DefaultPIN),
              _.has(wps, 'DevicePIN') && (info.devpin = wps.DevicePIN),
              _.has(wps, 'ClientPIN') && (info.clipin = wps.ClientPIN),
              _.has(ap, 'SSID') && (info.ssid = ap.SSID),
              _.has(sec, 'ModeEnabled') &&
                (info.mode = helper.getModeName(sec.ModeEnabled)),
              _.has(sec, 'EncryptionType') && (info.encr = sec.EncryptionType),
              _.has(sec, 'PreSharedKey') &&
                'None' != sec.ModeEnabled &&
                (info.psk = sec.PreSharedKey),
              info
            );
          },
          connect: function(cb) {
            'PIN' != wps.Method && delete wps.PIN, cb && cb();
          },
          reset: function(cb) {
            (wps.Configured = !1), cb && cb();
          },
          warnings: function() {
            var result = [];
            return (
              radio.Enable || result.push('radioDisable'),
              _.has(ap, 'Broadcast') &&
                !ap.Broadcast &&
                result.push('broadcastDisable'),
              wps.Check || result.push('unallowableMode'),
              result
            );
          },
        };
      }
      var _ = (__webpack_require__(5), __webpack_require__(3)),
        helper = __webpack_require__(76);
      module.exports = WiFiWPS;
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function WiFiWMM(data, attrs, radioInx) {
        function getRestriction(type, ac) {
          function getRestrict(cwmin, cwmax) {
            return {
              ECWMin: cwmin,
              ECWMax: cwmax,
            };
          }

          function getAIFSRangeAttrs(wmmAttrs) {
            var range = getAIFSRangeDefault(),
              minMax = funcs.newConfig.makeMinMaxModel(wmmAttrs);
            return (
              _.has(minMax.AIFSN, 'min') && (range.min = minMax.AIFSN.min),
              _.has(minMax.AIFSN, 'max') && (range.max = minMax.AIFSN.max + 1),
              prepareAIFSRange(range)
            );
          }

          function getAIFSRangeDefault() {
            return {
              min: 1,
              max: 16,
            };
          }

          function prepareAIFSRange(range) {
            return _.range(range.min, range.max);
          }

          function getTxOpMaxMinMaxAttrs(wmmAttrs) {
            var range = getTxOpMaxMinMaxDefault(),
              minMax = funcs.newConfig.makeMinMaxModel(wmmAttrs);
            return (
              _.has(minMax.TxOpMax, 'min') && (range.min = minMax.TxOpMax.min),
              _.has(minMax.TxOpMax, 'max') && (range.max = minMax.TxOpMax.max),
              range
            );
          }

          function getTxOpMaxMinMaxDefault() {
            return {
              min: 0,
              max: 9999,
            };
          }

          function getWMMAttrs(type, ac) {
            function getWMMAPAttrs() {
              return funcs.fetchBranch(attrs, 'Device.WiFi.Radio.WMM.AP.AC.');
            }

            function getWMMEPAttrs() {
              return funcs.fetchBranch(attrs, 'Device.WiFi.Radio.WMM.EP.AC.');
            }
            if (!attrs) return null;
            var wmmAttrs = 'ap' == type ? getWMMAPAttrs() : getWMMEPAttrs();
            return wmmAttrs && wmmAttrs[ac] ? wmmAttrs[ac] : null;
          }
          var wmmAttrs = getWMMAttrs(type, ac);
          return {
            ap: {
              BK: getRestrict(5, 10),
              BE: getRestrict(4, 6),
              VI: getRestrict(3, 4),
              VO: getRestrict(2, 3),
            },
            ep: {
              BK: getRestrict(4, 10),
              BE: getRestrict(4, 10),
              VI: getRestrict(3, 4),
              VO: getRestrict(2, 3),
            },
            AIFSN: wmmAttrs
              ? getAIFSRangeAttrs(wmmAttrs)
              : prepareAIFSRange(getAIFSRangeDefault()),
            TxOpMax: wmmAttrs
              ? getTxOpMaxMinMaxAttrs(wmmAttrs)
              : getTxOpMaxMinMaxDefault(),
          };
        }

        function hasSupportMode() {
          return _.has(data.settings, 'Mode');
        }
        var radio = data.Device.WiFi.Radio[radioInx];
        if (!radio.WMM) return {};
        var wmm = radio.WMM,
          ap = wmm.AP[1].AC,
          ep = wmm.EP[1].AC,
          data = {
            settings: wmm,
            ap: ap,
            ep: ep,
          };
        return {
          data: data,
          get: function(type, inst) {
            return data[type][inst];
          },
          getRestriction: getRestriction,
          hasSupportMode: hasSupportMode,
        };
      }
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      module.exports = WiFiWMM;
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function isChanged() {
        var path,
          changes = status();
        for (path in changes)
          if (!path.indexOf('Device.WiFiMACFilter')) return !0;
        return !1;
      }

      function status() {
        return dms.data
          ? _.extend(
              funcs.getChanges(dms.data, dms.__initialData),
              funcs.getChanges(dms.__initialData, dms.data)
            )
          : {};
      }

      function data() {
        return dms.data ? dms.data.Device.WiFiMACFilter : {};
      }
      var dms = __webpack_require__(141).get().wifiMacFilter,
        funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      (module.exports = {
        pull: dms.pull,
        push: dms.push,
        status: status,
        isChanged: isChanged,
        data: data,
        cut: function(inx) {
          return funcs.cutInstance(
            dms.data.Device.WiFiMACFilter,
            'Rules.' + inx
          );
        },
        set: function(inx, obj) {
          return funcs.setInstance(
            dms.data.Device.WiFiMACFilter,
            'Rules.' + inx,
            obj
          );
        },
        add: function(obj) {
          return funcs.addInstance(dms.data.Device.WiFiMACFilter, 'Rules', obj);
        },
      }),
        (dms.isChanged = isChanged),
        (dms.status = status);
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var dms = __webpack_require__(141).get().wifiShaping;
      __webpack_require__(5),
        __webpack_require__(3),
        (module.exports = {
          pull: dms.pull,
          push: dms.push,
          getData: dms.getData,
          wasModified: dms.wasModified,
        });
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5),
        _ = __webpack_require__(3),
        dms = __webpack_require__(141).get().lan,
        ipv4 = __webpack_require__(200),
        ipv6 = __webpack_require__(205);
      module.exports = (function() {
        function pull(cb, constants) {
          return dms.pull(cb, constants);
        }

        function push(cb, constants) {
          return dms.push(cb, constants);
        }

        function remove(inx, cb) {
          return dms.remove(inx, cb);
        }

        function data() {
          return _.isNull(dms.data) ? {} : dms.data.Device.LAN;
        }

        function supported() {
          return dms.supported ? dms.supported() : function() {};
        }

        function constraints() {
          return dms.constraints ? dms.constraints() : {};
        }

        function isChange() {
          return !_.isEmpty(dms.status());
        }

        function cleanData() {
          dms.data = null;
        }

        function getInterface() {
          function init() {
            var interfaces = list();
            initInterfaces = funcs.deepClone(interfaces);
            var inst = _.keys(interfaces)[0];
            change(inst);
          }

          function clean() {
            (current = null), (initInterfaces = null);
          }

          function list() {
            return lan.data();
          }

          function listNew() {
            var interfaces = funcs.deepClone(lan.data());
            return (
              _.each(interfaces, function(iface, key) {
                iface.__isNewInterface || delete interfaces[key];
              }),
              interfaces
            );
          }

          function getData(inst) {
            var interfaces = list();
            return interfaces ? interfaces[inst] : null;
          }

          function setData(data, inst) {
            var interfaces = list();
            interfaces[inst] = funcs.deepClone(data);
          }

          function getCurrent() {
            return current;
          }

          function getNotices() {
            var notices = [];
            return (
              _.each(current, function(elem) {
                if (elem && elem.notification) {
                  var list = elem.notification.list();
                  _.each(list, function(name) {
                    var notice = elem.notification.get(name);
                    notice.check() &&
                      notices.push({
                        name: name,
                        notice: notice,
                      });
                  });
                }
              }),
              notices
            );
          }

          function change(inst, isSetCurrentData) {
            if (isSetCurrentData) {
              var oldIface = funcs.deepClone(
                  _.omit(current.data, '__l2Key', '__vlanName')
                ),
                newIface = getData(inst),
                iface = funcs.deepExtend(newIface, oldIface);
              resetInstanceToInit(current.instance);
            } else var iface = getData(inst);
            current = {
              data: iface,
              instance: inst,
              ipv4:
                'undefined' != typeof ipv4 && _.has(iface, 'IPv4')
                  ? ipv4(iface)
                  : dummy(),
              ipv6:
                'undefined' != typeof ipv6 && _.has(iface, 'IPv6')
                  ? ipv6(iface)
                  : dummy(),
            };
          }

          function has(inst) {
            var interfaces = list();
            return interfaces && _.has(interfaces, inst);
          }

          function resetInstanceToInit(inst) {
            setData(funcs.deepClone(initInterfaces[inst]), inst);
          }

          function dummy() {
            return {};
          }
          var current = null,
            initInterfaces = null;
          return {
            init: init,
            clean: clean,
            list: list,
            listNew: listNew,
            getCurrent: getCurrent,
            getNotices: getNotices,
            change: change,
            has: has,
          };
        }

        function getIfaceConnections(iface) {
          var lan = dms.data.Device.LAN,
            names = [];
          return (
            _.each(lan, function(connection) {
              connection.__l3Key === iface && names.push(connection.Name);
            }),
            names
          );
        }
        var lan = {
          pull: pull,
          push: push,
          remove: remove,
          data: data,
          supported: supported,
          constraints: constraints,
          isChange: isChange,
          clean: cleanData,
          interface: getInterface(),
          getIfaceConnections: getIfaceConnections,
        };
        return lan;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var Notification = (__webpack_require__(5),
        __webpack_require__(3),
        __webpack_require__(201)),
        ipv4StaticIP = __webpack_require__(202),
        ipv4DHCP = __webpack_require__(203);
      module.exports = function(iface) {
        function data() {
          return ipv4;
        }
        var ipv4 = iface.IPv4,
          staticIP = ipv4StaticIP(ipv4),
          dhcp = ipv4DHCP(ipv4),
          notification = new Notification();
        return (
          notification.add({
            name: 'dhcp_is_incorrect_pool',
            check: {
              fn: dhcp.isIncorrectPool,
              context: dhcp,
            },
            correct: {
              fn: dhcp.changePool,
              context: dhcp,
            },
            params: {
              fn: function() {
                return {
                  ranges: staticIP.getRanges(),
                };
              },
            },
          }),
          {
            data: data,
            staticIP: staticIP,
            dhcp: dhcp,
            notification: notification,
          }
        );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3);
      module.exports = (function() {
        function Notification() {
          function list() {
            return _.keys(listeners);
          }

          function add(options) {
            options.name && (listeners[options.name] = new Notice(options));
          }

          function get(name) {
            return listeners[name] ? listeners[name] : null;
          }

          function remove(name) {
            delete listeners[name];
          }

          function cleanAll(name) {
            _.each(listeners, function(elem, name) {
              remove(name);
            });
          }
          var listeners = {};
          return {
            list: list,
            add: add,
            get: get,
            remove: remove,
            cleanAll: cleanAll,
          };
        }

        function Notice(options) {
          function check() {
            return callOption('check', arguments);
          }

          function correct() {
            return callOption('correct', arguments);
          }

          function params() {
            return callOption('params', arguments);
          }

          function callOption(name, args) {
            var option = options[name];
            if (option) {
              var fn = option.fn,
                args = Array.prototype.slice.call(args, 0),
                context = option.context || null;
              return fn.apply(context, args);
            }
          }
          return {
            check: check,
            correct: correct,
            params: params,
          };
        }
        return Notification;
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.ipv4 = __webpack_require__(74)),
        (funcs.is = __webpack_require__(73));
      var _ = __webpack_require__(3);
      module.exports = function(ipv4) {
        function get(inx) {
          return _.has(staticIP, inx) ? staticIP[inx] : null;
        }

        function set(elem, inx) {
          staticIP[inx] = elem;
        }

        function list() {
          return _.isUndefined(staticIP) ? null : staticIP;
        }

        function conflicts(inx) {
          function isIncorrectSubnet(address, mask) {
            return !funcs.is.ipv4(address) || !funcs.is.mask(mask);
          }
          if (!inx) return [];
          var addresses = list(),
            current = get(inx),
            result = [];
          return isIncorrectSubnet(current.Address, current.SubnetMask)
            ? result
            : (_.each(addresses, function(elem, index) {
                if (
                  index != inx &&
                  !isIncorrectSubnet(elem.Address, elem.SubnetMask)
                ) {
                  var network = funcs.ipv4.subnet.getNetworkRange(
                    elem.Address,
                    elem.SubnetMask
                  );
                  funcs.ipv4.subnet.belongNetworkRange(
                    network,
                    current.Address
                  ) && result.push(index);
                }
              }),
              result);
        }

        function validation(elem, dhcpOffFlag) {
          function isInvalidGW(gw) {
            return !gw || !funcs.is.ipv4(gw);
          }

          function isInvalidIP(addr) {
            return addr && !funcs.is.ipv4(addr);
          }

          function isInvalidMask(msk) {
            return msk && !funcs.is.mask(msk);
          }

          function isReserved(addr, msk) {
            return funcs.ipv4.subnet.checkReserved(addr, msk);
          }

          function isHostsLessMin(hosts) {
            return !_.isNull(options.minHosts) && hosts < options.minHosts;
          }

          function isHostsLessMinDhcpOff(hosts) {
            return (
              !_.isNull(options.minHostsDhcpOff) &&
              hosts < options.minHostsDhcpOff
            );
          }

          function isHostsMoreMax(hosts) {
            return !_.isNull(options.maxHosts) && hosts > options.maxHosts;
          }
          var errors = {
              Address: [],
              SubnetMask: [],
              GatewayAddress: [],
            },
            addr = elem.Address,
            msk = elem.SubnetMask,
            gw = elem.GatewayAddress;
          if (
            (isInvalidIP(addr) && errors.Address.push('invalid_ipv4'),
            isInvalidMask(msk) && errors.SubnetMask.push('invalid_maskv4'),
            !isInvalidIP(addr) && !isInvalidMask(msk))
          ) {
            var hosts = funcs.ipv4.mask.hosts(msk);
            if (
              (isReserved(addr, msk) &&
                errors.Address.push('error_ip_is_reserved'),
              (dhcpOffFlag
                ? isHostsLessMinDhcpOff(hosts)
                : isHostsLessMin(hosts)) &&
                errors.SubnetMask.push('error_subnet_hosts_less_min'),
              isHostsMoreMax(hosts) &&
                errors.SubnetMask.push('error_subnet_hosts_more_max'),
              !isInvalidGW(gw))
            ) {
              var network = funcs.ipv4.subnet.getNetworkRange(
                elem.Address,
                elem.SubnetMask
              );
              funcs.ipv4.subnet.belongNetworkRange(network, gw) ||
                errors.GatewayAddress.push('error_gateway_not_belong_subnets'),
                0 == funcs.ipv4.address.compare(addr, gw) &&
                  (errors.Address.push('error_gateway_ip_address_reserved'),
                  errors.GatewayAddress.push(
                    'error_gateway_ip_address_reserved'
                  ));
            }
          }
          return errors;
        }

        function getRanges() {
          function isValidList(addressesList) {
            return _.every(addressesList, function(elem) {
              var errors = validation(elem);
              return (
                0 == errors.Address.length && 0 == errors.SubnetMask.length
              );
            });
          }

          function filterRanges(network, addr1, addr2) {
            var compareAddresses = funcs.ipv4.address.compare(addr1, addr2);
            switch (compareAddresses) {
              case 1:
                var ranges1 = funcs.ipv4.subnet.splitNetworkRange(
                    network,
                    addr2
                  ),
                  ranges2 = funcs.ipv4.subnet.splitNetworkRange(network, addr1);
                if (_.isUndefined(ranges1[1])) {
                  var range = {
                    start: ranges1[0].start,
                    end: ranges2[0].end,
                  };
                  result = result.concat(range);
                } else {
                  result = result.concat(ranges1[0]);
                  var range = {
                    start: ranges1[1].start,
                    end: ranges2[0].end,
                  };
                  result = result.concat(range);
                }
                _.isUndefined(ranges2[1]) ||
                  (result = result.concat(ranges2[1]));
                break;
              case -1:
                var ranges1 = funcs.ipv4.subnet.splitNetworkRange(
                    network,
                    addr1
                  ),
                  ranges2 = funcs.ipv4.subnet.splitNetworkRange(network, addr2);
                if (_.isUndefined(ranges1[1])) {
                  var range = {
                    start: ranges1[0].start,
                    end: ranges2[0].end,
                  };
                  result = result.concat(range);
                } else {
                  result = result.concat(ranges1[0]);
                  var range = {
                    start: ranges1[1].start,
                    end: ranges2[0].end,
                  };
                  result = result.concat(range);
                }
                _.isUndefined(ranges2[1]) ||
                  (result = result.concat(ranges2[1]));
            }
          }
          var result = [],
            addressesList = list();
          return isValidList(addressesList)
            ? (_.each(addressesList, function(elem) {
                var network = funcs.ipv4.subnet.getNetworkRange(
                  elem.Address,
                  elem.SubnetMask
                );
                if (!_.isUndefined(elem.GatewayAddress) && elem.GatewayAddress)
                  filterRanges(network, elem.Address, elem.GatewayAddress);
                else {
                  var ranges = funcs.ipv4.subnet.splitNetworkRange(
                    network,
                    elem.Address
                  );
                  result = result.concat(ranges);
                }
              }),
              _.filter(result, function(elem) {
                return -1 == funcs.ipv4.address.compare(elem.start, elem.end);
              }))
            : result;
        }

        function outOfRanges(addr) {
          var ranges = getRanges();
          return ranges.length
            ? !_.some(ranges, function(range) {
                return funcs.ipv4.subnet.belongNetworkRange(range, addr);
              })
            : !1;
        }

        function getSubnet() {
          function isValidList(addressesList) {
            return _.every(addressesList, function(elem) {
              var errors = validation(elem);
              return (
                0 == errors.Address.length && 0 == errors.SubnetMask.length
              );
            });
          }
          var result = [],
            addressesList = list();
          return isValidList(addressesList)
            ? (_.each(addressesList, function(elem) {
                var network = funcs.ipv4.subnet.getNetwork(
                  elem.Address,
                  elem.SubnetMask
                );
                result.push(network);
              }),
              result)
            : result;
        }

        function isBelongDifferentRanges(addrs) {
          function isBelong(net, addrs) {
            return _.every(addrs, function(addr) {
              return funcs.ipv4.subnet.belongNetwork(net.net, addr, net.mask);
            });
          }
          var subnet = getSubnet();
          return subnet.length
            ? !_.some(subnet, function(net) {
                return isBelong(net, addrs);
              })
            : !1;
        }

        function isAddressBelongNetworkRange(range) {
          var addressesList = list();
          return _.some(addressesList, function(elem) {
            return funcs.ipv4.subnet.belongNetworkRange(range, elem.Address);
          });
        }

        function isGatewayBelongNetworkRange(range) {
          var addressesList = list();
          return _.some(addressesList, function(elem) {
            return !_.isUndefined(elem.GatewayAddress) && elem.GatewayAddress
              ? funcs.ipv4.subnet.belongNetworkRange(range, elem.GatewayAddress)
              : void 0;
          });
        }

        function isReserved(addr) {
          var addressesList = list();
          return _.some(addressesList, function(elem) {
            return funcs.ipv4.subnet.checkReserved(addr, elem.SubnetMask);
          });
        }

        function getOptions() {
          return options;
        }

        function setOptions(data) {
          options = _.extend(options, data);
        }
        var staticIP = ipv4.StaticIP,
          options = {
            minHosts: 4,
            maxHosts: 16777214,
            minHostsDhcpOff: 2,
          };
        return {
          get: get,
          set: set,
          list: list,
          conflicts: conflicts,
          validation: validation,
          getRanges: getRanges,
          outOfRanges: outOfRanges,
          isBelongDifferentRanges: isBelongDifferentRanges,
          getOptions: getOptions,
          setOptions: setOptions,
          isAddressBelongNetworkRange: isAddressBelongNetworkRange,
          isGatewayBelongNetworkRange: isGatewayBelongNetworkRange,
          isReserved: isReserved,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.ipv4 = __webpack_require__(74)),
        (funcs.is = __webpack_require__(73)),
        (_ = __webpack_require__(3));
      var moduleStatipIP = __webpack_require__(202),
        moduleDhcpStaticAddress = __webpack_require__(204);
      module.exports = function(ipv4) {
        function data() {
          return dhcp;
        }

        function validation() {
          var errors = {
              MinAddress: [],
              MaxAddress: [],
            },
            minAddress = dhcp.Server.MinAddress,
            maxAddress = dhcp.Server.MaxAddress;
          if (
            (minAddress || errors.MinAddress.push('input_is_empty'),
            maxAddress || errors.MaxAddress.push('input_is_empty'),
            minAddress &&
              !funcs.is.ipv4(minAddress) &&
              errors.MinAddress.push('invalid_ipv4'),
            maxAddress &&
              !funcs.is.ipv4(maxAddress) &&
              errors.MaxAddress.push('invalid_ipv4'),
            minAddress &&
              funcs.is.ipv4(minAddress) &&
              maxAddress &&
              funcs.is.ipv4(maxAddress))
          ) {
            var compareAddresses = funcs.ipv4.address.compare(
              minAddress,
              maxAddress
            );
            switch (compareAddresses) {
              case 1:
                errors.MinAddress.push('error_dhcp_start_ip_more_stop_ip'),
                  errors.MaxAddress.push('error_dhcp_stop_ip_less_start_ip');
                break;
              case 0:
                errors.MinAddress.push('error_dhcp_start_ip_equal_stop_ip'),
                  errors.MaxAddress.push('error_dhcp_start_ip_equal_stop_ip');
            }
            staticIP.isBelongDifferentRanges([minAddress, maxAddress]) &&
              (errors.MinAddress.push(
                'error_dhcp_start_ip_and_stop_ip_belong_different_ip_ranges'
              ),
              errors.MaxAddress.push(
                'error_dhcp_start_ip_and_stop_ip_belong_different_ip_ranges'
              )),
              staticIP.isReserved(minAddress) &&
                errors.MinAddress.push('error_ip_is_reserved'),
              staticIP.isReserved(maxAddress) &&
                errors.MaxAddress.push('error_ip_is_reserved'),
              staticIP.isAddressBelongNetworkRange({
                start: minAddress,
                end: maxAddress,
              }) &&
                (errors.MinAddress.push(
                  'error_lan_ip_address_is_in_dhcp_range'
                ),
                errors.MaxAddress.push(
                  'error_lan_ip_address_is_in_dhcp_range'
                )),
              staticIP.isGatewayBelongNetworkRange({
                start: minAddress,
                end: maxAddress,
              }) &&
                (errors.MinAddress.push('error_gw_ip_address_is_in_dhcp_range'),
                errors.MaxAddress.push('error_gw_ip_address_is_in_dhcp_range')),
              staticIP.outOfRanges(minAddress) &&
                errors.MinAddress.push('error_dhcp_start_ip_out_of_ranges'),
              staticIP.outOfRanges(maxAddress) &&
                errors.MaxAddress.push('error_dhcp_stop_ip_out_of_ranges');
          }
          return errors;
        }

        function changePool(obj) {
          obj.start &&
            funcs.is.ipv4(obj.start) &&
            obj.end &&
            funcs.is.ipv4(obj.end) &&
            ((dhcp.Server.MinAddress = obj.start),
            (dhcp.Server.MaxAddress = obj.end));
        }

        function isIncorrectPool() {
          if ('Server' != data().Mode) return !1;
          var error = validation();
          return error.MinAddress.length || error.MaxAddress.length;
        }
        var dhcp = ipv4.DHCP || {},
          staticIP = _.isUndefined(ipv4.staticIP)
            ? moduleStatipIP(ipv4)
            : ipv4.staticIP,
          dhcpStaticAddress = moduleDhcpStaticAddress(dhcp);
        return {
          data: data,
          validation: validation,
          changePool: changePool,
          isIncorrectPool: isIncorrectPool,
          staticAddress: dhcpStaticAddress,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.is = __webpack_require__(73)),
        (funcs.ipv4 = __webpack_require__(74));
      var _ = __webpack_require__(3);
      module.exports = function(dhcp) {
        function list() {
          return dhcpServer.StaticAddress;
        }

        function mode() {
          return dhcp.Mode;
        }

        function add(elem) {
          var path = funcs.addInstance(dhcpServer, 'StaticAddress', elem);
          return path.replace('StaticAddress.', '');
        }

        function set(elem, inx) {
          var path = funcs.setInstance(
            dhcpServer,
            'StaticAddress.' + inx,
            elem
          );
          return path.replace('StaticAddress.', '');
        }

        function cut(inx) {
          return funcs.cutInstance(dhcpServer, 'StaticAddress.' + inx);
        }

        function remove(inx) {
          var elem = _.clone(dhcpServer.StaticAddress[inx]);
          delete dhcpServer.StaticAddress[inx];
          var toAdd = dhcpServer.__toAdd.split(','),
            toAddIndex = _.indexOf(toAdd, 'StaticAddress.' + inx);
          return (
            -1 != toAddIndex && toAdd.splice(toAddIndex, 1),
            toAdd.length
              ? (dhcpServer.__toAdd = toAdd.join(','))
              : delete dhcpServer.__toAdd,
            elem
          );
        }

        function validation(elem) {
          function isHostname(hostname) {
            var re = /^([a-zA-Z0-9]{1})+([a-zA-Z0-9-])+([a-zA-Z0-9]{1})+$/;
            return re.test(hostname);
          }
          var errors = {
              IPAddress: [],
              MACAddress: [],
              Hostname: [],
            },
            ipAddress = elem.IPAddress,
            macAddress = elem.MACAddress,
            hostname = elem.Hostname;
          return (
            ipAddress &&
              !funcs.is.ipv4(ipAddress) &&
              errors.IPAddress.push('invalid_ipv4'),
            macAddress &&
              !funcs.is.mac(macAddress) &&
              errors.MACAddress.push('invalid_mac'),
            hostname &&
              !isHostname(hostname) &&
              errors.Hostname.push('invalid_hostname'),
            errors
          );
        }

        function checkForEntryInSubnet(ipaddr, server) {
          if (!ipaddr || !funcs.is.ipv4(ipaddr)) return !0;
          var network = funcs.ipv4.subnet.getNetworkRange(
            server.Address,
            server.SubnetMask
          );
          return funcs.ipv4.subnet.belongNetworkRange(network, ipaddr)
            ? !0
            : !1;
        }

        function isUseRule(rule) {
          return _.some(list(), function(elem, inx) {
            return (
              rule.IPAddress == elem.IPAddress ||
              rule.MACAddress == elem.MACAddress
            );
          });
        }

        function usedValues(withoutInx) {
          var rules = _.filter(list(), function(elem, inx) {
            return 'cut' == getInstanceState(inx)
              ? !1
              : withoutInx && withoutInx == inx
                ? !1
                : !0;
          });
          return {
            IPAddress: _.compact(_.pluck(rules, 'IPAddress')),
            MACAddress: _.compact(_.pluck(rules, 'MACAddress')),
            Hostname: _.compact(_.pluck(rules, 'Hostname')),
            Mode: _.compact(_.pluck(rules, 'Mode')),
          };
        }

        function getInstanceState(instance) {
          var regCut = /\-$/,
            regAdd = /\+$/;
          return regCut.test(instance)
            ? 'cut'
            : regAdd.test(instance)
              ? 'add'
              : '';
        }
        var dhcpServer = dhcp.Server || {};
        return {
          list: list,
          mode: mode,
          add: add,
          set: set,
          cut: cut,
          remove: remove,
          validation: validation,
          checkForEntryInSubnet: checkForEntryInSubnet,
          isUseRule: isUseRule,
          usedValues: usedValues,
          getInstanceState: getInstanceState,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var Notification = (__webpack_require__(5),
        __webpack_require__(3),
        __webpack_require__(201)),
        ipv6StaticIP = __webpack_require__(206),
        ipv6DHCP = __webpack_require__(207);
      module.exports = function(iface) {
        function data() {
          return ipv6;
        }
        var ipv6 = iface.IPv6,
          staticIP = ipv6StaticIP(ipv6),
          dhcp = ipv6DHCP(ipv6),
          notification = new Notification();
        return (
          notification.add({
            name: 'dhcp_is_incorrect_pool',
            check: {
              fn: dhcp.isIncorrectPool,
              context: dhcp,
            },
            correct: {
              fn: dhcp.changePool,
              context: dhcp,
            },
            params: {
              fn: function() {
                var ranges = staticIP.getRanges();
                return {
                  ranges: ranges,
                };
              },
            },
          }),
          {
            data: data,
            staticIP: staticIP,
            dhcp: dhcp,
            notification: notification,
          }
        );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.is = __webpack_require__(73)),
        (funcs.ipv6 = __webpack_require__(75));
      var _ = __webpack_require__(3);
      module.exports = function(ipv6) {
        function get(inx) {
          return _.has(staticIP, inx) ? staticIP[inx] : null;
        }

        function list() {
          return _.isUndefined(staticIP) ? null : _.omit(staticIP, 2);
        }

        function validation(elem) {
          function isInvalidIP(addr) {
            return addr && !funcs.is.ipv6(addr);
          }

          function isInvalidPrefix(prefix) {
            return prefix && !funcs.is.ipv6Prefix(prefix);
          }

          function isReserved(addr, prefix) {
            return funcs.ipv6.subnet.checkReserved(addr, prefix);
          }

          function isOutOfRangePrefix(prefix) {
            var value = parseInt(prefix);
            return (
              (!_.isNull(options.minPrefix) && value < options.minPrefix) ||
              (!_.isNull(options.maxPrefix) && value > options.maxPrefix)
            );
          }

          function isOutOfSubnetRange(subnetGateway, subnetStaticIp) {
            return subnetGateway != subnetLinkLocal &&
              subnetGateway != subnetStaticIp
              ? subnetGateway && subnetStaticIp
              : void 0;
          }
          var errors = {
              Address: [],
              Prefix: [],
              GatewayAddress: [],
            },
            addr = elem.Address,
            prefix = elem.Prefix,
            gw = elem.GatewayAddress;
          if (gw)
            var subnetGateway = funcs.ipv6.subnet.getNetworkAddress(
                funcs.ipv6.address.full(gw),
                prefix
              ),
              subnetStaticIp = funcs.ipv6.subnet.getNetworkAddress(
                funcs.ipv6.address.full(addr),
                prefix
              ),
              subnetLinkLocal = funcs.ipv6.subnet.getNetworkAddress(
                funcs.ipv6.address.full('fe80::'),
                prefix
              );
          return (
            isInvalidIP(addr) && errors.Address.push('invalid_ipv6'),
            isInvalidIP(gw) && errors.GatewayAddress.push('invalid_ipv6'),
            isInvalidPrefix(prefix) &&
              errors.Prefix.push('invalid_ipv6_prefix'),
            isInvalidIP(addr) ||
              isInvalidPrefix(prefix) ||
              (isReserved(addr, prefix) &&
                errors.Address.push('error_ip_is_reserved')),
            isInvalidIP(gw) ||
              isInvalidPrefix(prefix) ||
              (isReserved(gw, prefix) &&
                errors.GatewayAddress.push('error_ip_is_reserved')),
            isInvalidIP(addr) ||
              isInvalidIP(gw) ||
              isInvalidPrefix(prefix) ||
              (isOutOfRangePrefix(prefix) &&
                errors.Prefix.push('error_subnet_ipv6_prefix_out_of_range')),
            isInvalidIP(gw) ||
              isInvalidPrefix(prefix) ||
              isInvalidIP(addr) ||
              (isOutOfSubnetRange(subnetGateway, subnetStaticIp) &&
                errors.GatewayAddress.push(
                  'error_gateway_ip_address_out_of_range'
                )),
            isInvalidIP(addr) ||
              isInvalidIP(gw) ||
              isInvalidPrefix(prefix) ||
              (gw &&
                addr == gw &&
                errors.GatewayAddress.push('ip_address_is_used')),
            errors
          );
        }

        function getRanges() {
          function isValidList(addressesList) {
            return _.every(addressesList, function(elem) {
              var errors = validation(elem);
              return 0 == errors.Address.length && 0 == errors.Prefix.length;
            });
          }
          var result = [],
            addressesList = list();
          return isValidList(addressesList)
            ? (_.each(addressesList, function(elem) {
                var network = funcs.ipv6.subnet.getNetworkRange(
                    elem.Address,
                    elem.Prefix
                  ),
                  ranges = funcs.ipv6.subnet.splitNetworkRange(
                    network,
                    elem.Address
                  );
                _.each(ranges, function(range) {
                  funcs.ipv6.subnet.belongNetworkRange(network, range.start) &&
                    funcs.ipv6.subnet.belongNetworkRange(network, range.end) &&
                    range.start != range.end &&
                    (result = result.concat(range));
                });
              }),
              result)
            : result;
        }

        function outOfRanges(addr) {
          var ranges = getRanges();
          return ranges.length
            ? !_.some(ranges, function(range) {
                return funcs.ipv6.subnet.belongNetworkRange(range, addr);
              })
            : !1;
        }

        function getSubnet() {
          function isValidList(addressesList) {
            return _.every(addressesList, function(elem) {
              var errors = validation(elem);
              return 0 == errors.Address.length && 0 == errors.Prefix.length;
            });
          }
          var result = [],
            addressesList = list();
          return isValidList(addressesList)
            ? (_.each(addressesList, function(elem) {
                var network = funcs.ipv6.subnet.getNetwork(
                  elem.Address,
                  elem.Prefix
                );
                result.push(network);
              }),
              result)
            : result;
        }

        function isBelongDifferentRanges(addrs) {
          function isBelong(net, addrs) {
            return _.every(addrs, function(addr) {
              return funcs.ipv6.subnet.belongNetwork(net.net, addr, net.prefix);
            });
          }
          var subnet = getSubnet();
          return subnet.length
            ? !_.some(subnet, function(net) {
                return isBelong(net, addrs);
              })
            : !1;
        }

        function isAddressBelongNetworkRange(range) {
          var addressesList = list();
          return _.some(addressesList, function(elem) {
            return funcs.ipv6.subnet.belongNetworkRange(range, elem.Address);
          });
        }

        function getOptions() {
          return options;
        }

        function setOptions(data) {
          options = _.extend(options, data);
        }
        var staticIP = ipv6.StaticIP,
          options = {
            minPrefix: 1,
            maxPrefix: 128,
          };
        return {
          get: get,
          list: list,
          validation: validation,
          getRanges: getRanges,
          outOfRanges: outOfRanges,
          isBelongDifferentRanges: isBelongDifferentRanges,
          getOptions: getOptions,
          setOptions: setOptions,
          isAddressBelongNetworkRange: isAddressBelongNetworkRange,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.ipv6 = __webpack_require__(75)),
        (funcs.is = __webpack_require__(73)),
        (_ = __webpack_require__(3));
      var moduleStatipIP = __webpack_require__(206),
        moduleDhcpStaticAddress = __webpack_require__(208);
      module.exports = function(ipv6) {
        function data() {
          return dhcp;
        }

        function validation() {
          var errors = {
              MinAddress: [],
              MaxAddress: [],
            },
            minAddress = dhcp.Server.MinAddress,
            maxAddress = dhcp.Server.MaxAddress;
          if (
            (minAddress || errors.MinAddress.push('input_is_empty'),
            maxAddress || errors.MaxAddress.push('input_is_empty'),
            minAddress &&
              !funcs.is.ipv6(minAddress) &&
              errors.MinAddress.push('invalid_ipv6'),
            maxAddress &&
              !funcs.is.ipv6(maxAddress) &&
              errors.MaxAddress.push('invalid_ipv6'),
            minAddress &&
              funcs.is.ipv6(minAddress) &&
              maxAddress &&
              funcs.is.ipv6(maxAddress))
          ) {
            var compareAddresses = funcs.ipv6.address.compare(
              minAddress,
              maxAddress
            );
            switch (compareAddresses) {
              case 1:
                errors.MinAddress.push('error_dhcp_start_ip_more_stop_ip'),
                  errors.MaxAddress.push('error_dhcp_stop_ip_less_start_ip');
                break;
              case 0:
                errors.MinAddress.push('error_dhcp_start_ip_equal_stop_ip'),
                  errors.MaxAddress.push('error_dhcp_start_ip_equal_stop_ip');
            }
            staticIP.isBelongDifferentRanges([minAddress, maxAddress]) &&
              (errors.MinAddress.push(
                'error_dhcp_start_ip_and_stop_ip_belong_different_ip_ranges'
              ),
              errors.MaxAddress.push(
                'error_dhcp_start_ip_and_stop_ip_belong_different_ip_ranges'
              )),
              staticIP.isAddressBelongNetworkRange({
                start: minAddress,
                end: maxAddress,
              }) &&
                (errors.MinAddress.push(
                  'error_lan_ip_address_is_in_dhcp_range_ipv6'
                ),
                errors.MaxAddress.push(
                  'error_lan_ip_address_is_in_dhcp_range_ipv6'
                )),
              staticIP.outOfRanges(minAddress) &&
                errors.MinAddress.push('error_dhcp_start_ip_out_of_ranges'),
              staticIP.outOfRanges(maxAddress) &&
                errors.MaxAddress.push('error_dhcp_stop_ip_out_of_ranges');
          }
          return errors;
        }

        function changePool(obj) {
          obj.start &&
            funcs.is.ipv6(obj.start) &&
            obj.end &&
            funcs.is.ipv6(obj.end) &&
            ((dhcp.Server.MinAddress = obj.start),
            (dhcp.Server.MaxAddress = obj.end));
        }

        function isIncorrectPool() {
          var autoMode = (data().Mode, data().Server.AutoconfigurationMode);
          if ('Statefull' != autoMode) return !1;
          var error = validation();
          return error.MinAddress.length || error.MaxAddress.length;
        }
        var dhcp = ipv6.DHCP,
          staticIP = _.isUndefined(ipv6.staticIP)
            ? moduleStatipIP(ipv6)
            : ipv6.staticIP,
          dhcpStaticAddress = moduleDhcpStaticAddress(dhcp);
        return {
          data: data,
          validation: validation,
          isIncorrectPool: isIncorrectPool,
          changePool: changePool,
          staticAddress: dhcpStaticAddress,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var funcs = __webpack_require__(5);
      (funcs.is = __webpack_require__(73)),
        (funcs.ipv6 = __webpack_require__(75));
      var _ = __webpack_require__(3);

      module.exports = function(dhcp) {
        function list() {
          return dhcpServer.StaticAddress;
        }

        function mode() {
          return dhcp.Mode;
        }

        function add(elem) {
          var path = funcs.addInstance(dhcpServer, 'StaticAddress', elem);
          return path.replace('StaticAddress.', '');
        }

        function set(elem, inx) {
          var path = funcs.setInstance(
            dhcpServer,
            'StaticAddress.' + inx,
            elem
          );
          return path.replace('StaticAddress.', '');
        }

        function cut(inx) {
          return funcs.cutInstance(dhcpServer, 'StaticAddress.' + inx);
        }

        function remove(inx) {
          var elem = _.clone(dhcpServer.StaticAddress[inx]);
          delete dhcpServer.StaticAddress[inx];
          var toAdd = dhcpServer.__toAdd.split(','),
            toAddIndex = _.indexOf(toAdd, 'StaticAddress.' + inx);
          return (
            -1 != toAddIndex && toAdd.splice(toAddIndex, 1),
            toAdd.length
              ? (dhcpServer.__toAdd = toAdd.join(','))
              : delete dhcpServer.__toAdd,
            elem
          );
        }

        function validation(elem) {
          function isHostname(hostname) {
            var re = /^([a-zA-Z0-9]{1})+([a-zA-Z0-9-])+([a-zA-Z0-9]{1})+$/;
            return re.test(hostname);
          }
          var errors = {
              IPAddress: [],
              MACAddress: [],
              Hostname: [],
            },
            ipAddress = elem.IPAddress,
            macAddress = elem.MACAddress,
            hostname = elem.Hostname;
          return (
            ipAddress &&
              !funcs.is.ipv6(ipAddress) &&
              errors.IPAddress.push('invalid_ipv6'),
            macAddress &&
              !funcs.is.mac(macAddress) &&
              errors.MACAddress.push('invalid_mac'),
            hostname &&
              !isHostname(hostname) &&
              errors.Hostname.push('invalid_hostname'),
            errors
          );
        }

        function checkForEntryInSubnet(ipaddr, server) {
          if (!ipaddr || !funcs.is.ipv6(ipaddr)) return !0;
          var network = funcs.ipv6.subnet.getNetworkRange(
            server.Address,
            server.Prefix
          );
          return funcs.ipv6.subnet.belongNetworkRange(network, ipaddr)
            ? !0
            : !1;
        }

        function isUseRule(rule) {
          return _.some(list(), function(elem, inx) {
            return (
              rule.IPAddress == elem.IPAddress ||
              rule.MACAddress == elem.MACAddress
            );
          });
        }

        function usedValues(withoutInx) {
          var rules = _.filter(list(), function(elem, inx) {
            return 'cut' == getInstanceState(inx)
              ? !1
              : withoutInx && withoutInx == inx
                ? !1
                : !0;
          });
          return {
            IPAddress: _.compact(_.pluck(rules, 'IPAddress')),
            MACAddress: _.compact(_.pluck(rules, 'MACAddress')),
            Hostname: _.compact(_.pluck(rules, 'Hostname')),
            Mode: _.compact(_.pluck(rules, 'Mode')),
          };
        }

        function getInstanceState(instance) {
          var regCut = /\-$/,
            regAdd = /\+$/;
          return regCut.test(instance)
            ? 'cut'
            : regAdd.test(instance)
              ? 'add'
              : '';
        }
        var dhcpServer = dhcp.Server ? dhcp.Server : {};
        return {
          list: list,
          mode: mode,
          add: add,
          set: set,
          cut: cut,
          remove: remove,
          validation: validation,
          checkForEntryInSubnet: checkForEntryInSubnet,
          isUseRule: isUseRule,
          usedValues: usedValues,
          getInstanceState: getInstanceState,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }

      function isChanged() {
        var path,
          changes = status();
        for (path in changes) if (!path.indexOf('Device.VLAN')) return !0;
        return !1;
      }

      function status() {
        return dms.data
          ? _.extend(
              funcs.getChanges(dms.data, dms.__initialData),
              funcs.getChanges(dms.__initialData, dms.data)
            )
          : {};
      }

      function getAvailPortsU(vlan, include, exclude) {
        return getAvailPorts(vlan)(include, exclude);
      }

      function getAvailPortsT(include, exclude) {
        return getAvailPorts(null)(include, exclude);
      }

      function getAvailPorts(vlan) {
        return function(include, exclude) {
          function filterHandler(filters, isExclude) {
            function check(port, isExclude) {
              return function(type) {
                return types[type](port) ^ isExclude;
              };
            }
            return function(port) {
              return filters.filter(inTypes).some(check(port, isExclude));
            };
          }

          function inCurrentVlan(name) {
            return toArray(vlan.PortsU).some(function(port) {
              return name === port.Key;
            });
          }

          function isFree(name) {
            return !getBusyPorts().some(function(port) {
              return name === port.Key;
            });
          }

          function getBusyPorts() {
            var concatPorts = function(acc, vlan) {
              return acc.concat(toArray(vlan.PortsU));
            };
            return reduce(getDmsVlan().List, concatPorts, []);
          }
          var isAvail = function(port, name) {
              return inCurrentVlan(name) || isFree(name);
            },
            inTypes = function(type) {
              return type in types;
            },
            isNotEmptyArray = function(obj) {
              return Array.isArray(obj) && obj.length;
            },
            types = {
              wan: isWan,
              wifi: isWifi,
            },
            isTagged = null === vlan,
            ports = isTagged
              ? reject(getDmsVlan().Ports, isWifi)
              : filter(getDmsVlan().Ports, isAvail);
          return (
            (ports = isNotEmptyArray(include)
              ? filter(ports, filterHandler(include, !1))
              : ports),
            isNotEmptyArray(exclude)
              ? filter(ports, filterHandler(exclude, !0))
              : ports
          );
        };
      }

      function getUsedPortsU(vlan) {
        return getUsedPorts('PortsU', vlan);
      }

      function getUsedPortsT(vlan) {
        return getUsedPorts('PortsT', vlan);
      }

      function getUsedPorts(portsKey, vlan) {
        function isUsed(port, name) {
          return toArray(vlan[portsKey]).some(function(port) {
            return name === port.Key;
          });
        }

        function convert(item, key) {
          return {
            item: item,
            key: key,
          };
        }
        return toArray(map(filter(getDmsVlan().Ports, isUsed), convert));
      }

      function getTypeCount(type) {
        var checkType = function(type) {
          return function(vlan) {
            return vlan.Type === type;
          };
        };
        return toArray(getDmsVlan().List).filter(checkType(type)).length;
      }

      function filter(obj, fn) {
        function filterFn(acc, item, key, obj) {
          return fn(item, key, obj) ? setProp(acc, key, item) : acc;
        }
        return reduce(obj, filterFn, {});
      }

      function reject(obj, fn) {
        return filter(obj, reverse(fn));
      }

      function map(obj, fn) {
        function mapFn(acc, item, key, obj) {
          return setProp(acc, key, fn(item, key, obj));
        }
        return reduce(obj, mapFn, {});
      }

      function setProp(obj, key, property) {
        return (obj[key] = property), obj;
      }

      function reduce(obj, fn, initial) {
        var result = initial;
        for (var key in obj) result = fn(result, obj[key], key, obj);
        return result;
      }

      function toArray(obj) {
        return obj
          ? _keys2['default'](obj).map(function(key) {
              return obj[key];
            })
          : [];
      }

      function reverse(fn) {
        return function(item, key, obj) {
          return !fn.apply(null, arguments);
        };
      }
      var _keys = __webpack_require__(150),
        _keys2 = _interopRequireDefault(_keys),
        dms = __webpack_require__(141).get().vlan,
        funcs = __webpack_require__(5),
        getDmsVlan = function() {
          return dms.data.Device.VLAN;
        },
        pull = dms.pull,
        push = dms.push,
        data = function() {
          return _.isNull(dms.data) ? {} : getDmsVlan();
        };
      (module.exports = {
        pull: pull,
        push: push,
        status: status,
        isChanged: isChanged,
        data: data,
        getAvailPortsU: getAvailPortsU,
        getAvailPortsT: getAvailPortsT,
        getUsedPortsU: getUsedPortsU,
        getUsedPortsT: getUsedPortsT,
        getTypeCount: getTypeCount,
        cut: function(inx) {
          return funcs.cutInstance(getDmsVlan(), 'List.' + inx);
        },
        set: function(inx, obj) {
          return funcs.setInstance(getDmsVlan(), 'List.' + inx, obj);
        },
        add: function(obj) {
          return funcs.addInstance(getDmsVlan(), 'List', obj);
        },
        list: function() {
          return getDmsVlan().List;
        },
        cutPort: function(portsKey, vlanInx, inx) {
          return funcs.cutInstance(
            getDmsVlan().List[vlanInx],
            portsKey + '.' + inx
          );
        },
        addPort: function(portsKey, vlanInx, obj) {
          return funcs.addInstance(getDmsVlan().List[vlanInx], portsKey, obj);
        },
      }),
        (dms.isChanged = isChanged),
        (dms.status = status);
      var isWan = function(port) {
          return !!port.IsWan;
        },
        isWifi = function(port) {
          return !!port.IsWifi;
        };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var dir = __webpack_require__(211),
        dsl = __webpack_require__(212);
      module.exports = function() {
        var obj = {};
        return (
          dir.pull && !dsl.pull
            ? (obj = dir)
            : dsl.pull && !dir.pull && (obj = dsl),
          obj
        );
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        dms = (__webpack_require__(140),
        __webpack_require__(5),
        __webpack_require__(141).get().portAllocation);
      module.exports = (function() {
        function updateAvailableSourcesList() {
          availableSources = _.reduce(
            dms.data.sources,
            function(memo, source, index) {
              return sourceMayBeGrouped(source) && (memo[index] = source), memo;
            },
            {}
          );
        }

        function updateType(source, id) {
          if ('wan' == source.type && source.vid)
            throw 'Cannot create or update tagged NAT';
          if (!id || 'wan' != source.type) {
            if (!hasDefaultWanSource() && !source.vid)
              return void (source.type = 'wan');
            if (
              (hasDefaultWanSource() && source.vid && (source.type = 'bridge'),
              hasDefaultWanSource() && !source.vid)
            )
              throw 'Cannot create or update bridge without tag';
          }
        }

        function addSource(source) {
          if (!source.name) throw 'source name must be specified';
          updateType(source);
          var maxId = _.max(_.keys(dms.data.sources)) || -1,
            newId = Number(maxId) + 1;
          dms.data.sources[newId] = source;
          var internetPort =
            _.findWhere(dms.data.wanPorts, {
              name: 'internet',
            }) ||
            _.findWhere(dms.data.wanPorts, {
              name: 'port5',
            });
          return (
            internetPort && internetPort.bridge.push(newId),
            updateAvailableSourcesList(),
            source
          );
        }

        function getDefaultWanSourceId() {
          var defaultSource = _.find(_.pairs(getAvailableSources()), function(
            pair
          ) {
            return 'wan' == pair[1].type && !pair[1].vid;
          });
          return defaultSource ? defaultSource[0] : null;
        }

        function hasDefaultWanSource() {
          return !!getDefaultWanSourceId();
        }

        function updateSource(id, source) {
          updateType(source, id),
            _.extend(dms.data.sources[id], source),
            updateAvailableSourcesList();
        }

        function removeSource(id) {
          var source = dms.data.sources[id];
          _.each(dms.data.lanPorts, function(port) {
            source && port.bridge == source.name && (port.bridge = null);
          }),
            delete dms.data.sources[id],
            updateAvailableSourcesList();
        }

        function getAvailableSources() {
          return (
            availableSources || updateAvailableSourcesList(), availableSources
          );
        }

        function filterBridges() {
          return _.omit(getAvailableSources(), function(source) {
            return 'bridge' != source.type;
          });
        }

        function portInBridge(port) {
          return port.bridge ? !!filterBridges()[port.bridge] : !1;
        }

        function sourceMayBeGrouped(source) {
          return (
            'bridge' == source.type || ('wan' == source.type && !source.vid)
          );
        }

        function sourceIsEditable(source) {
          return !source || 'bridge' == source.type;
        }

        function getReservedNames() {
          return _.pluck(dms.data.sources, 'name');
        }

        function getReservedVlans(params) {
          return _.compact(_.pluck(dms.data.sources, 'vid'));
        }

        function getDefaultSourceId() {
          var wanSourceId = getDefaultWanSourceId();
          return isNull(wanSourceId) ? null : wanSourceId;
        }

        function getDefaultSource() {
          var defaultSourceId = getDefaultWanSourceId();
          return isNull(defaultSourceId)
            ? null
            : getAvailableSources()[defaultSourceId];
        }

        function isNull(value) {
          return _.isUndefined(value) || _.isNull(value);
        }

        function portInDefaultGroup(port) {
          var defaultSourceId = getDefaultSourceId();
          return !isNull(defaultSourceId) && defaultSourceId == port.bridge;
        }

        function pull() {
          var promise = dms.pull();
          return promise.then(updateAvailableSourcesList), promise;
        }
        var availableSources = null;
        return {
          pull: pull,
          push: dms.push,
          sources: getAvailableSources,
          connections: function() {
            return [];
          },
          deletedSources: function() {
            return [];
          },
          ports: function() {
            return dms.data.lanPorts;
          },
          availIfaces: function() {
            return [];
          },
          getBusyPVC: function() {
            return [];
          },
          addSource: addSource,
          updateSource: updateSource,
          removeSource: removeSource,
          sourceIsEditable: sourceIsEditable,
          getDeviceClass: function() {
            return 'DIR';
          },
          getReservedNames: getReservedNames,
          getReservedVlans: getReservedVlans,
          getDefaultSource: getDefaultSource,
          getDefaultSourceId: getDefaultSourceId,
          portInDefaultGroup: portInDefaultGroup,
          hasDefaultWanSource: hasDefaultWanSource,
          portInBridge: portInBridge,
          isChanged: dms.isChanged,
        };
      })();
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function isChanged(protocol) {
        var path,
          changes = status();
        for (path in changes)
          if (!path.indexOf('Device.DNS.' + protocol)) return !0;
        return !1;
      }

      function status() {
        return dms.data
          ? _.extend(
              funcs.getChanges(dms.data, dms.__initialData),
              funcs.getChanges(dms.__initialData, dms.data)
            )
          : {};
      }

      function data() {
        return dms.data ? dms.data.Device.DNS : {};
      }
      var dms = __webpack_require__(141).get().dns,
        funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      (module.exports = {
        pull: dms.pull,
        push: dms.push,
        status: status,
        isChanged: isChanged,
        data: data,
      }),
        (dms.isChanged = isChanged),
        (dms.status = status);
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(215),
        converter: __webpack_require__(216),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      module.exports = function() {
        function getDefaultRule(attrs) {
          var defaultModel = funcs.newConfig.makeDefaultModel(attrs);
          return (
            (defaultModel.Source.Iface = 'all'),
            defaultModel.Dest.Ports &&
              (defaultModel.Dest.Ports = {
                1: defaultModel.Dest.Ports,
              }),
            defaultModel.Source.Ports &&
              (defaultModel.Source.Ports = {
                1: defaultModel.Source.Ports,
              }),
            defaultModel
          );
        }

        function getProtocolList(allList, possibleList) {
          return _.chain(allList)
            .intersection(possibleList)
            .map(function(proto) {
              return {
                name: proto,
                value: proto,
              };
            })
            .value();
        }

        function getEmptyIfaces(rules) {
          var output = [];
          return (
            _.each(rules, function(elem) {
              elem.Source.Iface || output.push(elem.Name);
            }),
            output.join(', ')
          );
        }

        function getUseSourcePorts(allUsePorts, iface, proto, index) {
          function filterVserverRule(rule, iface, proto, index) {
            return 'vserver' != rule.Section && 'firewall' != rule.Section
              ? !1
              : _.isUndefined(index) || rule.Id != index
                ? 'all' != iface && 'all' != rule.Iface && iface != rule.Iface
                  ? !0
                  : 'TCP/UDP' != proto &&
                    'TCP/UDP' != rule.Proto &&
                    proto != rule.Proto
                    ? !0
                    : !1
                : !0;
          }
          var output = [];
          return (
            _.each(allUsePorts, function(rule) {
              filterVserverRule(rule, iface, proto, index) ||
                output.push({
                  startPort: rule.Ports.Start,
                  endPort: rule.Ports.End,
                });
            }),
            output
          );
        }

        function validation(rule, index, config) {
          function validationName(rule, index) {
            function isUniqName(name) {
              return !_.contains(usedNames(config.Rules, index), name);
            }
            var result = [];
            return (
              isUniqName(rule.Name) || result.push('error_value_is_not_uniq'),
              result
            );
          }

          function validationDestIp(rule) {
            function isOutOfRanges(ip) {
              var ranges = getPrivateSubnetRanges(config.LAN);
              return !_.some(ranges, function(range) {
                return funcs.ipv4.subnet.belongNetworkRange(range, ip);
              });
            }
            var result = [],
              ips = funcs.fetchBranch(rule, 'Dest.IP.');
            if (!ips || !ips.length || !ips[0]) return result;
            var ip = ips[0];
            return (
              funcs.is.ipv4(ip) || result.push('invalid_ipv4'),
              isOutOfRanges(ip) && result.push('error_ipd_not_belong_subnets'),
              result
            );
          }

          function usedNames(rules, without) {
            var result = [];
            return (
              _.each(rules, function(elem, index) {
                (_.isUndefined(without) || without != index) &&
                  result.push(elem.Name);
              }),
              result
            );
          }

          function getPrivateSubnetRanges(lan) {
            return _.map(lan, function(elem) {
              return funcs.ipv4.subnet.getNetworkRange(
                elem.Address,
                elem.SubnetMask
              );
            });
          }
          return {
            name: validationName(rule, index),
            destIp: validationDestIp(rule),
          };
        }
        return {
          getDefaultRule: getDefaultRule,
          getProtocolList: getProtocolList,
          getEmptyIfaces: getEmptyIfaces,
          getUseSourcePorts: getUseSourcePorts,
          validation: validation,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function somovdToNative(input) {
          function prepareRules(rules) {
            function getDefaultRule(type) {
              switch (type) {
                case 'ipsec':
                  return {
                    proto: 'udp',
                    portd_begin: '500,4500',
                    ports_begin: '500,4500',
                  };
                case 'sftp':
                  return {
                    proto: 'tcp',
                    portd_begin: '22,115',
                    ports_begin: '22,115',
                  };
                case 'pcanywhere':
                  return {
                    proto: 'tcp/udp',
                    portd_begin: '5631,5632',
                    ports_begin: '5631,5632',
                  };
              }
              return {};
            }
            return (
              _.each(rules, function(rule, index) {
                var defRule = getDefaultRule(rule.type);
                rules[index] = _.extend(rule, defRule);
              }),
              rules
            );
          }

          function getUsedSourcePorts(input, rules) {
            function addVserverPorts(rules, result) {
              _.each(rules, function(rule) {
                var input = {
                    Section: 'vserver',
                    Id: rule.__id,
                    Iface: rule.Source.Iface,
                    Proto: rule.Proto,
                  },
                  ports = rule.Source.Ports[1];
                ports.Start && ports.End
                  ? ((input.Ports = ports), result.push(input))
                  : ports.Start &&
                    _.each(ports.Start.split(','), function(value) {
                      (input.Ports = {
                        Start: value,
                        End: '',
                      }),
                        result.push(_.clone(input));
                    });
              });
            }

            function addHttpAccessPorts(rules, result) {
              _.each(rules, function(rule) {
                result.push({
                  Section: 'httpaccess',
                  Ports: {
                    Start: rule.sport.toString(),
                    End: '',
                  },
                });
              });
            }

            function addConnReqPorts(tr69, result) {
              result.push({
                Section: 'tr69',
                Ports: {
                  Start: tr69.ConnReqPort.toString(),
                  End: '',
                },
              });
            }

            function addVoipPorts(voip, result) {
              result.push({
                Section: 'voip',
                Ports: {
                  Start: '9000',
                  End: '9008',
                },
              }),
                voip.UserAgentPort &&
                  result.push({
                    Section: 'voip',
                    Ports: {
                      Start: voip.UserAgentPort.toString(),
                      End: '',
                    },
                  });
            }
            var result = [];
            return (
              addVserverPorts(rules, result),
              input.httpaccess && addHttpAccessPorts(input.httpaccess, result),
              input.tr69 && addConnReqPorts(input.tr69, result),
              input.voip && addVoipPorts(input.voip, result),
              result
            );
          }

          function getConns(wan) {
            var list = [];
            return (
              _.each(wan, function(obj, key) {
                obj.Connection &&
                  (_.contains(['PPPoEv6', 'IPv6oE'], key) ||
                    _.each(obj.Connection, function(conn) {
                      list.push(conn);
                    }));
              }),
              list
            );
          }

          function getLanAddrs(input) {
            var result = [];
            return (
              _.each(input.LAN, function(elem) {
                _.each(elem.IPv4.StaticIP, function(addr) {
                  result.push(addr);
                });
              }),
              result
            );
          }
          var pattern = T({
            '->': ['$input', 'Rules', 'Ifaces', 'UsedSourcePorts', 'LAN'],
            $input: ':external',
            Rules: {
              '->': ['$rule', 'Source', 'Dest'],
              '{$rule, $index}': [
                '$parent',
                function(p) {
                  return prepareRules(p.$input.vserver);
                },
              ],
              __id: [
                '$index*',
                function(i) {
                  return i;
                },
              ],
              __num: [
                '$rule*',
                function(r) {
                  return r.num;
                },
              ],
              Enable: !0,
              Name: [
                '$rule*',
                function(r) {
                  return r.name;
                },
              ],
              Type: [
                '$rule*',
                function(r) {
                  return r.type;
                },
              ],
              Proto: [
                '$rule*',
                function(r) {
                  return r.proto ? r.proto.toUpperCase() : '';
                },
              ],
              SNAT: [
                '$rule*',
                function(r) {
                  return r.enable_snat;
                },
              ],
              Source: {
                '->': ['?', 'IP', 'Ports'],
                $rule: [
                  '$parent',
                  function(p) {
                    return p.$rule;
                  },
                ],
                '?': [
                  '$rule',
                  function(r) {
                    return !!r;
                  },
                ],
                Iface: [
                  '$rule',
                  function(r) {
                    return r.source_iface;
                  },
                ],
                IP: {
                  '->': !0,
                  $rule: [
                    '$parent',
                    function(p) {
                      return p.$rule;
                    },
                  ],
                  '{$addr}': [
                    '$rule',
                    function(r) {
                      return r.remote_ip ? r.remote_ip.split(',') : [''];
                    },
                  ],
                  $return: [
                    '$addr',
                    function(a) {
                      return a;
                    },
                  ],
                },
                Ports: {
                  '->': ['$rule', '1'],
                  $rule: [
                    '$parent',
                    function(p) {
                      return p.$rule;
                    },
                  ],
                  1: {
                    '->': !0,
                    $rule: [
                      '$parent',
                      function(p) {
                        return p.$rule;
                      },
                    ],
                    Start: [
                      '$rule',
                      function(r) {
                        return r.ports_begin;
                      },
                    ],
                    End: [
                      '$rule',
                      function(r) {
                        return r.ports_end;
                      },
                    ],
                  },
                },
              },
              Dest: {
                '->': ['?', 'IP', 'Ports'],
                $rule: [
                  '$parent',
                  function(p) {
                    return p.$rule;
                  },
                ],
                '?': [
                  '$rule',
                  function(r) {
                    return !!r;
                  },
                ],
                IP: {
                  '->': !0,
                  $rule: [
                    '$parent',
                    function(p) {
                      return p.$rule;
                    },
                  ],
                  '{$addr}': [
                    '$rule',
                    function(r) {
                      return r.ipd ? r.ipd.split(',') : [];
                    },
                  ],
                  $return: [
                    '$addr',
                    function(a) {
                      return a;
                    },
                  ],
                },
                Ports: {
                  '->': ['$rule', '1'],
                  $rule: [
                    '$parent',
                    function(p) {
                      return p.$rule;
                    },
                  ],
                  1: {
                    '->': !0,
                    $rule: [
                      '$parent',
                      function(p) {
                        return p.$rule;
                      },
                    ],
                    Start: [
                      '$rule',
                      function(r) {
                        return r.portd_begin;
                      },
                    ],
                    End: [
                      '$rule',
                      function(r) {
                        return r.portd_end;
                      },
                    ],
                  },
                },
              },
            },
            UsedSourcePorts: [
              '$input',
              'Rules',
              function(i, rs) {
                return getUsedSourcePorts(i, rs);
              },
            ],
            Ifaces: {
              '->': !0,
              $ifaces: [
                '$parent',
                function(p) {
                  return p.$input.ifaces;
                },
              ],
              $wan: [
                '$ifaces*',
                function(ifaces) {
                  return wanConverter.somovdToNative(ifaces);
                },
              ],
              '{$conn}': [
                '$wan',
                function(w) {
                  return getConns(w);
                },
              ],
              Name: [
                '$conn*',
                function(c) {
                  return c.Name;
                },
              ],
              Value: [
                '$conn*',
                function(c) {
                  return c.__OriginInterface
                    ? c.__OriginInterface
                    : c.__LowerLayer;
                },
              ],
            },
            LAN: {
              '->': !0,
              $ifaces: [
                '$parent',
                function(p) {
                  return p.$input.ifaces;
                },
              ],
              $lan: [
                '$ifaces*',
                function(ifaces) {
                  return lanConverter.somovdToNative(ifaces.iface_names);
                },
              ],
              '{$addr}': [
                '$lan*',
                function(lan) {
                  return getLanAddrs(lan);
                },
              ],
              $return: [
                '$addr',
                function(a) {
                  return a;
                },
              ],
            },
          });
          return pattern.build({
            $input: input,
          });
        }

        function nativeToSomovd(input) {
          var pattern = T({
            '->': !0,
            $input: ':external',
            $rules: [
              '$input',
              function(i) {
                return i.Rules;
              },
            ],
            '{$rule}': [
              '$rules',
              function(rs) {
                return rs;
              },
            ],
            $source: [
              '$rule*',
              function(r) {
                return r.Source;
              },
            ],
            $dest: [
              '$rule*',
              function(r) {
                return r.Dest;
              },
            ],
            num: [
              '$rule*',
              function(r) {
                return r.__id;
              },
            ],
            name: [
              '$rule*',
              function(r) {
                return r.Name;
              },
            ],
            type: [
              '$rule*',
              function(r) {
                return r.Type;
              },
            ],
            proto: [
              '$rule*',
              function(r) {
                return r.Proto ? r.Proto.toLowerCase() : '';
              },
            ],
            enable_snat: [
              '$rule*',
              function(r) {
                return r.SNAT;
              },
            ],
            source_iface: [
              '$source*',
              function(s) {
                return s.Iface;
              },
            ],
            remote_ip: [
              '$source*',
              function(s) {
                return s.IP ? s.IP.join(',') : '';
              },
            ],
            ports_begin: [
              '$source*',
              function(s) {
                return s.Ports ? s.Ports[1].Start : '';
              },
            ],
            ports_end: [
              '$source*',
              function(s) {
                return s.Ports ? s.Ports[1].End : '';
              },
            ],
            ipd: [
              '$dest*',
              function(d) {
                return d.IP ? d.IP.join(',') : '';
              },
            ],
            portd_begin: [
              '$dest*',
              function(d) {
                return d.Ports ? d.Ports[1].Start : '';
              },
            ],
            portd_end: [
              '$dest*',
              function(d) {
                return d.Ports ? d.Ports[1].End : '';
              },
            ],
          });
          return pattern.build({
            $input: input,
          });
        }
        var T = __webpack_require__(84).T,
          _ = __webpack_require__(3),
          wanConverter = __webpack_require__(144),
          lanConverter = __webpack_require__(121);
        module.exports = {
          somovdToNative: somovdToNative,
          nativeToSomovd: nativeToSomovd,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(218),
        converter: __webpack_require__(219),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        funcs = (__webpack_require__(140), __webpack_require__(5));
      module.exports = function() {
        function getDefaultRule(config, attrs) {
          function getBiggestId(rules) {
            var ids = _.pluck(rules, '__id');
            return ids.length ? _.max(ids) + 1 : 1;
          }
          if (attrs) {
            var defaultModel = funcs.newConfig.makeDefaultModel(attrs.Rules);
            return (
              _.has(defaultModel, 'Enable') && (defaultModel.Enable = !0),
              _.has(defaultModel, 'Action') && (defaultModel.Action = 'ACCEPT'),
              defaultModel
            );
          }
          return {
            Enable: !0,
            Action: 'ACCEPT',
            MACAddress: '',
            Hostname: '',
            __id: getBiggestId(config.Rules),
          };
        }

        function changeConfig(config, opts) {
          var workCopy = funcs.deepClone(config);
          if (
            ((opts = opts || {}),
            opts.removeIndexes &&
              _.each(opts.removeIndexes.reverse(), function(index) {
                workCopy.Rules.splice(index, 1);
              }),
            opts.editRules)
          ) {
            var rule = opts.editRules.rule,
              index = opts.editRules.index;
            _.isUndefined(index)
              ? workCopy.Rules.push(rule)
              : (workCopy.Rules[index] = rule);
          }
          return workCopy;
        }

        function accessWillLost(config) {
          function getClientState(config) {
            var clientMac = config.Client.MACAddress,
              rule = _.find(config.Rules, function(elem) {
                return elem.MACAddress == clientMac;
              });
            return rule && rule.Enable ? rule.Action : 'NONE';
          }
          var baseAction = config.BaseRule.Action,
            clientAction = getClientState(config);
          return 'DROP' == baseAction && 'ACCEPT' != clientAction
            ? !0
            : 'DROP' == clientAction
              ? !0
              : !1;
        }

        function getUsedMacList(config, withoutIndex) {
          return config && config.Rules
            ? _.chain(config.Rules)
                .filter(function(r, i) {
                  return _.isUndefined(withoutIndex) ? !0 : i != withoutIndex;
                })
                .map(function(rule) {
                  return {
                    mac: rule.MACAddress,
                  };
                })
                .value()
            : [];
        }

        function isNotUniqRule(config, curRule, curIndex) {
          var useRules = getUsedMacList(config, curIndex);
          return _.some(useRules, function(rule) {
            return rule.mac.toUpperCase() == curRule.MACAddress.toUpperCase();
          });
        }

        function makeSomovdRequests(changed, init) {
          function getWriteChanges(changed, init) {
            var rules = [];
            return (
              _.each(changed, function(elem) {
                var id = elem.id,
                  initRule = _.find(init, function(e) {
                    return e.id == id;
                  });
                if (initRule) {
                  var compareRule = _.omit(elem, '__pos');
                  _.isEqual(initRule, compareRule) || rules.push(elem);
                } else rules.push(elem);
              }),
              rules
            );
          }

          function getRemoveChanges(changed, init) {
            var rules = [];
            return (
              _.each(init, function(elem, index) {
                var id = elem.id,
                  changedRule = _.find(changed, function(e) {
                    return e.id == id;
                  });
                changedRule || ((elem.__pos = index), rules.push(elem));
              }),
              rules
            );
          }

          function makeWriteList(rules) {
            return _.map(rules, function(elem) {
              return {
                id: 74,
                data: _.omit(elem, '__pos'),
                pos: elem.__pos,
              };
            });
          }

          function makeRemoveList(rules) {
            return (
              (rules = _.sortBy(rules, function(inx) {
                return -rules.id;
              })),
              _.map(rules, function(rule) {
                return {
                  id: 74,
                  data: _.omit(rule, '__pos'),
                  pos: rule.__pos,
                };
              })
            );
          }
          var requests = {},
            writeChanges = getWriteChanges(changed, init),
            removeChanges = getRemoveChanges(changed, init);
          return (
            _.size(writeChanges) &&
              (requests.write = makeWriteList(writeChanges)),
            _.size(removeChanges) &&
              (requests.remove = makeRemoveList(removeChanges)),
            requests
          );
        }
        return {
          getDefaultRule: getDefaultRule,
          changeConfig: changeConfig,
          accessWillLost: accessWillLost,
          getUsedMacList: getUsedMacList,
          isNotUniqRule: isNotUniqRule,
          makeSomovdRequests: makeSomovdRequests,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function somovdToNative(input) {
          function getBaseRule() {
            return {
              id: 0,
              state: !1,
              mac: null,
              enable: 'DROP',
            };
          }
          var pattern = T({
            '->': ['$macfilter', 'BaseRule', 'Rules', 'Client'],
            $input: ':external',
            $macfilter: [
              '$input',
              function(i) {
                return i.macfilter;
              },
            ],
            $ifaces: [
              '$input',
              function(i) {
                return i.ifaces;
              },
            ],
            $client: [
              '$input',
              function(i) {
                return i.client;
              },
            ],
            __hasBaseRule: [
              '$macfilter',
              function(mf) {
                return !(!mf || !mf[0]);
              },
            ],
            BaseRule: {
              '->': !0,
              $macfilter: [
                '$parent',
                function(p) {
                  return p.$macfilter;
                },
              ],
              $baseRule: [
                '$macfilter',
                function(mf) {
                  return mf && mf[0] ? mf[0] : getBaseRule();
                },
              ],
              Action: [
                '$baseRule',
                function(r) {
                  return r.state ? 'DROP' : 'ACCEPT';
                },
              ],
            },
            Rules: {
              '->': !0,
              '{$rule, $index}': [
                '$parent',
                function(p) {
                  return _.filter(p.$macfilter, function(r) {
                    return !_.isNull(r.mac);
                  });
                },
              ],
              __id: [
                '$rule*',
                function(r) {
                  return r.id;
                },
              ],
              __pos: [
                '$index*',
                function(i) {
                  return i + 1;
                },
              ],
              Enable: [
                '$rule*',
                function(r) {
                  return r.state;
                },
              ],
              Action: [
                '$rule*',
                function(r) {
                  return r.enable;
                },
              ],
              MACAddress: [
                '$rule*',
                function(r) {
                  return r.mac;
                },
              ],
              Hostname: [
                '$rule*',
                function(r) {
                  return r.hostname;
                },
              ],
            },
            Client: {
              '->': !0,
              $client: [
                '$parent',
                function(p) {
                  return p.$client;
                },
              ],
              MACAddress: [
                '$client',
                function(c) {
                  return c.mac;
                },
              ],
            },
          });
          return pattern.build({
            $input: input,
          });
        }

        function nativeToSomovd(input) {
          function getRules(config) {
            function prepareBaseRule(rule) {
              return {
                __pos: 0,
                __id: 0,
                MACAddress: null,
                Enable: 'DROP' == rule.Action,
                Action: 'DROP',
              };
            }
            var output = [];
            return (
              config.BaseRule && output.push(prepareBaseRule(config.BaseRule)),
              config.Rules && (output = output.concat(config.Rules)),
              output
            );
          }
          var pattern = T({
            '->': !0,
            $input: ':external',
            $rules: [
              '$input',
              function(i) {
                return getRules(i);
              },
            ],
            '{$rule}': [
              '$rules',
              function(rs) {
                return rs;
              },
            ],
            __pos: [
              '$rule*',
              function(r) {
                return _.isUndefined(r.__pos) ? -1 : r.__pos;
              },
            ],
            id: [
              '$rule*',
              function(r) {
                return r.__id;
              },
            ],
            state: [
              '$rule*',
              function(r) {
                return r.Enable;
              },
            ],
            enable: [
              '$rule*',
              function(r) {
                return r.Action;
              },
            ],
            mac: [
              '$rule*',
              function(r) {
                return r.MACAddress;
              },
            ],
            hostname: [
              '$rule*',
              function(r) {
                return r.Hostname;
              },
            ],
          });
          return pattern.build({
            $input: input,
          });
        }
        var T = __webpack_require__(84).T,
          _ = __webpack_require__(3);
        module.exports = {
          somovdToNative: somovdToNative,
          nativeToSomovd: nativeToSomovd,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        lanConverter: __webpack_require__(121),
        Helper: __webpack_require__(221),
        attrsConverter: __webpack_require__(222),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function IPFilter(ipfilter, lan, attributes) {
        function getRules() {
          function transformRule(rule, index) {
            return (
              (rule.__index = index),
              _.has(rule, 'action') &&
                (rule.action = _.find(actionMap, function(e) {
                  return e.value == rule.action;
                }).name),
              _.has(rule, 'proto') &&
                (rule.proto = _.find(protoMap, function(e) {
                  return e.value == rule.proto;
                }).name),
              (rule.IPVersion = rule.is_ipv6 ? 'IPv6' : 'IPv4'),
              rule
            );
          }
          var rules = funcs.deepClone(ipfilter);
          return _.map(rules, transformRule);
        }

        function getRule(index) {
          return funcs.deepClone(ipfilter[index]);
        }

        function getDefaultTemplate(attrs) {
          var template = {};
          return (
            attrs || (attrs = attributes),
            _.each(attrs, function(obj, key) {
              if (obj.__Template) template[key] = getDefaultTemplate(obj);
              else {
                if (!obj.supported || !_.has(obj, 'default')) return;
                template[key] = obj['default'];
              }
            }),
            template
          );
        }

        function getActions() {
          return _.filter(actionMap, function(e) {
            return _.contains(attributes.action['enum'], e.value);
          });
        }

        function getProtocols() {
          return _.filter(protoMap, function(e) {
            return _.contains(attributes.proto['enum'], e.value);
          });
        }

        function getBiggestID() {
          var ids = _.pluck(getRules(), 'id');
          return ids.length ? _.max(ids) + 1 : 1;
        }

        function makeRemoveList(indexes) {
          return (
            (indexes = indexes.sort().reverse()),
            _.map(indexes, function(index) {
              return {
                data: ipfilter[index],
                pos: index,
              };
            })
          );
        }

        function validation(rule, param) {
          function validationPort(rule, param) {
            function isValidPort(port) {
              function isValidPortRanges(ranges) {
                return _.every(ranges, function(elem) {
                  var startPort = elem.split(':')[0],
                    endPort = elem.split(':')[1];
                  return startPort || endPort
                    ? startPort && !funcs.is.port(startPort)
                      ? !1
                      : endPort && !funcs.is.port(endPort)
                        ? !1
                        : _.isUndefined(startPort) ||
                          _.isUndefined(endPort) ||
                          ('' != startPort && '' != endPort)
                          ? startPort &&
                            endPort &&
                            parseInt(startPort) >= parseInt(endPort)
                            ? !1
                            : !0
                          : !1
                    : !1;
                });
              }

              function isOverlapPortRanges(ranges) {
                function belongRange(range, port) {
                  var rangeStartPort = range.split(':')[0],
                    rangeEndPort = range.split(':')[1];
                  return !port ||
                    (!rangeStartPort && !rangeEndPort) ||
                    (!rangeStartPort && port != rangeEndPort) ||
                    (!rangeEndPort && port != rangeStartPort)
                    ? !1
                    : port >= rangeStartPort && rangeEndPort >= port;
                }
                return _.some(ranges, function(range) {
                  var startPort = range.split(':')[0],
                    endPort = range.split(':')[1];
                  return _.some(_.without(ranges, range), function(elem) {
                    return belongRange(elem, startPort)
                      ? !0
                      : belongRange(elem, endPort)
                        ? !0
                        : !1;
                  });
                });
              }
              if (/\s/.test(port)) return !1;
              var portRanges = port.split(',');
              return isValidPortRanges(portRanges)
                ? isOverlapPortRanges(portRanges)
                  ? !1
                  : !0
                : !1;
            }

            function isWrongFormat(port, comparePort) {
              var arrPort = port.split(','),
                arrComparePort = comparePort.split(',');
              return arrPort.length != arrComparePort.length
                ? !0
                : _.some(arrPort, function(elem, index) {
                    return (
                      arrPort[index].split(':').length !=
                      arrComparePort[index].split(':').length
                    );
                  });
            }

            function isWrongNumber(port, comparePort) {
              function getPortRangeNumber(range) {
                var startPort = range.split(':')[0],
                  endPort = range.split(':')[1];
                return startPort && endPort
                  ? parseInt(endPort) - parseInt(startPort)
                  : 1;
              }
              var arrPort = port.split(','),
                arrComparePort = comparePort.split(',');
              return _.some(arrPort, function(elem, index) {
                var portNumber = getPortRangeNumber(elem),
                  comparePortNumber = getPortRangeNumber(arrComparePort[index]);
                return portNumber != comparePortNumber;
              });
            }
            var port = rule[param];
            if (!port) return null;
            if (!isValidPort(port)) return 'ipfilterInvalidPort';
            var comparePort = 'ports' == param ? rule.portd : rule.ports;
            return comparePort && isValidPort(comparePort)
              ? isWrongFormat(port, comparePort)
                ? 'ipfilterWrongFormatPort'
                : isWrongNumber(port, comparePort)
                  ? 'ipfilterWrongNumberPort'
                  : null
              : null;
          }
          switch (param) {
            case 'ports':
            case 'portd':
              return validationPort(rule, param);
          }
          return null;
        }

        function conflicts(rule, index) {
          function compareParam(obj1, obj2, param) {
            return _.has(obj1, param) && _.has(obj2, param)
              ? obj1[param] == obj2[param]
              : !0;
          }
          var comparedFields = [
              'name',
              'proto',
              'is_ipv6',
              'ips',
              'ipd',
              'ports',
              'portd',
            ],
            findIndex = _.findIndex(ipfilter, function(elem, inx) {
              return _.isUndefined(index) || index != inx
                ? _.every(comparedFields, _.partial(compareParam, elem, rule))
                : !1;
            });
          if (-1 == findIndex) return null;
          var rule = getRule(findIndex);
          return _.has(rule, 'id') ? rule.id : rule.name;
        }

        function accessWillLost(rule, client) {
          function checkLocalIPs(localIPs, destIP, sourceIP) {
            var result = !1;
            return (
              _.every(localIPs, function(obj) {
                var localIP = obj.Address;
                return (
                  (isBelongIPRange(destIP[0], destIP[1], localIP) ||
                    isBelongIPRange(sourceIP[0], sourceIP[1], localIP)) &&
                    (result = !0),
                  result
                );
              }),
              result
            );
          }

          function checkClientIP(clientIP, destIP, sourceIP) {
            return (
              (isBelongIPRange(destIP[0], destIP[1], clientIP) &&
                isAllRange(sourceIP)) ||
              (isBelongIPRange(sourceIP[0], sourceIP[1], clientIP) &&
                isAllRange(destIP))
            );
          }
          if (0 == rule.state) return !1;
          if (1 != rule.action) return !1;
          if (rule.is_ipv6) return !1;
          var localIPs = lan[1].IPv4.StaticIP,
            clientIP = client.ip,
            destIP = prepareIP(rule.ipd),
            sourceIP = prepareIP(rule.ips);
          return checkLocalIPs(localIPs, destIP, sourceIP)
            ? !0
            : checkClientIP(clientIP, destIP, sourceIP)
              ? !0
              : !1;
        }

        function isLocalRule(rule) {
          function checkFn(range, ip) {
            return (
              !ip || (ip && funcs.ipv4.subnet.belongNetworkRange(range, ip))
            );
          }
          var localIPs = lan[1].IPv4.StaticIP,
            destIP = prepareIP(rule.ipd),
            sourceIP = prepareIP(rule.ips);
          return _.some(localIPs, function(obj) {
            var range = funcs.ipv4.subnet.getNetworkRange(
              obj.Address,
              obj.SubnetMask
            );
            return (
              checkFn(range, destIP[0]) &&
              checkFn(range, destIP[1]) &&
              checkFn(range, sourceIP[0]) &&
              checkFn(range, sourceIP[1])
            );
          });
        }

        function isBelongIPRange(start, end, ip) {
          return start && end
            ? funcs.ipv4.subnet.belongNetworkRange(
                {
                  start: start,
                  end: end,
                },
                ip
              )
            : start
              ? start == ip
              : end
                ? end == ip
                : !1;
        }

        function prepareIP(ip) {
          if ('' == ip) return ['0.0.0.0', '255.255.255.255'];
          if (!funcs.is.ipv4Network(ip)) return ip.split('-');
          var arrIP = ip.split('/'),
            addr = arrIP[0],
            mask = funcs.ipv4.mask['long'](arrIP[1]),
            range = funcs.ipv4.subnet.getNetworkRange(addr, mask);
          return [range.start, range.end];
        }

        function isAllRange(ip) {
          return '' == ip || '0.0.0.0/0' == ip;
        }

        function isSupported(param) {
          function getSupported() {
            var attrs = __flattenAttrs();
            return _.chain(attrs)
              .keys()
              .filter(function(path) {
                return attrs[path].supported;
              })
              .value();
          }
          return (
            cache.supported || (cache.supported = getSupported()),
            _.contains(cache.supported, param)
          );
        }

        function isRequired(param) {
          function getRequired() {
            var attrs = __flattenAttrs();
            return _.chain(attrs)
              .keys()
              .filter(function(path) {
                return attrs[path].required;
              })
              .value();
          }
          return (
            cache.required || (cache.required = getRequired()),
            _.contains(cache.required, param)
          );
        }

        function __flattenAttrs(rootPath) {
          var result = {},
            attrs = rootPath ? __getAttrsByPath(rootPath) : attributes;
          return (
            _.each(attrs, function(elem, key) {
              if ('__Template' != key) {
                var path = rootPath ? rootPath + '.' + key : key;
                elem.__Template
                  ? _.extend(result, __flattenAttrs(path))
                  : (result[path] = elem);
              }
            }),
            result
          );
        }

        function __getAttrsByPath(path) {
          var result = null;
          return (
            _.each(path.split('.'), function(key) {
              result = result ? result[key] : attributes[key];
            }),
            result
          );
        }
        if (!(this instanceof IPFilter))
          return new IPFilter(ipfilter, lan, attributes);
        var ipfilter = funcs.deepClone(ipfilter),
          lan = funcs.deepClone(lan),
          attributes = funcs.deepClone(attributes),
          cache = {},
          actionMap = [
            {
              name: 'ipfilterActionAccept',
              value: 0,
            },
            {
              name: 'ipfilterActionDrop',
              value: 1,
            },
          ],
          protoMap = [
            {
              name: 'TCP/UDP',
              value: 0,
            },
            {
              name: 'TCP',
              value: 1,
            },
            {
              name: 'UDP',
              value: 2,
            },
            {
              name: 'ICMP',
              value: 3,
            },
            {
              name: 'allProtocols',
              value: 4,
            },
          ];
        return {
          getRules: getRules,
          getRule: getRule,
          getActions: getActions,
          getProtocols: getProtocols,
          getBiggestID: getBiggestID,
          makeRemoveList: makeRemoveList,
          validation: validation,
          conflicts: conflicts,
          accessWillLost: accessWillLost,
          isLocalRule: isLocalRule,
          getDefaultTemplate: getDefaultTemplate,
          isSupported: isSupported,
          isRequired: isRequired,
        };
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      (funcs.is = __webpack_require__(73)),
        (funcs.ipv4 = __webpack_require__(74)),
        (module.exports = IPFilter);
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var T = __webpack_require__(84).T;
      __webpack_require__(3),
        (module.exports = function(input) {
          var pattern = T({
            '->': ['$brcm', 'ipv6', 'id', 'name', 'state', 'is_ipv6'],
            $input: ':external',
            $brcm: [
              '$input',
              function(i) {
                return i.BRCM;
              },
            ],
            $ipv6: [
              '$input',
              function(i) {
                return i.BRIPV6;
              },
            ],
            id: {
              '->': !0,
              supported: [
                '$root',
                function(r) {
                  return r.$brcm;
                },
              ],
              type: 'string',
            },
            name: {
              '->': !0,
              supported: [
                '$root',
                function(r) {
                  return r.$brcm;
                },
              ],
              type: 'string',
              default: '',
              required: !0,
            },
            state: {
              '->': !0,
              supported: [
                '$root',
                function(r) {
                  return r.$brcm;
                },
              ],
              type: 'boolean',
              default: !0,
            },
            is_ipv6: {
              '->': !0,
              supported: [
                '$root',
                function(r) {
                  return r.$ipv6;
                },
              ],
              type: 'boolean',
              default: !1,
            },
            action: {
              supported: !0,
              type: 'number',
              default: 0,
              enum: [0, 1],
            },
            proto: {
              supported: !0,
              type: 'number',
              default: 0,
              enum: [0, 1, 2, 3, 4],
            },
            ipd: {
              supported: !0,
              type: 'ipv4/ipv6',
              default: '',
            },
            ips: {
              supported: !0,
              type: 'ipv4/ipv6',
              default: '',
            },
            portd: {
              supported: !0,
              type: 'port',
              default: '',
            },
            ports: {
              supported: !0,
              type: 'port',
              default: '',
            },
          });
          return pattern.build({
            $input: input,
          });
        });
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(224),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function UrlFilter(config, list, workList) {
        function formList(list) {
          function listPrepare(list) {
            return _.map(list, function(elem, index) {
              return (elem.__index = index), elem;
            });
          }

          function getOriginal(list) {
            for (var index = 0; list[index] && hasWWW(list[index].url); )
              index++;
            return list[index]
              ? list.splice(index, 1)[0]
              : list.splice(0, 1)[0];
          }

          function getDub(list, originalURL) {
            if (!originalURL) return {};
            var index = _.findIndex(list, function(elem) {
              return elem.url == 'www.' + originalURL;
            });
            return -1 != index ? list.splice(index, 1)[0] : {};
          }
          var result = [];
          for (list = listPrepare(list); list.length; ) {
            var obj = {};
            (obj.original = getOriginal(list)),
              (obj.dub = getDub(list, obj.original.url)),
              result.push(obj);
          }
          return result;
        }

        function getConfig() {
          return config;
        }

        function getList() {
          return _.map(workList, function(elem) {
            return elem.original;
          });
        }

        function getClientsList() {
          if (config.clients_list) {
            var clientsList = [];
            for (var key in config.clients_list)
              clientsList.push(config.clients_list[key]);
            return clientsList;
          }
        }

        function updateClientsList(list) {
          (config.clients_list = {}),
            _.each(list, function(elem, inx) {
              config.clients_list[inx + 1] = elem;
            });
        }

        function addRule(rule) {
          setRule(rule);
        }

        function setRule(rule, inx) {
          function getOriginal(rule) {
            var obj = funcs.deepClone(rule);
            return _.omit(obj, '__index');
          }

          function getDub(rule) {
            var obj = funcs.deepClone(rule);
            return (
              (obj.url = hasWWW(obj.url)
                ? obj.url.replace(/^www\./, '')
                : 'www.' + obj.url),
              _.omit(obj, '__index')
            );
          }
          normalizeRule(rule);
          var obj = {
            original: getOriginal(rule),
            dub: getDub(rule),
          };
          if (_.isUndefined(inx)) workList.push(obj);
          else {
            var curRule = workList[inx];
            (curRule.original = _.extend(curRule.original, obj.original)),
              (curRule.dub = _.extend(curRule.dub, obj.dub));
          }
        }

        function removeRule(inx) {
          __initWorkList[inx]
            ? ((workList[inx].original.__removed = !0),
              (workList[inx].dub.__removed = !0))
            : workList.splice(inx, 1);
        }

        function normalizeRule(rule) {
          rule.url = rule.url.toLowerCase();
        }

        function wasModified(newConfig) {
          return wasModifiedConfig(newConfig) || wasModifiedList();
        }

        function wasModifiedConfig(newConfig) {
          return __initConfig && !_.isEqual(newConfig, __initConfig);
        }

        function wasModifiedList() {
          return __initWorkList
            ? __initWorkList.length != workList.length
              ? !0
              : _.some(__initWorkList, function(elem, index) {
                  var original = angular.fromJson(
                    angular.toJson(workList[index].original)
                  );
                  return (
                    (!_.isEqual(elem.original, original) &&
                      !_.isEqual(elem.dub, workList[index].dub)) ||
                    (!_.isEqual(elem.original, original) &&
                      _.isEqual(elem.dub, workList[index].dub))
                  );
                })
            : !1;
        }

        function hasWWW(url) {
          return /^www\./.test(url);
        }

        function supportedParam(obj, param) {
          return _.has(obj, param);
        }

        function prepareSettings(settings) {
          function getConfigRequests(config) {
            var data = {
              enable: config.enable,
              type: config.enable ? config.type : __initConfig.type,
            };
            return (
              supportedParam(config, 'show_block_page') &&
                (data.show_block_page = config.enable
                  ? config.show_block_page
                  : __initConfig.show_block_page),
              supportedParam(config, 'clients_mode') &&
                (data.clients_mode = config.clients_mode),
              supportedParam(config, 'clients_list') &&
                (data.clients_list = config.clients_list),
              {
                config: data,
              }
            );
          }

          function getListWriteRequests(list) {
            var requests = [];
            return (
              _.each(list, function(elem, index) {
                var __initElem = __initList[index];
                (__initElem && _.isEqual(__initElem, elem)) ||
                  requests.push({
                    data: elem,
                    pos: __initElem ? index : -1,
                  });
              }),
              {
                list: requests,
              }
            );
          }

          function getListRemoveRequests(list) {
            function getRemoveIndexes() {
              var indexes = _.range(0, list.length).reverse();
              return _.filter(indexes, function(index) {
                return _.has(list[index], '__removed') && __initList[index];
              });
            }
            var indexes = getRemoveIndexes();
            return _.map(indexes, function(index) {
              var elem = funcs.deepClone(list[index]);
              return (
                list.splice(index, 1),
                __initList.splice(index, 1),
                {
                  data: _.omit(elem, '__removed'),
                  pos: index,
                }
              );
            });
          }

          function formList(list) {
            function appendRule(rule) {
              _.has(rule, '__index')
                ? (result[rule.__index] = _.omit(rule, '__index'))
                : newRules.push(rule);
            }
            var result = [],
              newRules = [];
            return (
              _.each(list, function(elem) {
                var orig = elem.original,
                  dub = elem.dub;
                _.isEmpty(orig) || appendRule(orig),
                  _.isEmpty(dub) || appendRule(dub);
              }),
              (result = result.concat(newRules))
            );
          }
          var write = [],
            remove = [];
          if (
            (wasModifiedConfig(settings.config) &&
              write.push(getConfigRequests(config)),
            wasModifiedList())
          ) {
            var list = formList(workList);
            (remove = remove.concat(getListRemoveRequests(list))),
              (write = write.concat(getListWriteRequests(list)));
          }
          var result = {};
          return (
            write.length && (result.write = write),
            remove.length && (result.remove = remove),
            result
          );
        }
        if (!(this instanceof UrlFilter))
          return new UrlFilter(config, workList);
        var config = funcs.deepClone(config),
          list = funcs.deepClone(list),
          workList = workList ? funcs.deepClone(workList) : formList(list),
          __initConfig = funcs.deepClone(config),
          __initList = funcs.deepClone(list),
          __initWorkList = funcs.deepClone(workList),
          urlfilter = {
            getConfig: getConfig,
            getList: getList,
            getClientsList: getClientsList,
            updateClientsList: updateClientsList,
            addRule: addRule,
            setRule: setRule,
            removeRule: removeRule,
            wasModified: wasModified,
            prepareSettings: prepareSettings,
          };
        return urlfilter;
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      module.exports = UrlFilter;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var yandexSettings = __webpack_require__(226),
        yandexRules = __webpack_require__(227);
      module.exports = {
        rules: yandexRules,
        settings: yandexSettings,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function pull() {
        clean();
        var promise = transport.read(_yandexSettingsRpc, handleResponse);
        return promise;
      }

      function handleResponse(response) {
        var data = _.defaults(response && response.data ? response.data : {}, {
          enabled: !1,
          default: 'safe',
        });
        (_yandexSettingsInitial = _.clone(data)), setConfig(data);
      }

      function push() {
        var promise = transport
          .write(_yandexSettingsRpc, _yandexSettings)
          .then(function() {
            _yandexSettingsInitial = _.clone(_yandexSettings);
          });
        return promise;
      }

      function getConfig() {
        return _yandexSettings;
      }

      function setConfig(obj) {
        _yandexSettings = _.clone(obj);
      }

      function clean() {
        (_yandexSettings = null), (_yandexSettingsInitial = null);
      }

      function getAvailableModes() {
        return _.clone(_availableModes);
      }

      function wasModified() {
        return !_.isEqual(_yandexSettingsInitial, _yandexSettings);
      }
      var _ = __webpack_require__(3),
        transport = __webpack_require__(140).get(),
        _yandexSettingsRpc = (__webpack_require__(5), 179),
        _yandexSettings = null,
        _yandexSettingsInitial = null,
        _availableModes = [
          {
            value: 'off',
            label: 'yandex_dns_protection_off_mode',
          },
          {
            value: 'safe',
            label: 'yandex_dns_safe_mode',
          },
          {
            value: 'child',
            label: 'yandex_dns_child_mode',
          },
        ];
      module.exports = {
        pull: pull,
        push: push,
        getConfig: getConfig,
        setConfig: setConfig,
        getAvailableModes: getAvailableModes,
        handleResponse: handleResponse,
        wasModified: wasModified,
        clean: clean,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function getClients() {
        return _clients;
      }

      function setCliens(array) {
        _clients = array;
      }

      function getSettings() {
        return _yandexSettings;
      }

      function setSettings(obj) {
        _yandexSettings = obj;
      }

      function getRules() {
        return _yandexRules;
      }

      function setRules(array) {
        (_yandexRules = array),
          (_clients = _.map(_dhcpRpcModel, clientToModel));
      }

      function getRpcIndex(rpc) {
        return _.indexOf(_rpcList, rpc);
      }

      function pull() {
        function readCb(response) {
          var getRpcData = function(dataIndex) {
            return response.rq[dataIndex] && response.rq[dataIndex].data
              ? response.rq[dataIndex].data
              : {};
          };
          (_wanRpcModel = getRpcData(getRpcIndex(_wanRpc))),
            (_dhcpRpcModel = getRpcData(getRpcIndex(_dhcpRpc))),
            (_yandexSettingsRpcModel = getRpcData(
              getRpcIndex(_yandexSettingsRpc)
            )),
            mapDataToModel(
              _wanRpcModel,
              _dhcpRpcModel,
              _yandexSettingsRpcModel
            );
        }
        var transport = somovd.get();
        clean();
        var promise = transport.read(_rpcList, readCb);
        return promise;
      }

      function clientToModel(client) {
        var rule = _.findWhere(getRules(), {
          mac: client.mac,
          ip: client.ip,
        });
        return _.extend({}, client, {
          rule: rule,
        });
      }

      function settingsToModel(settings) {
        return _.extend({}, settings);
      }

      function extendRules(rules, yandexInfo) {
        return (
          _.each(rules, function(rule) {
            rule && (rule.mode = rule.mode ? rule.mode : yandexInfo['default']);
          }),
          rules
        );
      }

      function getRulesFromRpc(wanInfo) {
        return _.chain(wanInfo ? wanInfo.iface_names : [])
          .toArray()
          .pluck('services')
          .map(_.toArray)
          .flatten()
          .pluck('dhcpd')
          .compact()
          .pluck('reserved')
          .flatten()
          .compact()
          .value();
      }

      function mapDataToModel(wanInfo, dhcpInfo, yandexInfo) {
        var rules = getRulesFromRpc(wanInfo);
        (rules = extendRules(rules, yandexInfo)),
          setRules(rules),
          (_clients = _.map(dhcpInfo, clientToModel)),
          setCliens(_clients);
        var settings = settingsToModel(yandexInfo);
        setSettings(settings);
      }

      function ruleToRpc(rule) {
        return _.pick(rule, 'ip', 'mac', 'hostname', 'mode');
      }

      function push() {
        var transport = somovd.get(),
          rpcWriteModel = {
            br0: funcs.deepClone(_wanRpcModel.iface_names.br0),
          };
        rpcWriteModel.br0.services.br0.dhcpd.reserved = _.map(
          _yandexRules,
          ruleToRpc
        );
        var promise = transport.write(_wanRpc, rpcWriteModel);
        return (
          promise.then(function() {
            _.extend(_wanRpcModel.iface_names, rpcWriteModel);
          }),
          promise
        );
      }

      function clean() {
        (_yandexRules = null), (_clients = null), (_yandexSettings = null);
      }

      function getAreas() {
        return _rpcList.join('|');
      }

      function setFromDevinfoResponse(rpcResponses) {
        (_wanRpcModel = rpcResponses[getRpcIndex(_wanRpc)]),
          (_dhcpRpcModel = rpcResponses[getRpcIndex(_dhcpRpc)]),
          (_yandexSettingsRpcModel =
            rpcResponses[getRpcIndex(_yandexSettingsRpc)]),
          mapDataToModel(_wanRpcModel, _dhcpRpcModel, _yandexSettingsRpcModel);
      }

      function wasModified() {
        function normalizeModel(item) {
          return _.pick(item, 'ip', 'mac', 'mode', 'hostname');
        }
        if (!_wanRpcModel) return !1;
        var initialRules = getRulesFromRpc(_wanRpcModel),
          currentRules = _.map(_yandexRules, ruleToRpc);
        return (
          initialRules.length != currentRules.length ||
          _.some(initialRules, function(ir) {
            return !_.some(currentRules, function(cr) {
              return _.isEqual(normalizeModel(cr), normalizeModel(ir));
            });
          })
        );
      }
      var _ = __webpack_require__(3),
        somovd = __webpack_require__(140),
        funcs = __webpack_require__(5),
        _wanRpc = 1,
        _dhcpRpc = 187,
        _yandexSettingsRpc = 179,
        _rpcList = [_wanRpc, _dhcpRpc, _yandexSettingsRpc],
        _wanRpcModel = null,
        _dhcpRpcModel = null,
        _yandexSettingsRpcModel = null,
        _yandexRules = null,
        _clients = null,
        _yandexSettings = null;
      module.exports = {
        pull: pull,
        push: push,
        getSettings: getSettings,
        getClients: getClients,
        getRules: getRules,
        setRules: setRules,
        getAreas: getAreas,
        setFromDevinfoResponse: setFromDevinfoResponse,
        wasModified: wasModified,
        clean: clean,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(230),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function StatsRouting(config) {
        function getData() {
          return config ? config : {};
        }

        function getDestString(elem) {
          var ipWithMask = elem.mask
            ? elem.dest + '/' + funcs.ipv4.mask['short'](elem.mask)
            : elem.dest;
          return elem.gw && '' != elem.gw
            ? ipWithMask + ' - ' + elem.gw
            : ipWithMask;
        }
        if (!(this instanceof StatsRouting)) return new StatsRouting(config);
        var config = funcs.deepClone(config);
        return {
          getData: getData,
          getDestString: getDestString,
        };
      }
      var funcs = (__webpack_require__(3), __webpack_require__(5));
      module.exports = StatsRouting;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var somovd = __webpack_require__(140).get(),
        funcs = __webpack_require__(5),
        _ = __webpack_require__(3);
      module.exports = (function() {
        function remoteUpdate(success, error, done) {
          var isFirmwareUpload = !0,
            uploadingWaitTime = 5e3;
          somovd.write(
            178,
            {
              need_update: !0,
            },
            function(response) {
              (isFirmwareUpload = !1),
                tryCall(funcs.is.RPCSuccess(response) ? success : error),
                tryCall(done);
            }
          ),
            setTimeout(function() {
              isFirmwareUpload && tryCall(success);
            }, uploadingWaitTime);
        }

        function tryCall(fn) {
          _.isFunction(fn) && fn();
        }
        return {
          reboot: somovd.reboot,
          save: somovd.save,
          reset: somovd.reset,
          backup: somovd.backup,
          remoteUpdate: remoteUpdate,
        };
      })();
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(242),
        constants: __webpack_require__(243),
        converter: __webpack_require__(244),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function SystemTime(config, attrs) {
        function getData() {
          var result = {
              ntp: {},
              time: {},
            },
            ntp = funcs.fetchBranch(config, paths.ntp),
            time = funcs.fetchBranch(config, paths.time);
          return (
            (result.ntp.Enable = ntp.Enable),
            (result.ntp.TimeZoneOffset = unionOffset(
              ntp.TimeZoneHourOffset,
              ntp.TimeZoneMinuteOffset
            )),
            (result.ntp.Server = _.map(
              funcs.newConfig.normalize(ntp.Server),
              function(value, inst) {
                return {
                  address: value,
                  __id: inst,
                };
              }
            )),
            _.has(ntp, 'DST') && (result.ntp.DST = ntp.DST),
            _.has(ntp, 'UseDHCP') && (result.ntp.UseDHCP = ntp.UseDHCP),
            _.has(ntp, 'RunAsServer') &&
              (result.ntp.RunAsServer = ntp.RunAsServer),
            (result.time = time),
            result
          );
        }

        function formConfig(data) {
          function prepareNtp(ntp) {
            return (
              (ntp.Server = prepareNtpServer(ntp.Server)),
              prepareOffset(ntp),
              ntp
            );
          }

          function prepareNtpServer(server) {
            var result = {};
            return (
              _.each(server, function(elem, inx) {
                if (elem.address) {
                  var inst = elem.__id ? elem.__id : 'new_inst_' + inx;
                  result[inst] = elem.address;
                }
              }),
              result
            );
          }

          function prepareOffset(ntp) {
            var arrOffset = ntp.TimeZoneOffset.split(':');
            (ntp.TimeZoneHourOffset = Number(arrOffset[0])),
              (ntp.TimeZoneMinuteOffset = Number(arrOffset[1])),
              delete ntp.TimeZoneOffset;
          }
          var config = {},
            input = funcs.deepClone(data);
          return (
            (input.ntp = prepareNtp(input.ntp)),
            funcs.setValue(paths.ntp.replace(/\.$/, ''), input.ntp, config),
            funcs.setValue(paths.time.replace(/\.$/, ''), input.time, config),
            config
          );
        }

        function getTimeStamp(input) {
          return new Date(
            input.Year,
            input.Month - 1,
            input.Day,
            input.Hour,
            input.Minute
          ).getTime();
        }

        function getTimeZones() {
          var result = [];
          if (attrs)
            var ntpAttrs = funcs.fetchBranch(attrs, paths.ntp),
              start = ntpAttrs.TimeZoneHourOffset.minInclusive,
              end = ntpAttrs.TimeZoneHourOffset.maxInclusive;
          else
            var start = -12,
              end = 12;
          for (var i = start; end >= i; i++) {
            var sign = identifySign(i),
              name = i.toString();
            result.push({
              sign: sign,
              name: name,
              value: unionOffset(i, 0),
            }),
              _.contains([-4, -3, 3, 4, 5, 6, 9], i) &&
                result.push({
                  sign: sign,
                  name: name + '30',
                  value: unionOffset(i, 30),
                }),
              5 == i &&
                result.push({
                  sign: sign,
                  name: name + '45',
                  value: unionOffset(i, 45),
                });
          }
          return result;
        }

        function unionOffset(hour, minute) {
          var sign = identifySign(hour),
            hour = Math.abs(hour).toString(),
            minute = minute.toString();
          return (
            1 == hour.length && (hour = '0' + hour),
            1 == minute.length && (minute = '0' + minute),
            sign + hour + ':' + minute
          );
        }

        function identifySign(hour) {
          return hour > 0 ? '+' : 0 > hour ? '-' : '';
        }
        var config = funcs.deepClone(config),
          attrs = funcs.deepClone(attrs);
        return {
          getData: getData,
          formConfig: formConfig,
          getTimeStamp: getTimeStamp,
          getTimeZones: getTimeZones,
          unionOffset: unionOffset,
        };
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        paths = __webpack_require__(243).paths;
      module.exports = SystemTime;
    },
    function(module, exports) {
      'use strict';
      module.exports = {
        paths: {
          time: 'Device.System.Time.',
          ntp: 'Device.Services.NTP.',
        },
        rpc: 65,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToDsysinit(input) {
        function getTimeZoneHour(hour) {
          var hour = hour.split(':')[0];
          return -1 * new Number(hour);
        }

        function getTimeZoneMinute(hour) {
          var minute = hour.split(':')[1];
          return minute || 0;
        }
        var pattern = T({
          '->': !0,
          $input: ':external',
          Device: {
            System: {
              Time: {
                '->': !0,
                $input: [
                  '$root',
                  function(r) {
                    return r.$input;
                  },
                ],
                $time: [
                  '$input',
                  function(i) {
                    return i.time;
                  },
                ],
                Day: [
                  '$time',
                  function(t) {
                    return t.tm_mday;
                  },
                ],
                Minute: [
                  '$time',
                  function(t) {
                    return t.tm_min;
                  },
                ],
                Hour: [
                  '$time',
                  function(t) {
                    return t.tm_hour;
                  },
                ],
                Month: [
                  '$time',
                  function(t) {
                    return t.tm_mon;
                  },
                ],
                Year: [
                  '$time',
                  function(t) {
                    return t.tm_year;
                  },
                ],
              },
            },
            Services: {
              NTP: {
                '->': !0,
                $input: [
                  '$root',
                  function(r) {
                    return r.$input;
                  },
                ],
                Enable: [
                  '$input',
                  function(i) {
                    return i.enable;
                  },
                ],
                Server: {
                  '->': !0,
                  $input: [
                    '$root',
                    function(r) {
                      return r.$input;
                    },
                  ],
                  '{$value,$i}': [
                    '$input',
                    function(i) {
                      return i.servers;
                    },
                  ],
                  ':': [
                    '$i*',
                    function(i) {
                      return i + 1;
                    },
                  ],
                  $return: [
                    '$value',
                    function(v) {
                      return v;
                    },
                  ],
                },
                TimeZoneHourOffset: [
                  '$input',
                  function(i) {
                    return getTimeZoneHour(i.hour);
                  },
                ],
                TimeZoneMinuteOffset: [
                  '$input',
                  function(i) {
                    return getTimeZoneMinute(i.hour);
                  },
                ],
                DST: [
                  '$input',
                  function(i) {
                    return i.dst || !1;
                  },
                ],
                UseDHCP: [
                  '$input',
                  function(i) {
                    return i.use_dhcp;
                  },
                ],
                RunAsServer: [
                  '$input',
                  function(i) {
                    return i.run_as_serv;
                  },
                ],
              },
            },
          },
        });
        return pattern.build({
          $input: input,
        });
      }

      function dsysinitToSomovd(input) {
        function getHour(hourOffset, minuteOffset) {
          var output = '';
          return (
            0 != hourOffset && (hourOffset = -1 * hourOffset),
            (output += hourOffset),
            minuteOffset && (output += ':' + minuteOffset),
            output
          );
        }
        var pattern = T({
          '->': ['$time', '$ntp', 'time', 'servers'],
          $input: ':external',
          $time: [
            '$input',
            function(i) {
              return i.Device.System.Time;
            },
          ],
          $ntp: [
            '$input',
            function(i) {
              return i.Device.Services.NTP;
            },
          ],
          time: {
            '->': !0,
            $time: [
              '$root',
              function(r) {
                return r.$time;
              },
            ],
            tm_mday: [
              '$time',
              function(t) {
                return t.Day;
              },
            ],
            tm_min: [
              '$time',
              function(t) {
                return t.Minute;
              },
            ],
            tm_hour: [
              '$time',
              function(t) {
                return t.Hour;
              },
            ],
            tm_mon: [
              '$time',
              function(t) {
                return t.Month;
              },
            ],
            tm_year: [
              '$time',
              function(t) {
                return t.Year;
              },
            ],
          },
          enable: [
            '$ntp',
            function(n) {
              return n.Enable;
            },
          ],
          hour: [
            '$ntp',
            function(n) {
              return getHour(n.TimeZoneHourOffset, n.TimeZoneMinuteOffset);
            },
          ],
          servers: {
            '->': !0,
            $ntp: [
              '$root',
              function(r) {
                return r.$ntp;
              },
            ],
            '{$value,$i}': [
              '$ntp',
              function(n) {
                return n.Server;
              },
            ],
            $return: [
              '$value',
              function(v) {
                return v;
              },
            ],
          },
          dst: [
            '$ntp',
            function(n) {
              return n.DST;
            },
          ],
          use_dhcp: [
            '$ntp',
            function(n) {
              return n.UseDHCP;
            },
          ],
          run_as_serv: [
            '$ntp',
            function(n) {
              return n.RunAsServer;
            },
          ],
        });
        return pattern.build({
          $input: input,
        });
      }
      var T = (__webpack_require__(3), __webpack_require__(84).T);
      module.exports = {
        somovdToDsysinit: somovdToDsysinit,
        dsysinitToSomovd: dsysinitToSomovd,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        converterSyslog: __webpack_require__(246),
        converterUsbInfo: __webpack_require__(247),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToNative(input) {
        function getDestination(value) {
          switch (value) {
            case 'local':
              return 'Local';
            case 'remote':
              return 'Remote';
            case 'both':
              return 'Both';
          }
        }
        var pattern = T({
          '->': !0,
          '?': [
            '$input',
            function(i) {
              return !!i;
            },
          ],
          $input: ':external',
          Enable: [
            '$input',
            function(s) {
              return s.enable;
            },
          ],
          Destination: [
            '$input',
            function(i) {
              return getDestination(i.type);
            },
          ],
          Level: [
            '$input',
            function(i) {
              return i.level;
            },
          ],
          Server: [
            '$input',
            function(i) {
              return i.server;
            },
          ],
          Port: [
            '$input',
            function(i) {
              return i.port;
            },
          ],
          Log2USB: {
            '->': !0,
            $settings: [
              '$root',
              function(r) {
                return r.$input;
              },
            ],
            Enable: [
              '$settings',
              function(s) {
                return s.log2usb || !1;
              },
            ],
            RotateSize: [
              '$settings',
              function(s) {
                return s.log2usb_rotatesize || 0;
              },
            ],
            RotateNumber: [
              '$settings',
              function(s) {
                return _.has(s, 'log2usb_rotatenumber') &&
                  0 != s.log2usb_rotatesize
                  ? s.log2usb_rotatenumber + 1
                  : 1;
              },
            ],
            Directory: [
              '$settings',
              function(s) {
                return s.log2usb_partition || '';
              },
            ],
            File: [
              '$settings',
              function(s) {
                return s.log2usb_filename || '';
              },
            ],
            InvalidPath: [
              '$settings',
              function(s) {
                return '' != s.log2usb_partition ? s.isInvalidPath : !1;
              },
            ],
          },
        });
        return pattern.build({
          $input: input,
        });
      }

      function nativeToSomovd(input) {
        function getDestination(value) {
          switch (value) {
            case 'Local':
              return 'local';
            case 'Remote':
              return 'remote';
            case 'Both':
              return 'both';
          }
        }
        var pattern = T({
          '->': !0,
          $input: ':external',
          $usb: [
            '$input',
            function(i) {
              return i.Log2USB;
            },
          ],
          enable: [
            '$input',
            function(i) {
              return i.Enable;
            },
          ],
          type: [
            '$input',
            function(i) {
              return getDestination(i.Destination);
            },
          ],
          level: [
            '$input',
            function(i) {
              return i.Level;
            },
          ],
          server: [
            '$input',
            function(i) {
              return i.Server;
            },
          ],
          port: [
            '$input',
            function(i) {
              return i.Port;
            },
          ],
          log2usb: [
            '$usb*',
            function(u) {
              return u.Enable;
            },
          ],
          log2usb_rotatesize: [
            '$usb*',
            function(u) {
              return u.RotateSize;
            },
          ],
          log2usb_rotatenumber: [
            '$usb*',
            function(u) {
              return u.RotateNumber - 1;
            },
          ],
          log2usb_partition: [
            '$usb*',
            function(u) {
              return u.Directory;
            },
          ],
          log2usb_filename: [
            '$usb*',
            function(u) {
              return u.File;
            },
          ],
        });
        return pattern.build({
          $input: input,
        });
      }

      function attrsToNative() {
        function getLevels() {
          return [0, 1, 2, 3, 4, 5, 6, 7];
        }

        function getDestinationList() {
          return ['Local', 'Remote', 'Both'];
        }
        return {
          Levels: getLevels(),
          Destination: getDestinationList(),
        };
      }
      var _ = __webpack_require__(3),
        T = __webpack_require__(84).T;
      module.exports = {
        somovdToNative: somovdToNative,
        nativeToSomovd: nativeToSomovd,
        attrsToNative: attrsToNative,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToNative(input) {
        var pattern = T({
          '->': !0,
          $input: ':external',
          '?': [
            '$usb',
            function(u) {
              return !!u;
            },
          ],
          '{$usb, Mountpoint}': [
            '$input',
            function(i) {
              return i;
            },
          ],
          Filesystem: [
            '$usb',
            function(u) {
              return u.file_system;
            },
          ],
          Device: [
            '$usb',
            function(u) {
              return u.name;
            },
          ],
          Disable: !1,
          Total: [
            '$usb',
            function(u) {
              return funcs.lookSize(1024 * u.total * 1024).toString();
            },
          ],
          Free: [
            '$usb',
            function(u) {
              return funcs.lookSize(1024 * u.free * 1024).toString();
            },
          ],
        });
        return pattern.build({
          $input: input,
        });
      }
      var T = (__webpack_require__(3), __webpack_require__(84).T),
        funcs = __webpack_require__(5);
      module.exports = {
        somovdToNative: somovdToNative,
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        converter: __webpack_require__(249),
        constants: __webpack_require__(250),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToNative(input) {
        var pattern = T({
          '->': !0,
          $input: ':external',
          Device: {
            Services: {
              RemoteUpdate: {
                '->': !0,
                $input: [
                  '$root',
                  function(r) {
                    return r.$input;
                  },
                ],
                Enable: [
                  '$input',
                  function(i) {
                    return i.enable;
                  },
                ],
                Server: [
                  '$input',
                  function(i) {
                    return i.server;
                  },
                ],
                Period: [
                  '$input',
                  function(i) {
                    return i.period || void 0;
                  },
                ],
                Version: [
                  '$input',
                  function(i) {
                    return i.version;
                  },
                ],
              },
            },
          },
        });
        return pattern.build({
          $input: input,
        });
      }

      function nativeToSomovd(input) {
        var pattern = T({
          '->': ['$settings', 'settings'],
          $input: ':external',
          $settings: [
            '$input',
            function(i) {
              return i.Device.Services.RemoteUpdate;
            },
          ],
          enable: [
            '$settings',
            function(s) {
              return s.Enable;
            },
          ],
          server: [
            '$settings',
            function(s) {
              return s.Server;
            },
          ],
          period: [
            '$settings',
            function(s) {
              return s.Period;
            },
          ],
          version: [
            '$settings',
            function(s) {
              return s.Version;
            },
          ],
        });
        return pattern.build({
          $input: input,
        });
      }
      var T = (__webpack_require__(3), __webpack_require__(84).T),
        T = __webpack_require__(84).T;
      module.exports = {
        somovdToNative: somovdToNative,
        nativeToSomovd: nativeToSomovd,
      };
    },
    function(module, exports) {
      'use strict';
      module.exports = {
        paths: {
          remoteUpdate: 'Device.Services.RemoteUpdate.',
        },
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(252),
        converter: __webpack_require__(253),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function StatsDHCP(config) {
        function getData() {
          return config ? config : {};
        }

        function getLeaseExpiresTime(elem) {
          return elem.lease ? funcs.lookTime(elem.lease) : '-';
        }
        if (!(this instanceof StatsDHCP)) return new StatsDHCP(config);
        var config = funcs.deepClone(config);
        return {
          getData: getData,
          getLeaseExpiresTime: getLeaseExpiresTime,
        };
      }
      var funcs = (__webpack_require__(3), __webpack_require__(5));
      module.exports = StatsDHCP;
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function dsysinitToNative(data) {
        function getDHCPServer(input) {
          var dhcp = funcs.newConfig.normalize(
              funcs.fetchBranch(input, paths.dhcpServer)
            ),
            dhcpv6 = funcs.newConfig.normalize(
              funcs.fetchBranch(input, paths.dhcpV6Server)
            ),
            result = {
              0: dhcp,
              1: dhcpv6,
            };
          return result;
        }
        var pattern = T({
          '->': !0,
          $data: ':external',
          '{$servers}': [
            '$data',
            function(d) {
              return getDHCPServer(d);
            },
          ],
          '{$dhcp}': [
            '$servers',
            function(s) {
              return s;
            },
          ],
          '?': [
            '$client',
            function(c) {
              return !!c;
            },
          ],
          '{$client}': [
            '$dhcp',
            function(d) {
              return d
                ? funcs.newConfig.normalize(funcs.fetchBranch(d, paths.stats))
                : void 0;
            },
          ],
          hostname: [
            '$client',
            function(c) {
              return c.HostName;
            },
          ],
          ip: [
            '$client',
            function(c) {
              return c.IP;
            },
          ],
          MACAddress: [
            '$client',
            function(c) {
              return c.MAC;
            },
          ],
          lease: [
            '$client',
            function(c) {
              return c.LeaseTimeout;
            },
          ],
        });
        return pattern.build({
          $data: data,
        });
      }
      var T = __webpack_require__(84).T,
        funcs = (__webpack_require__(3), __webpack_require__(5)),
        paths = __webpack_require__(254).paths;
      module.exports = {
        dsysinitToNative: dsysinitToNative,
      };
    },
    function(module, exports) {
      'use strict';
      module.exports = {
        paths: {
          dhcpServer: 'Device.Network.Server.DHCP.',
          dhcpV6Server: 'Device.Network.Server.DHCPv6.',
          stats: 'Statistic.Client.',
        },
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(256),
        converter: __webpack_require__(258),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule
          ? obj
          : {
              default: obj,
            };
      }

      function PortSettings(config) {
        function getData() {
          return config ? sortData() : {};
        }

        function sortData() {
          if (!config.order) return config.ports;
          var sortData = [];
          return (
            _.each(config.order, function(elem) {
              sortData.push(
                _.findWhere(config.ports, {
                  __id: parseInt(elem),
                })
              );
            }),
            sortData
          );
        }

        function getAdvertisementKeys(advertisement) {
          if (advertisement) {
            var result = _keys2['default'](advertisement);
            return result;
          }
          return {};
        }

        function getSpeedList(speeds) {
          var result = [];
          return (
            result.push('auto'),
            speeds && (result = result.concat(_keys2['default'](speeds))),
            result
          );
        }

        function prepareData(port, speed) {
          var result = {};
          return (result =
            'auto' !== speed
              ? {
                  __id: port.__id,
                  name: port.name,
                  autonegotiation: !1,
                  speed: speed,
                }
              : {
                  __id: port.__id,
                  name: port.name,
                  autonegotiation: !0,
                  advertisement: port.advertisement,
                  pause: port.pause,
                });
        }
        if (!(this instanceof PortSettings)) return new PortSettings(config);
        var config = funcs.deepClone(config);
        return {
          getData: getData,
          getAdvertisementKeys: getAdvertisementKeys,
          getSpeedList: getSpeedList,
          prepareData: prepareData,
        };
      }
      var _keys = __webpack_require__(150),
        _keys2 = _interopRequireDefault(_keys),
        _ = __webpack_require__(3),
        funcs = (__webpack_require__(131),
        __webpack_require__(135),
        __webpack_require__(5));
      __webpack_require__(257), (module.exports = PortSettings);
    },
    function(module, exports) {
      'use strict';
      module.exports = {
        ports: 'Device.Switch.1.Ports.',
        vlansPath: 'Device.Switch.1.Vlan.',
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function somovdToNative(data) {
          function getIface(input) {
            var result = [];
            return (
              _.each(input, function(elem, name) {
                result.push({
                  port: elem,
                  name: name,
                });
              }),
              result
            );
          }
          var pattern = T({
            '->': !0,
            $data: ':external',
            ports: {
              '->': !0,
              '{$iface, __id}': [
                '$parent',
                function(p) {
                  return getIface(p.$data);
                },
              ],
              $port: [
                '$iface',
                function(i) {
                  return i.port;
                },
              ],
              name: [
                '$iface',
                function(i) {
                  return i.name;
                },
              ],
              status: [
                '$port',
                function(p) {
                  return p.status;
                },
              ],
              autonegotiation: [
                '$port',
                function(p) {
                  return p.autonegotiation;
                },
              ],
              advertisement: [
                '$port',
                function(p) {
                  return p.advertisement;
                },
              ],
              pause: [
                '$port',
                function(p) {
                  return p.pause;
                },
              ],
              speed: [
                '$port',
                function(p) {
                  return p.speed;
                },
              ],
              flowControl: [
                '$port',
                function(p) {
                  return funcs.fetchBranch(p, 'flow-control');
                },
              ],
            },
          });
          return pattern.build({
            $data: data,
          });
        }

        function nativeToSomovd(data) {
          var result = {};
          return (
            (result[data.name] = {
              autonegotiation: data.autonegotiation,
              speed: data.speed,
              pause: data.pause,
              advertisement: data.advertisement,
            }),
            result
          );
        }
        var T = __webpack_require__(84).T,
          _ = __webpack_require__(3),
          funcs = __webpack_require__(5);
        module.exports = {
          somovdToNative: somovdToNative,
          nativeToSomovd: nativeToSomovd,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        constructor: __webpack_require__(260),
        converter: __webpack_require__(261),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      module.exports = function() {
        function getFreeConnections(config) {
          var allInst = _.pluck(config.Connections, 'Value'),
            failoverInst = getFailoverConnections(config);
          return _.difference(allInst, failoverInst);
        }

        function isCrossMasterConnection(config, slaveIndex) {
          var master = config.Connection.Master,
            value = config.Connection.Slave[slaveIndex];
          return master == value;
        }

        function isCrossSlaveConnection(config, slaveIndex) {
          var slaves = funcs.deepClone(config.Connection.Slave);
          _.isUndefined(slaveIndex) || slaves.splice(slaveIndex, 1);
          var value = config.Connection.Slave[slaveIndex];
          return _.contains(slaves, value);
        }

        function checkHost(host, hosts, index) {
          if (!host) return null;
          if (!funcs.is.ipv4(host)) return 'invalid_ipv4';
          var hostsList = funcs.deepClone(hosts);
          return (
            !_.isUndefined(index) &&
              index < hostsList.length &&
              hostsList.splice(index, 1),
            _.contains(hostsList, host) ? 'error_value_is_not_uniq' : null
          );
        }

        function checkRecheckTimeout(config) {
          if (!_.has(config, 'PingRetries')) return null;
          var minValue = (config.PingRetries * config.PingTimeout) / 1e3;
          return config.RecheckTimeout <= minValue
            ? {
                error: !0,
                minValue: minValue,
              }
            : null;
        }

        function checkFreeConnections(config) {
          var allInst = config.Connections,
            failoverInst = getFailoverConnections(config);
          return failoverInst.length < allInst.length;
        }

        function getFailoverConnections(config, slaveIndex) {
          var master = config.Connection.Master,
            slaves = funcs.deepClone(config.Connection.Slave);
          return (
            _.isUndefined(slaveIndex) || slaves.splice(slaveIndex, 1),
            [master].concat(slaves)
          );
        }
        return {
          getFreeConnections: getFreeConnections,
          isCrossMasterConnection: isCrossMasterConnection,
          isCrossSlaveConnection: isCrossSlaveConnection,
          checkHost: checkHost,
          checkRecheckTimeout: checkRecheckTimeout,
          checkFreeConnections: checkFreeConnections,
        };
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function somovdToNative(input) {
          function getConnectionList(w) {
            var output = [],
              ifaces = w.iface_names;
            return (
              _.each(ifaces, function(iface) {
                iface.is_wan &&
                  _.each(iface.services, function(service, ifname) {
                    (service.type && /v6$/.test(service.type)) ||
                      ('auto' != service.type &&
                        output.push({
                          Name: service.name,
                          Value: ifname,
                          DefaultGateway: service.gwif ? service.gwif : !1,
                        }),
                      _.each(service.tunnels, function(tunnel, ifname) {
                        output.push({
                          Name: tunnel.name,
                          Value: ifname,
                          DefaultGateway: service.gwif ? service.gwif : !1,
                        });
                      }));
                  });
              }),
              output
            );
          }

          function getBasicConn(conns) {
            var gwConn = _.find(conns, function(c) {
              return c.DefaultGateway;
            });
            return gwConn ? gwConn.Value : '';
          }

          function getBackupConn(conns, master) {
            var backupConn = _.filter(conns, function(c) {
              return c.Value != master;
            });
            return backupConn.length ? backupConn[0].Value : '';
          }
          var pattern = T({
            '->': ['$wanReserv', '$wan', 'Hosts', 'Connections', 'Connection'],
            $input: ':external',
            $wanReserv: [
              '$input',
              function(i) {
                return i[210];
              },
            ],
            $wan: [
              '$input',
              function(i) {
                return i[1];
              },
            ],
            Enable: [
              '$wanReserv',
              function(wr) {
                return wr.enable || !1;
              },
            ],
            PingTimeout: [
              '$wanReserv',
              function(wr) {
                return wr.icmp_timeout || 3;
              },
            ],
            RecheckTimeout: [
              '$wanReserv',
              function(wr) {
                return wr.icmp_interval || 10;
              },
            ],
            FailoverAttempts: [
              '$wanReserv',
              function(wr) {
                return wr.failover_attempts || 3;
              },
            ],
            RecoveryAttempts: [
              '$wanReserv',
              function(wr) {
                return wr.recovery_attempts || 5;
              },
            ],
            Connection: {
              '->': !0,
              $wanReserv: [
                '$parent',
                function(p) {
                  return p.$wanReserv;
                },
              ],
              $conns: [
                '$parent',
                function(p) {
                  return p.Connections;
                },
              ],
              $master: [
                '$wanReserv',
                '$conns',
                function(wr, conns) {
                  return wr.master_iface
                    ? wr.master_iface
                    : getBasicConn(conns);
                },
              ],
              $slave: [
                '$wanReserv',
                '$conns',
                '$master',
                function(wr, conns, master) {
                  return wr.slave_iface
                    ? wr.slave_iface
                    : getBackupConn(conns, master);
                },
              ],
              Master: [
                '$master',
                function(m) {
                  return m;
                },
              ],
              Slave: [
                '$slave',
                function(s) {
                  return [s];
                },
              ],
            },
            MultiHosts: !1,
            Hosts: {
              '->': !0,
              $wanReserv: [
                '$parent',
                function(p) {
                  return p.$wanReserv;
                },
              ],
              '{$raw}': [
                '$wanReserv',
                function(wr) {
                  return [wr.icmp_host];
                },
              ],
              $return: [
                '$raw',
                function(r) {
                  return r || '8.8.8.8';
                },
              ],
            },
            Connections: {
              '->': !0,
              $wan: [
                '$parent',
                function(p) {
                  return p.$wan;
                },
              ],
              $return: [
                '$wan',
                function(w) {
                  return getConnectionList(w);
                },
              ],
            },
            TimeSystem: 's',
            MinMax: {
              RecheckTimeout: {
                min: 1,
                max: 60,
              },
              PingTimeout: {
                min: 1,
                max: 10,
              },
              FailoverAttempts: {
                min: 1,
                max: 10,
              },
              RecoveryAttempts: {
                min: 1,
                max: 10,
              },
            },
          });
          return pattern.build({
            $input: input,
          });
        }

        function nativeToSomovd(input) {
          var pattern = T({
            '->': !0,
            $input: ':external',
            enable: [
              '$input',
              function(i) {
                return i.Enable;
              },
            ],
            icmp_timeout: [
              '$input',
              function(i) {
                return i.PingTimeout;
              },
            ],
            icmp_interval: [
              '$input',
              function(i) {
                return i.RecheckTimeout;
              },
            ],
            failover_attempts: [
              '$input',
              function(i) {
                return i.FailoverAttempts;
              },
            ],
            recovery_attempts: [
              '$input',
              function(i) {
                return i.RecoveryAttempts;
              },
            ],
            icmp_host: [
              '$input',
              function(i) {
                return i.Hosts[0];
              },
            ],
            master_iface: [
              '$input',
              function(i) {
                return i.Connection.Master;
              },
            ],
            slave_iface: [
              '$input',
              function(i) {
                return i.Connection.Slave[0];
              },
            ],
          });
          return pattern.build({
            $input: input,
          });
        }
        var T = __webpack_require__(84).T,
          _ = __webpack_require__(3);
        module.exports = {
          nativeToSomovd: nativeToSomovd,
          somovdToNative: somovdToNative,
        };
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(263),
        converter: __webpack_require__(265),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function Udpxy(config) {
        function getIfaces() {
          var ifaces = config ? config.Interfaces : {},
            result = [];
          return (
            _.each(ifaces, function(elem, identifer) {
              var normalizeElem = funcs.newConfig.normalize(elem);
              _.each(normalizeElem, function(iface, num) {
                result.push({
                  name: iface.Ifname || iface.Name,
                  value: constants.interfaces + identifer + '.' + num + '.',
                });
              });
            }),
            result
          );
        }

        function getData() {
          var data = _.omit(config, 'Interfaces');
          return data;
        }
        if (!(this instanceof Udpxy)) return new Udpxy(config);
        var config = funcs.deepClone(config);
        return {
          getData: getData,
          getIfaces: getIfaces,
        };
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5),
        constants = __webpack_require__(264);
      module.exports = Udpxy;
    },
    function(module, exports) {
      'use strict';
      module.exports = {
        udpxy: 'Device.Services.Udpxy.',
        igmpxEnable: 'Device.Services.IGMPX.Enable',
        interfaces: 'Device.Network.Interface.',
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToNative(data) {
        var pattern = T({
          '->': !0,
          '?': [
            '$data',
            function(d) {
              return !!d;
            },
          ],
          $data: ':external',
          Enable: [
            '$data',
            function(d) {
              return d.enabled;
            },
          ],
          BufCli: [
            '$data',
            function(d) {
              return d.bufcli;
            },
          ],
          SocBuf: [
            '$data',
            function(d) {
              return d.socbuf;
            },
          ],
          MaxCli: [
            '$data',
            function(d) {
              return d.maxcli;
            },
          ],
          DefaultIface: [
            '$data',
            function(d) {
              return d.default_iface;
            },
          ],
          AllowAllPorts: !0,
          Port: [
            '$data',
            function(d) {
              return d.port;
            },
          ],
        });
        return pattern.build({
          $data: data,
        });
      }

      function nativeToSomovd(data) {
        var pattern = T({
          '->': !0,
          $data: ':external',
          enabled: [
            '$data',
            function(d) {
              return d.Enable;
            },
          ],
          bufcli: [
            '$data',
            function(d) {
              return d.BufCli.toString();
            },
          ],
          socbuf: [
            '$data',
            function(d) {
              return d.SocBuf.toString();
            },
          ],
          maxcli: [
            '$data',
            function(d) {
              return d.MaxCli.toString();
            },
          ],
          default_iface: [
            '$data',
            function(d) {
              return d.DefaultIface;
            },
          ],
          port: [
            '$data',
            function(d) {
              return d.Port.toString();
            },
          ],
        });
        return pattern.build({
          $data: data,
        });
      }
      var T = (__webpack_require__(3), __webpack_require__(84).T);
      module.exports = {
        somovdToNative: somovdToNative,
        nativeToSomovd: nativeToSomovd,
      };
    },
    function(module, exports) {
      module.exports = function() {};
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        Helper: __webpack_require__(268),
        converter: __webpack_require__(269),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function DDNS(config) {
        function getDdns() {
          return config && config.DDNS ? config.DDNS : {};
        }

        function getIfaces() {
          return config && config.Ifaces ? config.Ifaces : {};
        }

        function getServices() {
          return config && config.Services ? config.Services : {};
        }

        function getConfiguration() {
          return config
            ? {
                Multihostname: config.MultiHostname,
                NeedChooseIface: config.NeedChooseIface,
                MultiDdns: config.MultiDdns,
              }
            : {};
        }

        function getAvailIfaces(currentIface) {
          function isWan(iface) {
            return iface.IsWan;
          }

          function isAvail(iface) {
            return (
              (currentIface && iface.Iface === currentIface) ||
              !~getBusyIfaces().indexOf(iface.Iface)
            );
          }

          function getBusyIfaces() {
            return config.DDNS.map(function(iface) {
              return iface.Iface;
            });
          }
          return config.Ifaces.filter(isWan).filter(isAvail);
        }

        function getRule(index) {
          function getDefaultTemplate() {
            return {
              System: '',
              Hostname: config.MultiHostname
                ? [
                    {
                      Name: '',
                    },
                  ]
                : '',
              Service: '',
              Period: '',
              Username: '',
              Iface: '',
              Password: '',
            };
          }
          var result;
          return (
            (result = _.isUndefined(index)
              ? getDefaultTemplate()
              : config.DDNS[index]),
            _.isUndefined(result) ? getDefaultTemplate() : result
          );
        }

        function getCurrentService(serviceName) {
          var service = _.findWhere(config.Services, {
            Name: serviceName,
          });
          return service ? service : config.Services[0];
        }
        if (!(this instanceof DDNS)) return new DDNS(config);
        var config = funcs.deepClone(config);
        return {
          getDdns: getDdns,
          getIfaces: getIfaces,
          getAvailIfaces: getAvailIfaces,
          getRule: getRule,
          getServices: getServices,
          getCurrentService: getCurrentService,
          getConfiguration: getConfiguration,
        };
      }
      var _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      module.exports = DDNS;
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      !(function() {
        function somovdToNative(data) {
          var pattern = T({
            '->': ['DDNS', 'Ifaces'],
            $data: ':external',
            MultiDdns: !1,
            MultiHostname: !1,
            NeedChooseIface: [
              '$root',
              function(r) {
                return r.$data.NeedChooseIface;
              },
            ],
            DDNS: {
              '->': !0,
              '?': [
                '$ddns',
                function(d) {
                  return !!d;
                },
              ],
              '{$ddns}': [
                '$root',
                function(r) {
                  return r.$data.ddns;
                },
              ],
              System: [
                '$ddns',
                function(d) {
                  return d.system;
                },
              ],
              Hostname: [
                '$ddns',
                function(d) {
                  return d.host_name;
                },
              ],
              Service: [
                '$ddns',
                function(d) {
                  return d.service;
                },
              ],
              Period: [
                '$ddns',
                function(d) {
                  return d.period;
                },
              ],
              Username: [
                '$ddns',
                function(d) {
                  return d.usr_name;
                },
              ],
              Iface: [
                '$ddns',
                function(d) {
                  return d.iface;
                },
              ],
              Password: [
                '$ddns',
                function(d) {
                  return d.pass;
                },
              ],
              Ssl: [
                '$ddns',
                function(d) {
                  return d.ssl;
                },
              ],
            },
            Ifaces: {
              '->': !0,
              '{$iface}': [
                '$root',
                function(r) {
                  return r.$data.ifaces;
                },
              ],
              Iface: [
                '$iface',
                function(i) {
                  return i.iface;
                },
              ],
              Name: [
                '$iface',
                function(i) {
                  return i.name;
                },
              ],
              IsWan: [
                '$iface',
                function(i) {
                  return i.is_wan;
                },
              ],
            },
            Services: [
              '$data',
              function(d) {
                return d.services;
              },
            ],
          });
          return pattern.build({
            $data: data,
          });
        }

        function nativeToSomovd(data) {
          var pattern = T({
            '->': ['ddns'],
            $data: ':external',
            system: [
              '$data',
              function(d) {
                return d.System;
              },
            ],
            host_name: [
              '$data',
              function(d) {
                return d.Hostname;
              },
            ],
            service: [
              '$data',
              function(d) {
                return d.Service;
              },
            ],
            period: [
              '$data',
              function(d) {
                return d.Period;
              },
            ],
            usr_name: [
              '$data',
              function(d) {
                return d.Username;
              },
            ],
            iface: [
              '$data',
              function(d) {
                return d.Iface;
              },
            ],
            pass: [
              '$data',
              function(d) {
                return d.Password;
              },
            ],
            ssl: [
              '$data',
              function(d) {
                return d.Ssl;
              },
            ],
          });
          return pattern.build({
            $data: data,
          });
        }
        var T = __webpack_require__(84).T;
        __webpack_require__(3),
          (module.exports = {
            somovdToNative: somovdToNative,
            nativeToSomovd: nativeToSomovd,
          });
      })();
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        converter: __webpack_require__(271),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      var T = __webpack_require__(84).T,
        _ = __webpack_require__(3),
        funcs = __webpack_require__(5);
      module.exports = {
        somovdToNative: function(data) {
          var pattern = T({
            '->': !0,
            $data: ':external',
            '?': [
              '$file',
              function(f) {
                return !!f;
              },
            ],
            '{$files}': [
              '$data',
              function(d) {
                return d.Files;
              },
            ],
            '{$file, $id}': [
              '$files',
              function(f) {
                return f;
              },
            ],
            Type: [
              '$data',
              '$file',
              function(d, f) {
                return d.Root ? 'root' : f.type ? 'folder' : 'file';
              },
            ],
            Free: [
              '$file',
              function(f) {
                return _.isUndefined(f.free)
                  ? '-'
                  : funcs.lookSize(1024 * f.free * 1024).toString();
              },
            ],
            Total: [
              '$file',
              function(f) {
                return _.isUndefined(f.total)
                  ? '-'
                  : funcs.lookSize(1024 * f.total * 1024).toString();
              },
            ],
            Filesystem: [
              '$file',
              function(f) {
                return f.file_system;
              },
            ],
            Key: [
              '$id',
              function(i) {
                return i;
              },
            ],
            Path: [
              '$data',
              '$id',
              function(d, i) {
                return d.Parent + '/' + i;
              },
            ],
            Alias: [
              '$id',
              '$file',
              function(i, f) {
                return i || f.name;
              },
            ],
            ModifyDate: [
              '$file',
              function(f) {
                return f.modify_date ? 1e3 * f.modify_date : void 0;
              },
            ],
            Name: [
              '$file',
              function(f) {
                return f.name;
              },
            ],
            Size: [
              '$file',
              function(f) {
                return _.isUndefined(f.size)
                  ? void 0
                  : funcs.lookSize(f.size).toString();
              },
            ],
          });
          return pattern.build({
            $data: data,
          });
        },
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';
      module.exports = {
        converter: __webpack_require__(273),
      };
    },
    function(module, exports, __webpack_require__) {
      'use strict';

      function somovdToNative(data) {
        function getMediaTypes() {
          return ['ALL', 'A', 'V', 'P'];
        }
        var pattern = T({
          '->': ['MediaDirs'],
          $data: ':external',
          Enable: [
            '$data',
            function(d) {
              return d.enabled;
            },
          ],
          Interval: [
            '$data',
            function(d) {
              return d.interval;
            },
          ],
          Name: [
            '$data',
            function(d) {
              return d.name;
            },
          ],
          MediaDirs: {
            '->': !0,
            '{$dirs}': [
              '$parent',
              function(p) {
                return p.$data.media_dirs;
              },
            ],
            Path: [
              '$dirs*',
              function(d) {
                return d.path;
              },
            ],
            Type: [
              '$dirs*',
              function(d) {
                return d.type;
              },
            ],
          },
          MediaTypes: getMediaTypes(),
          InvalidPath: [
            '$data',
            function(d) {
              return d.isInvalidPath;
            },
          ],
        });
        return pattern.build({
          $data: data,
        });
      }

      function nativeToSomovd(data) {
        var pattern = T({
          dlna: {
            '->': ['media_dirs'],
            $data: ':external',
            enabled: [
              '$data',
              function(d) {
                return d.Enable;
              },
            ],
            interval: [
              '$data',
              function(d) {
                return d.Interval;
              },
            ],
            name: [
              '$data',
              function(d) {
                return d.Name;
              },
            ],
            media_dirs: {
              '->': !0,
              '{$dirs}': [
                '$parent',
                function(p) {
                  return p.$data.MediaDirs;
                },
              ],
              type: [
                '$dirs*',
                function(d) {
                  return d.Type;
                },
              ],
              path: [
                '$dirs*',
                function(d) {
                  return d.Path;
                },
              ],
            },
          },
        });
        return pattern.build({
          $data: data,
        });
      }
      var T = __webpack_require__(84).T;
      __webpack_require__(3),
        (module.exports = {
          somovdToNative: somovdToNative,
          nativeToSomovd: nativeToSomovd,
        });
    },
  ]
);
